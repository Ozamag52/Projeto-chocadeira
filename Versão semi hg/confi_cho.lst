CCS PCH C Compiler, Version 5.015, 5967               29-jun-17 15:27

               Filename:   C:\Users\henri\Documents\GitHub\Projeto-chocadeira\Versão semi hg\confi_cho.lst

               ROM used:   10894 bytes (33%)
                           Largest free fragment is 21870
               RAM used:   111 (5%) at main() level
                           176 (9%) worst case
               Stack used: 7 locations (6 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   25CE
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  FF2.5
004A:  GOTO   0054
004E:  BTFSC  FF2.2
0050:  GOTO   0096
0054:  MOVFF  0E,00
0058:  MOVFF  0F,01
005C:  MOVFF  10,02
0060:  MOVFF  11,03
0064:  MOVFF  0C,FE9
0068:  MOVFF  07,FEA
006C:  BSF    07.7
006E:  MOVFF  08,FE1
0072:  MOVFF  09,FE2
0076:  MOVFF  0A,FD9
007A:  MOVFF  0B,FDA
007E:  MOVFF  12,FF3
0082:  MOVFF  13,FF4
0086:  MOVFF  14,FFA
008A:  MOVF   04,W
008C:  MOVFF  06,FE0
0090:  MOVFF  05,FD8
0094:  RETFIE 0
....................  
.................... #INCLUDE<18F4550.h>//   Inclui a biblioteca resposável por estabelecer os parametros do pic utilizado no projeto 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
*
00B6:  DATA 4D,45
00B8:  DATA 58,45
00BA:  DATA 4E,44
00BC:  DATA 4F,00
00BE:  DATA 43,4F
00C0:  DATA 4E,46
00C2:  DATA 49,47
00C4:  DATA 55,52
00C6:  DATA 41,43
00C8:  DATA 41,4F
00CA:  DATA 00,00
00CC:  DATA 49,4E
00CE:  DATA 43,55
00D0:  DATA 42,41
00D2:  DATA 44,4F
00D4:  DATA 52,41
00D6:  DATA 00,00
00D8:  DATA 43,4F
00DA:  DATA 4E,46
00DC:  DATA 49,47
00DE:  DATA 55,52
00E0:  DATA 41,43
00E2:  DATA 41,4F
00E4:  DATA 00,00
00E6:  DATA 53,45
00E8:  DATA 54,20
00EA:  DATA 54,45
00EC:  DATA 4D,50
00EE:  DATA 3A,20
00F0:  DATA 25,2E
00F2:  DATA 31,66
00F4:  DATA 20,20
00F6:  DATA 20,20
00F8:  DATA 20,20
00FA:  DATA 20,00
00FC:  DATA 43,4F
00FE:  DATA 4E,46
0100:  DATA 49,47
0102:  DATA 55,52
0104:  DATA 41,43
0106:  DATA 41,4F
0108:  DATA 00,00
010A:  DATA 53,45
010C:  DATA 54,20
010E:  DATA 55,4D
0110:  DATA 49,3A
0112:  DATA 20,25
0114:  DATA 2E,31
0116:  DATA 66,20
0118:  DATA 20,20
011A:  DATA 20,20
011C:  DATA 20,00
011E:  DATA 46,49
0120:  DATA 4D,20
0122:  DATA 44,41
0124:  DATA 00,00
0126:  DATA 43,4F
0128:  DATA 4E,46
012A:  DATA 49,47
012C:  DATA 55,52
012E:  DATA 41,43
0130:  DATA 41,4F
0132:  DATA 00,00
0134:  DATA 53,45
0136:  DATA 54,20
0138:  DATA 54,45
013A:  DATA 4D,50
013C:  DATA 3A,20
013E:  DATA 20,25
0140:  DATA 2E,31
0142:  DATA 66,20
0144:  DATA 20,20
0146:  DATA 20,20
0148:  DATA 20,20
014A:  DATA 20,00
014C:  DATA 53,45
014E:  DATA 54,20
0150:  DATA 55,4D
0152:  DATA 49,3A
0154:  DATA 20,20
0156:  DATA 20,25
0158:  DATA 2E,31
015A:  DATA 66,20
015C:  DATA 20,20
015E:  DATA 20,20
0160:  DATA 20,20
0162:  DATA 00,00
0164:  DATA 50,2F
0166:  DATA 56,4F
0168:  DATA 4C,54
016A:  DATA 41,52
016C:  DATA 20,41
016E:  DATA 20,00
0170:  DATA 43,4F
0172:  DATA 4E,46
0174:  DATA 49,47
0176:  DATA 55,52
0178:  DATA 41,43
017A:  DATA 41,4F
017C:  DATA 00,00
017E:  DATA 50,52
0180:  DATA 45,53
0182:  DATA 53,49
0184:  DATA 4F,4E
0186:  DATA 45,20
0188:  DATA 4F,20
018A:  DATA 00,00
018C:  DATA 42,4F
018E:  DATA 54,2E
0190:  DATA 20,43
0192:  DATA 4F,4E
0194:  DATA 46,49
0196:  DATA 47,55
0198:  DATA 52,41
019A:  DATA 43,41
019C:  DATA 4F,00
019E:  DATA 4F,55
01A0:  DATA 20,50
01A2:  DATA 52,45
01A4:  DATA 53,53
01A6:  DATA 49,4F
01A8:  DATA 4E,45
01AA:  DATA 00,00
01AC:  DATA 42,4F
01AE:  DATA 54,41
01B0:  DATA 4F,20
01B2:  DATA 49,4E
01B4:  DATA 49,43
01B6:  DATA 49,41
01B8:  DATA 52,00
01BA:  DATA 43,4F
01BC:  DATA 4E,46
01BE:  DATA 49,47
01C0:  DATA 55,52
01C2:  DATA 41,43
01C4:  DATA 41,4F
01C6:  DATA 00,00
01C8:  DATA 49,4E
01CA:  DATA 43,55
01CC:  DATA 42,41
01CE:  DATA 44,4F
01D0:  DATA 52,41
01D2:  DATA 00,00
01D4:  DATA 49,4E
01D6:  DATA 43,49
01D8:  DATA 41,4E
01DA:  DATA 44,4F
01DC:  DATA 20,41
01DE:  DATA 20,00
01E0:  DATA 49,4E
01E2:  DATA 43,55
01E4:  DATA 42,41
01E6:  DATA 44,4F
01E8:  DATA 52,41
01EA:  DATA 00,00
01EC:  DATA 49,4E
01EE:  DATA 43,55
01F0:  DATA 42,41
01F2:  DATA 44,4F
01F4:  DATA 52,41
01F6:  DATA 00,00
01F8:  DATA 44,45
01FA:  DATA 20,4F
01FC:  DATA 56,4F
01FE:  DATA 53,00
0200:  DATA 41,50
0202:  DATA 45,52
0204:  DATA 54,45
0206:  DATA 20,4F
0208:  DATA 20,42
020A:  DATA 4F,54
020C:  DATA 41,4F
020E:  DATA 00,00
0210:  DATA 43,4F
0212:  DATA 4E,46
0214:  DATA 49,47
0216:  DATA 55,52
0218:  DATA 41,43
021A:  DATA 41,4F
021C:  DATA 00,00
021E:  DATA 41,50
0220:  DATA 45,52
0222:  DATA 54,45
0224:  DATA 20,4F
0226:  DATA 20,42
0228:  DATA 4F,54
022A:  DATA 41,4F
022C:  DATA 00,00
022E:  DATA 49,4E
0230:  DATA 49,20
0232:  DATA 4F,55
0234:  DATA 20,43
0236:  DATA 4F,4E
0238:  DATA 46,49
023A:  DATA 47,00
023C:  DATA 41,4A
023E:  DATA 55,53
0240:  DATA 54,41
0242:  DATA 4E,44
0244:  DATA 4F,00
0246:  DATA 50,41
0248:  DATA 52,41
024A:  DATA 4D,45
024C:  DATA 4E,54
024E:  DATA 52,4F
0250:  DATA 53,2E
0252:  DATA 2E,2E
0254:  DATA 00,00
0256:  DATA 55,4D
0258:  DATA 49,44
025A:  DATA 41,44
025C:  DATA 45,3A
025E:  DATA 30,30
0260:  DATA 30,30
0262:  DATA 30,20
0264:  DATA 00,00
0266:  DATA 54,45
0268:  DATA 4D,50
026A:  DATA 2E,20
026C:  DATA 25,66
026E:  DATA 00,00
0270:  DATA 44,45
0272:  DATA 53,45
0274:  DATA 4A,41
0276:  DATA 20,50
0278:  DATA 41,52
027A:  DATA 41,52
027C:  DATA 20,41
027E:  DATA 20,00
0280:  DATA 49,4E
0282:  DATA 43,55
0284:  DATA 42,41
0286:  DATA 43,41
0288:  DATA 4F,3F
028A:  DATA 00,00
028C:  DATA 41,47
028E:  DATA 55,52
0290:  DATA 41,44
0292:  DATA 45,2E
0294:  DATA 2E,2E
0296:  DATA 00,00
0298:  DATA 49,4E
029A:  DATA 43,55
029C:  DATA 42,41
029E:  DATA 43,41
02A0:  DATA 4F,00
02A2:  DATA 49,4E
02A4:  DATA 43,55
02A6:  DATA 42,41
02A8:  DATA 43,41
02AA:  DATA 4F,00
02AC:  DATA 49,4E
02AE:  DATA 54,45
02B0:  DATA 52,52
02B2:  DATA 4F,4D
02B4:  DATA 50,49
02B6:  DATA 44,41
02B8:  DATA 00,00
02BA:  DATA 53,45
02BC:  DATA 54,20
02BE:  DATA 54,45
02C0:  DATA 4D,50
02C2:  DATA 3A,20
02C4:  DATA 20,25
02C6:  DATA 2E,31
02C8:  DATA 66,20
02CA:  DATA 20,20
02CC:  DATA 20,20
02CE:  DATA 20,20
02D0:  DATA 20,00
02D2:  DATA 53,45
02D4:  DATA 54,20
02D6:  DATA 55,4D
02D8:  DATA 49,3A
02DA:  DATA 20,20
02DC:  DATA 20,25
02DE:  DATA 2E,31
02E0:  DATA 66,20
02E2:  DATA 20,20
02E4:  DATA 20,20
02E6:  DATA 20,20
02E8:  DATA 00,00
*
0390:  TBLRD*+
0392:  MOVF   FF5,F
0394:  BZ    03AE
0396:  MOVFF  FF6,6F
039A:  MOVFF  FF7,70
039E:  MOVFF  FF5,7B
03A2:  RCALL  0374
03A4:  MOVFF  6F,FF6
03A8:  MOVFF  70,FF7
03AC:  BRA    0390
03AE:  RETURN 0
03B0:  MOVLW  8E
03B2:  MOVWF  00
03B4:  MOVFF  9F,01
03B8:  MOVFF  9E,02
03BC:  CLRF   03
03BE:  MOVF   01,F
03C0:  BNZ   03D4
03C2:  MOVFF  02,01
03C6:  CLRF   02
03C8:  MOVLW  08
03CA:  SUBWF  00,F
03CC:  MOVF   01,F
03CE:  BNZ   03D4
03D0:  CLRF   00
03D2:  BRA    03E4
03D4:  BCF    FD8.0
03D6:  BTFSC  01.7
03D8:  BRA    03E2
03DA:  RLCF   02,F
03DC:  RLCF   01,F
03DE:  DECF   00,F
03E0:  BRA    03D4
03E2:  BCF    01.7
03E4:  RETURN 0
03E6:  MOVF   x9A,W
03E8:  BTFSC  FD8.2
03EA:  BRA    04CE
03EC:  MOVWF  00
03EE:  MOVF   x9E,W
03F0:  BTFSC  FD8.2
03F2:  BRA    04CE
03F4:  ADDWF  00,F
03F6:  BNC   0400
03F8:  MOVLW  81
03FA:  ADDWF  00,F
03FC:  BC    04CE
03FE:  BRA    0408
0400:  MOVLW  7F
0402:  SUBWF  00,F
0404:  BNC   04CE
0406:  BZ    04CE
0408:  MOVFF  9B,A2
040C:  MOVF   x9F,W
040E:  XORWF  xA2,F
0410:  BSF    x9B.7
0412:  BSF    x9F.7
0414:  MOVF   x9D,W
0416:  MULWF  xA1
0418:  MOVFF  FF4,A4
041C:  MOVF   x9C,W
041E:  MULWF  xA0
0420:  MOVFF  FF4,03
0424:  MOVFF  FF3,A3
0428:  MULWF  xA1
042A:  MOVF   FF3,W
042C:  ADDWF  xA4,F
042E:  MOVF   FF4,W
0430:  ADDWFC xA3,F
0432:  MOVLW  00
0434:  ADDWFC 03,F
0436:  MOVF   x9D,W
0438:  MULWF  xA0
043A:  MOVF   FF3,W
043C:  ADDWF  xA4,F
043E:  MOVF   FF4,W
0440:  ADDWFC xA3,F
0442:  MOVLW  00
0444:  CLRF   02
0446:  ADDWFC 03,F
0448:  ADDWFC 02,F
044A:  MOVF   x9B,W
044C:  MULWF  xA1
044E:  MOVF   FF3,W
0450:  ADDWF  xA3,F
0452:  MOVF   FF4,W
0454:  ADDWFC 03,F
0456:  MOVLW  00
0458:  ADDWFC 02,F
045A:  MOVF   x9B,W
045C:  MULWF  xA0
045E:  MOVF   FF3,W
0460:  ADDWF  03,F
0462:  MOVF   FF4,W
0464:  ADDWFC 02,F
0466:  MOVLW  00
0468:  CLRF   01
046A:  ADDWFC 01,F
046C:  MOVF   x9D,W
046E:  MULWF  x9F
0470:  MOVF   FF3,W
0472:  ADDWF  xA3,F
0474:  MOVF   FF4,W
0476:  ADDWFC 03,F
0478:  MOVLW  00
047A:  ADDWFC 02,F
047C:  ADDWFC 01,F
047E:  MOVF   x9C,W
0480:  MULWF  x9F
0482:  MOVF   FF3,W
0484:  ADDWF  03,F
0486:  MOVF   FF4,W
0488:  ADDWFC 02,F
048A:  MOVLW  00
048C:  ADDWFC 01,F
048E:  MOVF   x9B,W
0490:  MULWF  x9F
0492:  MOVF   FF3,W
0494:  ADDWF  02,F
0496:  MOVF   FF4,W
0498:  ADDWFC 01,F
049A:  INCF   00,F
049C:  BTFSC  01.7
049E:  BRA    04AA
04A0:  RLCF   xA3,F
04A2:  RLCF   03,F
04A4:  RLCF   02,F
04A6:  RLCF   01,F
04A8:  DECF   00,F
04AA:  MOVLW  00
04AC:  BTFSS  xA3.7
04AE:  BRA    04C4
04B0:  INCF   03,F
04B2:  ADDWFC 02,F
04B4:  ADDWFC 01,F
04B6:  MOVF   01,W
04B8:  BNZ   04C4
04BA:  MOVF   02,W
04BC:  BNZ   04C4
04BE:  MOVF   03,W
04C0:  BNZ   04C4
04C2:  INCF   00,F
04C4:  BTFSC  xA2.7
04C6:  BSF    01.7
04C8:  BTFSS  xA2.7
04CA:  BCF    01.7
04CC:  BRA    04D6
04CE:  CLRF   00
04D0:  CLRF   01
04D2:  CLRF   02
04D4:  CLRF   03
04D6:  RETURN 0
04D8:  MOVF   x93,W
04DA:  BTFSC  FD8.2
04DC:  BRA    0628
04DE:  MOVWF  x9F
04E0:  MOVF   x97,W
04E2:  BTFSC  FD8.2
04E4:  BRA    0628
04E6:  SUBWF  x9F,F
04E8:  BNC   04F4
04EA:  MOVLW  7F
04EC:  ADDWF  x9F,F
04EE:  BTFSC  FD8.0
04F0:  BRA    0628
04F2:  BRA    0500
04F4:  MOVLW  81
04F6:  SUBWF  x9F,F
04F8:  BTFSS  FD8.0
04FA:  BRA    0628
04FC:  BTFSC  FD8.2
04FE:  BRA    0628
0500:  MOVFF  9F,00
0504:  CLRF   01
0506:  CLRF   02
0508:  CLRF   03
050A:  CLRF   x9E
050C:  MOVFF  94,9D
0510:  BSF    x9D.7
0512:  MOVFF  95,9C
0516:  MOVFF  96,9B
051A:  MOVLW  19
051C:  MOVWF  x9F
051E:  MOVF   x9A,W
0520:  SUBWF  x9B,F
0522:  BC    053E
0524:  MOVLW  01
0526:  SUBWF  x9C,F
0528:  BC    053E
052A:  SUBWF  x9D,F
052C:  BC    053E
052E:  SUBWF  x9E,F
0530:  BC    053E
0532:  INCF   x9E,F
0534:  INCF   x9D,F
0536:  INCF   x9C,F
0538:  MOVF   x9A,W
053A:  ADDWF  x9B,F
053C:  BRA    058E
053E:  MOVF   x99,W
0540:  SUBWF  x9C,F
0542:  BC    0568
0544:  MOVLW  01
0546:  SUBWF  x9D,F
0548:  BC    0568
054A:  SUBWF  x9E,F
054C:  BC    0568
054E:  INCF   x9E,F
0550:  INCF   x9D,F
0552:  MOVF   x99,W
0554:  ADDWF  x9C,F
0556:  MOVF   x9A,W
0558:  ADDWF  x9B,F
055A:  BNC   058E
055C:  INCF   x9C,F
055E:  BNZ   058E
0560:  INCF   x9D,F
0562:  BNZ   058E
0564:  INCF   x9E,F
0566:  BRA    058E
0568:  MOVF   x98,W
056A:  IORLW  80
056C:  SUBWF  x9D,F
056E:  BC    058C
0570:  MOVLW  01
0572:  SUBWF  x9E,F
0574:  BC    058C
0576:  INCF   x9E,F
0578:  MOVF   x98,W
057A:  IORLW  80
057C:  ADDWF  x9D,F
057E:  MOVF   x99,W
0580:  ADDWF  x9C,F
0582:  BNC   0556
0584:  INCF   x9D,F
0586:  BNZ   0556
0588:  INCF   x9E,F
058A:  BRA    0556
058C:  BSF    03.0
058E:  DECFSZ x9F,F
0590:  BRA    0594
0592:  BRA    05AA
0594:  BCF    FD8.0
0596:  RLCF   x9B,F
0598:  RLCF   x9C,F
059A:  RLCF   x9D,F
059C:  RLCF   x9E,F
059E:  BCF    FD8.0
05A0:  RLCF   03,F
05A2:  RLCF   02,F
05A4:  RLCF   01,F
05A6:  RLCF   xA0,F
05A8:  BRA    051E
05AA:  BTFSS  xA0.0
05AC:  BRA    05BA
05AE:  BCF    FD8.0
05B0:  RRCF   01,F
05B2:  RRCF   02,F
05B4:  RRCF   03,F
05B6:  RRCF   xA0,F
05B8:  BRA    05BE
05BA:  DECF   00,F
05BC:  BZ    0628
05BE:  BTFSC  xA0.7
05C0:  BRA    05FE
05C2:  BCF    FD8.0
05C4:  RLCF   x9B,F
05C6:  RLCF   x9C,F
05C8:  RLCF   x9D,F
05CA:  RLCF   x9E,F
05CC:  MOVF   x9A,W
05CE:  SUBWF  x9B,F
05D0:  BC    05E0
05D2:  MOVLW  01
05D4:  SUBWF  x9C,F
05D6:  BC    05E0
05D8:  SUBWF  x9D,F
05DA:  BC    05E0
05DC:  SUBWF  x9E,F
05DE:  BNC   0614
05E0:  MOVF   x99,W
05E2:  SUBWF  x9C,F
05E4:  BC    05F0
05E6:  MOVLW  01
05E8:  SUBWF  x9D,F
05EA:  BC    05F0
05EC:  SUBWF  x9E,F
05EE:  BNC   0614
05F0:  MOVF   x98,W
05F2:  IORLW  80
05F4:  SUBWF  x9D,F
05F6:  BC    05FE
05F8:  MOVLW  01
05FA:  SUBWF  x9E,F
05FC:  BNC   0614
05FE:  INCF   03,F
0600:  BNZ   0614
0602:  INCF   02,F
0604:  BNZ   0614
0606:  INCF   01,F
0608:  BNZ   0614
060A:  INCF   00,F
060C:  BZ    0628
060E:  RRCF   01,F
0610:  RRCF   02,F
0612:  RRCF   03,F
0614:  MOVFF  94,9F
0618:  MOVF   x98,W
061A:  XORWF  x9F,F
061C:  BTFSS  x9F.7
061E:  BRA    0624
0620:  BSF    01.7
0622:  BRA    0630
0624:  BCF    01.7
0626:  BRA    0630
0628:  CLRF   00
062A:  CLRF   01
062C:  CLRF   02
062E:  CLRF   03
0630:  RETURN 0
0632:  MOVLW  80
0634:  BTFSC  FD8.1
0636:  XORWF  xA3,F
0638:  CLRF   xA8
063A:  CLRF   xA9
063C:  MOVFF  9F,A7
0640:  MOVF   xA3,W
0642:  XORWF  xA7,F
0644:  MOVF   x9E,W
0646:  BTFSC  FD8.2
0648:  BRA    0802
064A:  MOVWF  xA6
064C:  MOVWF  00
064E:  MOVF   xA2,W
0650:  BTFSC  FD8.2
0652:  BRA    0814
0654:  SUBWF  xA6,F
0656:  BTFSC  FD8.2
0658:  BRA    075C
065A:  BNC   06D6
065C:  MOVFF  A3,AC
0660:  BSF    xAC.7
0662:  MOVFF  A4,AB
0666:  MOVFF  A5,AA
066A:  CLRF   xA9
066C:  BCF    FD8.0
066E:  RRCF   xAC,F
0670:  RRCF   xAB,F
0672:  RRCF   xAA,F
0674:  RRCF   xA9,F
0676:  DECFSZ xA6,F
0678:  BRA    066A
067A:  BTFSS  xA7.7
067C:  BRA    0684
067E:  BSF    xA8.0
0680:  BRA    083C
0682:  BCF    xA8.0
0684:  BCF    xA6.0
0686:  BSF    xA8.4
0688:  CLRF   FEA
068A:  MOVLW  A1
068C:  MOVWF  FE9
068E:  BRA    0862
0690:  BCF    xA8.4
0692:  BTFSC  xA7.7
0694:  BRA    06AA
0696:  BTFSS  xA6.0
0698:  BRA    06C0
069A:  RRCF   xAC,F
069C:  RRCF   xAB,F
069E:  RRCF   xAA,F
06A0:  RRCF   xA9,F
06A2:  INCF   00,F
06A4:  BTFSC  FD8.2
06A6:  BRA    0832
06A8:  BRA    06C0
06AA:  BTFSC  xAC.7
06AC:  BRA    06C6
06AE:  BCF    FD8.0
06B0:  RLCF   xA9,F
06B2:  RLCF   xAA,F
06B4:  RLCF   xAB,F
06B6:  RLCF   xAC,F
06B8:  DECF   00,F
06BA:  BTFSC  FD8.2
06BC:  BRA    0832
06BE:  BRA    06AA
06C0:  BSF    xA8.6
06C2:  BRA    079A
06C4:  BCF    xA8.6
06C6:  MOVFF  9F,A7
06CA:  BTFSS  x9F.7
06CC:  BRA    06D2
06CE:  BSF    xAC.7
06D0:  BRA    0824
06D2:  BCF    xAC.7
06D4:  BRA    0824
06D6:  MOVFF  A2,A6
06DA:  MOVFF  A2,00
06DE:  MOVF   x9E,W
06E0:  SUBWF  xA6,F
06E2:  MOVFF  9F,AC
06E6:  BSF    xAC.7
06E8:  MOVFF  A0,AB
06EC:  MOVFF  A1,AA
06F0:  CLRF   xA9
06F2:  BCF    FD8.0
06F4:  RRCF   xAC,F
06F6:  RRCF   xAB,F
06F8:  RRCF   xAA,F
06FA:  RRCF   xA9,F
06FC:  DECFSZ xA6,F
06FE:  BRA    06F0
0700:  BTFSS  xA7.7
0702:  BRA    070A
0704:  BSF    xA8.1
0706:  BRA    083C
0708:  BCF    xA8.1
070A:  BCF    xA6.0
070C:  BSF    xA8.5
070E:  CLRF   FEA
0710:  MOVLW  A5
0712:  MOVWF  FE9
0714:  BRA    0862
0716:  BCF    xA8.5
0718:  BTFSC  xA7.7
071A:  BRA    0730
071C:  BTFSS  xA6.0
071E:  BRA    0746
0720:  RRCF   xAC,F
0722:  RRCF   xAB,F
0724:  RRCF   xAA,F
0726:  RRCF   xA9,F
0728:  INCF   00,F
072A:  BTFSC  FD8.2
072C:  BRA    0832
072E:  BRA    0746
0730:  BTFSC  xAC.7
0732:  BRA    074C
0734:  BCF    FD8.0
0736:  RLCF   xA9,F
0738:  RLCF   xAA,F
073A:  RLCF   xAB,F
073C:  RLCF   xAC,F
073E:  DECF   00,F
0740:  BTFSC  FD8.2
0742:  BRA    0832
0744:  BRA    0730
0746:  BSF    xA8.7
0748:  BRA    079A
074A:  BCF    xA8.7
074C:  MOVFF  A3,A7
0750:  BTFSS  xA3.7
0752:  BRA    0758
0754:  BSF    xAC.7
0756:  BRA    0824
0758:  BCF    xAC.7
075A:  BRA    0824
075C:  MOVFF  A3,AC
0760:  BSF    xAC.7
0762:  MOVFF  A4,AB
0766:  MOVFF  A5,AA
076A:  BTFSS  xA7.7
076C:  BRA    0776
076E:  BCF    xAC.7
0770:  BSF    xA8.2
0772:  BRA    083C
0774:  BCF    xA8.2
0776:  CLRF   xA9
0778:  BCF    xA6.0
077A:  CLRF   FEA
077C:  MOVLW  A1
077E:  MOVWF  FE9
0780:  BRA    0862
0782:  BTFSC  xA7.7
0784:  BRA    07BE
0786:  MOVFF  9F,A7
078A:  BTFSS  xA6.0
078C:  BRA    079A
078E:  RRCF   xAC,F
0790:  RRCF   xAB,F
0792:  RRCF   xAA,F
0794:  RRCF   xA9,F
0796:  INCF   00,F
0798:  BZ    0832
079A:  BTFSS  xA9.7
079C:  BRA    07B4
079E:  INCF   xAA,F
07A0:  BNZ   07B4
07A2:  INCF   xAB,F
07A4:  BNZ   07B4
07A6:  INCF   xAC,F
07A8:  BNZ   07B4
07AA:  RRCF   xAC,F
07AC:  RRCF   xAB,F
07AE:  RRCF   xAA,F
07B0:  INCF   00,F
07B2:  BZ    0832
07B4:  BTFSC  xA8.6
07B6:  BRA    06C4
07B8:  BTFSC  xA8.7
07BA:  BRA    074A
07BC:  BRA    07F6
07BE:  MOVLW  80
07C0:  XORWF  xAC,F
07C2:  BTFSS  xAC.7
07C4:  BRA    07CE
07C6:  BRA    083C
07C8:  MOVFF  A3,A7
07CC:  BRA    07E2
07CE:  MOVFF  9F,A7
07D2:  MOVF   xAC,F
07D4:  BNZ   07E2
07D6:  MOVF   xAB,F
07D8:  BNZ   07E2
07DA:  MOVF   xAA,F
07DC:  BNZ   07E2
07DE:  CLRF   00
07E0:  BRA    0824
07E2:  BTFSC  xAC.7
07E4:  BRA    07F6
07E6:  BCF    FD8.0
07E8:  RLCF   xA9,F
07EA:  RLCF   xAA,F
07EC:  RLCF   xAB,F
07EE:  RLCF   xAC,F
07F0:  DECFSZ 00,F
07F2:  BRA    07E2
07F4:  BRA    0832
07F6:  BTFSS  xA7.7
07F8:  BRA    07FE
07FA:  BSF    xAC.7
07FC:  BRA    0824
07FE:  BCF    xAC.7
0800:  BRA    0824
0802:  MOVFF  A2,00
0806:  MOVFF  A3,AC
080A:  MOVFF  A4,AB
080E:  MOVFF  A5,AA
0812:  BRA    0824
0814:  MOVFF  9E,00
0818:  MOVFF  9F,AC
081C:  MOVFF  A0,AB
0820:  MOVFF  A1,AA
0824:  MOVFF  AC,01
0828:  MOVFF  AB,02
082C:  MOVFF  AA,03
0830:  BRA    089A
0832:  CLRF   00
0834:  CLRF   01
0836:  CLRF   02
0838:  CLRF   03
083A:  BRA    089A
083C:  CLRF   xA9
083E:  COMF   xAA,F
0840:  COMF   xAB,F
0842:  COMF   xAC,F
0844:  COMF   xA9,F
0846:  INCF   xA9,F
0848:  BNZ   0854
084A:  INCF   xAA,F
084C:  BNZ   0854
084E:  INCF   xAB,F
0850:  BNZ   0854
0852:  INCF   xAC,F
0854:  BTFSC  xA8.0
0856:  BRA    0682
0858:  BTFSC  xA8.1
085A:  BRA    0708
085C:  BTFSC  xA8.2
085E:  BRA    0774
0860:  BRA    07C8
0862:  MOVF   FEF,W
0864:  ADDWF  xAA,F
0866:  BNC   0872
0868:  INCF   xAB,F
086A:  BNZ   0872
086C:  INCF   xAC,F
086E:  BTFSC  FD8.2
0870:  BSF    xA6.0
0872:  MOVF   FED,F
0874:  MOVF   FEF,W
0876:  ADDWF  xAB,F
0878:  BNC   0880
087A:  INCF   xAC,F
087C:  BTFSC  FD8.2
087E:  BSF    xA6.0
0880:  MOVF   FED,F
0882:  MOVF   FEF,W
0884:  BTFSC  FEF.7
0886:  BRA    088A
0888:  XORLW  80
088A:  ADDWF  xAC,F
088C:  BTFSC  FD8.0
088E:  BSF    xA6.0
0890:  BTFSC  xA8.4
0892:  BRA    0690
0894:  BTFSC  xA8.5
0896:  BRA    0716
0898:  BRA    0782
089A:  RETURN 0
089C:  MOVFF  9B,A2
08A0:  MOVF   x9F,W
08A2:  XORWF  xA2,F
08A4:  BTFSS  xA2.7
08A6:  BRA    08B2
08A8:  BCF    FD8.2
08AA:  BCF    FD8.0
08AC:  BTFSC  x9B.7
08AE:  BSF    FD8.0
08B0:  BRA    0910
08B2:  MOVFF  9B,A2
08B6:  MOVFF  9E,A3
08BA:  MOVF   x9A,W
08BC:  SUBWF  xA3,F
08BE:  BZ    08CC
08C0:  BTFSS  xA2.7
08C2:  BRA    0910
08C4:  MOVF   FD8,W
08C6:  XORLW  01
08C8:  MOVWF  FD8
08CA:  BRA    0910
08CC:  MOVFF  9F,A3
08D0:  MOVF   x9B,W
08D2:  SUBWF  xA3,F
08D4:  BZ    08E2
08D6:  BTFSS  xA2.7
08D8:  BRA    0910
08DA:  MOVF   FD8,W
08DC:  XORLW  01
08DE:  MOVWF  FD8
08E0:  BRA    0910
08E2:  MOVFF  A0,A3
08E6:  MOVF   x9C,W
08E8:  SUBWF  xA3,F
08EA:  BZ    08F8
08EC:  BTFSS  xA2.7
08EE:  BRA    0910
08F0:  MOVF   FD8,W
08F2:  XORLW  01
08F4:  MOVWF  FD8
08F6:  BRA    0910
08F8:  MOVFF  A1,A3
08FC:  MOVF   x9D,W
08FE:  SUBWF  xA3,F
0900:  BZ    090E
0902:  BTFSS  xA2.7
0904:  BRA    0910
0906:  MOVF   FD8,W
0908:  XORLW  01
090A:  MOVWF  FD8
090C:  BRA    0910
090E:  BCF    FD8.0
0910:  RETURN 0
0912:  MOVLW  8E
0914:  MOVWF  00
0916:  MOVFF  91,01
091A:  MOVFF  90,02
091E:  CLRF   03
0920:  BTFSS  x91.7
0922:  BRA    092E
0924:  COMF   01,F
0926:  COMF   02,F
0928:  INCF   02,F
092A:  BNZ   092E
092C:  INCF   01,F
092E:  MOVF   01,F
0930:  BNZ   0944
0932:  MOVFF  02,01
0936:  CLRF   02
0938:  MOVLW  08
093A:  SUBWF  00,F
093C:  MOVF   01,F
093E:  BNZ   0944
0940:  CLRF   00
0942:  BRA    0958
0944:  BCF    FD8.0
0946:  BTFSC  01.7
0948:  BRA    0952
094A:  RLCF   02,F
094C:  RLCF   01,F
094E:  DECF   00,F
0950:  BRA    0944
0952:  BTFSC  x91.7
0954:  BRA    0958
0956:  BCF    01.7
0958:  RETURN 0
*
0C9A:  MOVLW  8E
0C9C:  MOVWF  00
0C9E:  MOVF   x9A,W
0CA0:  SUBWF  00,F
0CA2:  MOVFF  9B,02
0CA6:  MOVFF  9C,01
0CAA:  BSF    02.7
0CAC:  MOVF   00,F
0CAE:  BZ    0CC2
0CB0:  BCF    FD8.0
0CB2:  MOVF   02,F
0CB4:  BNZ   0CBA
0CB6:  MOVF   01,F
0CB8:  BZ    0CC2
0CBA:  RRCF   02,F
0CBC:  RRCF   01,F
0CBE:  DECFSZ 00,F
0CC0:  BRA    0CB0
0CC2:  BTFSS  x9B.7
0CC4:  BRA    0CD0
0CC6:  COMF   01,F
0CC8:  COMF   02,F
0CCA:  INCF   01,F
0CCC:  BTFSC  FD8.2
0CCE:  INCF   02,F
0CD0:  RETURN 0
*
1BEC:  MOVF   x6F,W
1BEE:  CLRF   01
1BF0:  SUBWF  x6E,W
1BF2:  BC    1BFA
1BF4:  MOVFF  6E,00
1BF8:  BRA    1C12
1BFA:  CLRF   00
1BFC:  MOVLW  08
1BFE:  MOVWF  x70
1C00:  RLCF   x6E,F
1C02:  RLCF   00,F
1C04:  MOVF   x6F,W
1C06:  SUBWF  00,W
1C08:  BTFSC  FD8.0
1C0A:  MOVWF  00
1C0C:  RLCF   01,F
1C0E:  DECFSZ x70,F
1C10:  BRA    1C00
1C12:  RETURN 0
*
1D42:  TBLRD*+
1D44:  MOVFF  FF6,6F
1D48:  MOVFF  FF7,70
1D4C:  MOVFF  FF5,7B
1D50:  CALL   0374
1D54:  MOVFF  6F,FF6
1D58:  MOVFF  70,FF7
1D5C:  DECFSZ x6E,F
1D5E:  BRA    1D42
1D60:  RETURN 0
1D62:  MOVF   x7B,W
1D64:  SUBLW  B6
1D66:  MOVWF  x7B
1D68:  CLRF   03
1D6A:  MOVFF  7C,7F
1D6E:  BSF    x7C.7
1D70:  BCF    FD8.0
1D72:  RRCF   x7C,F
1D74:  RRCF   x7D,F
1D76:  RRCF   x7E,F
1D78:  RRCF   03,F
1D7A:  RRCF   02,F
1D7C:  RRCF   01,F
1D7E:  RRCF   00,F
1D80:  DECFSZ x7B,F
1D82:  BRA    1D70
1D84:  BTFSS  x7F.7
1D86:  BRA    1D9E
1D88:  COMF   00,F
1D8A:  COMF   01,F
1D8C:  COMF   02,F
1D8E:  COMF   03,F
1D90:  INCF   00,F
1D92:  BTFSC  FD8.2
1D94:  INCF   01,F
1D96:  BTFSC  FD8.2
1D98:  INCF   02,F
1D9A:  BTFSC  FD8.2
1D9C:  INCF   03,F
1D9E:  GOTO   1E80 (RETURN)
1DA2:  BTFSC  FD8.1
1DA4:  BRA    1DAC
1DA6:  CLRF   FEA
1DA8:  MOVLW  83
1DAA:  MOVWF  FE9
1DAC:  CLRF   00
1DAE:  CLRF   01
1DB0:  CLRF   02
1DB2:  CLRF   03
1DB4:  CLRF   x83
1DB6:  CLRF   x84
1DB8:  CLRF   x85
1DBA:  CLRF   x86
1DBC:  MOVF   x82,W
1DBE:  IORWF  x81,W
1DC0:  IORWF  x80,W
1DC2:  IORWF  x7F,W
1DC4:  BZ    1E1E
1DC6:  MOVLW  20
1DC8:  MOVWF  x87
1DCA:  BCF    FD8.0
1DCC:  RLCF   x7B,F
1DCE:  RLCF   x7C,F
1DD0:  RLCF   x7D,F
1DD2:  RLCF   x7E,F
1DD4:  RLCF   x83,F
1DD6:  RLCF   x84,F
1DD8:  RLCF   x85,F
1DDA:  RLCF   x86,F
1DDC:  MOVF   x82,W
1DDE:  SUBWF  x86,W
1DE0:  BNZ   1DF2
1DE2:  MOVF   x81,W
1DE4:  SUBWF  x85,W
1DE6:  BNZ   1DF2
1DE8:  MOVF   x80,W
1DEA:  SUBWF  x84,W
1DEC:  BNZ   1DF2
1DEE:  MOVF   x7F,W
1DF0:  SUBWF  x83,W
1DF2:  BNC   1E12
1DF4:  MOVF   x7F,W
1DF6:  SUBWF  x83,F
1DF8:  MOVF   x80,W
1DFA:  BTFSS  FD8.0
1DFC:  INCFSZ x80,W
1DFE:  SUBWF  x84,F
1E00:  MOVF   x81,W
1E02:  BTFSS  FD8.0
1E04:  INCFSZ x81,W
1E06:  SUBWF  x85,F
1E08:  MOVF   x82,W
1E0A:  BTFSS  FD8.0
1E0C:  INCFSZ x82,W
1E0E:  SUBWF  x86,F
1E10:  BSF    FD8.0
1E12:  RLCF   00,F
1E14:  RLCF   01,F
1E16:  RLCF   02,F
1E18:  RLCF   03,F
1E1A:  DECFSZ x87,F
1E1C:  BRA    1DCA
1E1E:  MOVFF  83,FEF
1E22:  MOVFF  84,FEC
1E26:  MOVFF  85,FEC
1E2A:  MOVFF  86,FEC
1E2E:  RETURN 0
1E30:  MOVF   FE9,W
1E32:  MOVWF  x73
1E34:  MOVF   x72,W
1E36:  MOVWF  x75
1E38:  BZ    1E6E
1E3A:  MOVFF  71,9D
1E3E:  MOVFF  70,9C
1E42:  MOVFF  6F,9B
1E46:  MOVFF  6E,9A
1E4A:  CLRF   xA1
1E4C:  CLRF   xA0
1E4E:  MOVLW  20
1E50:  MOVWF  x9F
1E52:  MOVLW  82
1E54:  MOVWF  x9E
1E56:  CALL   03E6
1E5A:  MOVFF  03,71
1E5E:  MOVFF  02,70
1E62:  MOVFF  01,6F
1E66:  MOVFF  00,6E
1E6A:  DECFSZ x75,F
1E6C:  BRA    1E3A
1E6E:  MOVFF  71,7E
1E72:  MOVFF  70,7D
1E76:  MOVFF  6F,7C
1E7A:  MOVFF  6E,7B
1E7E:  BRA    1D62
1E80:  MOVFF  03,71
1E84:  MOVFF  02,70
1E88:  MOVFF  01,6F
1E8C:  MOVFF  00,6E
1E90:  BTFSS  x71.7
1E92:  BRA    1EAE
1E94:  DECF   x73,F
1E96:  BSF    x73.5
1E98:  COMF   x6E,F
1E9A:  COMF   x6F,F
1E9C:  COMF   x70,F
1E9E:  COMF   x71,F
1EA0:  INCF   x6E,F
1EA2:  BTFSC  FD8.2
1EA4:  INCF   x6F,F
1EA6:  BTFSC  FD8.2
1EA8:  INCF   x70,F
1EAA:  BTFSC  FD8.2
1EAC:  INCF   x71,F
1EAE:  MOVLW  3B
1EB0:  MOVWF  x7A
1EB2:  MOVLW  9A
1EB4:  MOVWF  x79
1EB6:  MOVLW  CA
1EB8:  MOVWF  x78
1EBA:  CLRF   x77
1EBC:  MOVLW  0A
1EBE:  MOVWF  x75
1EC0:  MOVF   x72,W
1EC2:  BTFSC  FD8.2
1EC4:  INCF   x73,F
1EC6:  BSF    FD8.1
1EC8:  CLRF   FEA
1ECA:  MOVLW  6E
1ECC:  MOVWF  FE9
1ECE:  MOVFF  71,7E
1ED2:  MOVFF  70,7D
1ED6:  MOVFF  6F,7C
1EDA:  MOVFF  6E,7B
1EDE:  MOVFF  7A,82
1EE2:  MOVFF  79,81
1EE6:  MOVFF  78,80
1EEA:  MOVFF  77,7F
1EEE:  RCALL  1DA2
1EF0:  MOVF   01,W
1EF2:  MOVF   00,F
1EF4:  BNZ   1F14
1EF6:  INCF   x72,W
1EF8:  SUBWF  x75,W
1EFA:  BZ    1F14
1EFC:  MOVF   x73,W
1EFE:  BZ    1F18
1F00:  ANDLW  0F
1F02:  SUBWF  x75,W
1F04:  BZ    1F08
1F06:  BC    1F7E
1F08:  BTFSC  x73.7
1F0A:  BRA    1F7E
1F0C:  BTFSC  x73.6
1F0E:  BRA    1F18
1F10:  MOVLW  20
1F12:  BRA    1F74
1F14:  MOVLW  20
1F16:  ANDWF  x73,F
1F18:  BTFSS  x73.5
1F1A:  BRA    1F36
1F1C:  BCF    x73.5
1F1E:  MOVF   x72,W
1F20:  BTFSS  FD8.2
1F22:  DECF   x73,F
1F24:  MOVF   00,W
1F26:  MOVWF  x73
1F28:  MOVLW  2D
1F2A:  MOVWF  x7B
1F2C:  CALL   0374
1F30:  MOVF   x73,W
1F32:  MOVWF  00
1F34:  CLRF   x73
1F36:  MOVF   x72,W
1F38:  SUBWF  x75,W
1F3A:  BNZ   1F52
1F3C:  MOVF   00,W
1F3E:  MOVWF  x73
1F40:  MOVLW  2E
1F42:  MOVWF  x7B
1F44:  CALL   0374
1F48:  MOVF   x73,W
1F4A:  MOVWF  00
1F4C:  MOVLW  20
1F4E:  ANDWF  x73,F
1F50:  MOVLW  00
1F52:  MOVLW  30
1F54:  BTFSS  x73.5
1F56:  BRA    1F74
1F58:  BCF    x73.5
1F5A:  MOVF   x72,W
1F5C:  BTFSS  FD8.2
1F5E:  DECF   x73,F
1F60:  MOVF   00,W
1F62:  MOVWF  x73
1F64:  MOVLW  2D
1F66:  MOVWF  x7B
1F68:  CALL   0374
1F6C:  MOVF   x73,W
1F6E:  MOVWF  00
1F70:  CLRF   x73
1F72:  MOVLW  30
1F74:  ADDWF  00,F
1F76:  MOVFF  00,7B
1F7A:  CALL   0374
1F7E:  BCF    FD8.1
1F80:  MOVFF  7A,7E
1F84:  MOVFF  79,7D
1F88:  MOVFF  78,7C
1F8C:  MOVFF  77,7B
1F90:  CLRF   x82
1F92:  CLRF   x81
1F94:  CLRF   x80
1F96:  MOVLW  0A
1F98:  MOVWF  x7F
1F9A:  RCALL  1DA2
1F9C:  MOVFF  03,7A
1FA0:  MOVFF  02,79
1FA4:  MOVFF  01,78
1FA8:  MOVFF  00,77
1FAC:  DECFSZ x75,F
1FAE:  BRA    1EC6
1FB0:  RETURN 0
....................  
.................... #list 
....................  
.................... #DEVICE ADC =10  // seleciona o conversor a/d com 10 bits 
.................... #INCLUDE <stdlib.h>   
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <math.h> //  Inclui a biblioteca responsavel por fornecer funções de calculos matematicos  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
0CD2:  BCF    x99.0
....................    y = x; 
0CD4:  MOVFF  8D,92
0CD8:  MOVFF  8C,91
0CDC:  MOVFF  8B,90
0CE0:  MOVFF  8A,8F
....................  
....................    if (x < 0) 
0CE4:  MOVFF  8D,9D
0CE8:  MOVFF  8C,9C
0CEC:  MOVFF  8B,9B
0CF0:  MOVFF  8A,9A
0CF4:  CLRF   xA1
0CF6:  CLRF   xA0
0CF8:  CLRF   x9F
0CFA:  CLRF   x9E
0CFC:  RCALL  089C
0CFE:  BNC   0D08
....................    { 
....................       s = 1; 
0D00:  BSF    x99.0
....................       y = -y; 
0D02:  MOVF   x90,W
0D04:  XORLW  80
0D06:  MOVWF  x90
....................    } 
....................  
....................    if (y <= 32768.0) 
0D08:  MOVFF  92,9D
0D0C:  MOVFF  91,9C
0D10:  MOVFF  90,9B
0D14:  MOVFF  8F,9A
0D18:  CLRF   xA1
0D1A:  CLRF   xA0
0D1C:  CLRF   x9F
0D1E:  MOVLW  8E
0D20:  MOVWF  x9E
0D22:  RCALL  089C
0D24:  BC    0D28
0D26:  BNZ   0D58
....................       res = (float32)(unsigned int16)y; 
0D28:  MOVFF  92,9D
0D2C:  MOVFF  91,9C
0D30:  MOVFF  90,9B
0D34:  MOVFF  8F,9A
0D38:  RCALL  0C9A
0D3A:  MOVFF  02,9F
0D3E:  MOVFF  01,9E
0D42:  CALL   03B0
0D46:  MOVFF  03,96
0D4A:  MOVFF  02,95
0D4E:  MOVFF  01,94
0D52:  MOVFF  00,93
0D56:  BRA    0EE2
....................  
....................  else if (y < 10000000.0) 
0D58:  MOVFF  92,9D
0D5C:  MOVFF  91,9C
0D60:  MOVFF  90,9B
0D64:  MOVFF  8F,9A
0D68:  MOVLW  80
0D6A:  MOVWF  xA1
0D6C:  MOVLW  96
0D6E:  MOVWF  xA0
0D70:  MOVLW  18
0D72:  MOVWF  x9F
0D74:  MOVLW  96
0D76:  MOVWF  x9E
0D78:  RCALL  089C
0D7A:  BTFSS  FD8.0
0D7C:  BRA    0ED2
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
0D7E:  MOVFF  92,9D
0D82:  MOVFF  91,9C
0D86:  MOVFF  90,9B
0D8A:  MOVFF  8F,9A
0D8E:  CLRF   xA1
0D90:  CLRF   xA0
0D92:  CLRF   x9F
0D94:  MOVLW  70
0D96:  MOVWF  x9E
0D98:  CALL   03E6
0D9C:  MOVFF  03,9D
0DA0:  MOVFF  02,9C
0DA4:  MOVFF  01,9B
0DA8:  MOVFF  00,9A
0DAC:  RCALL  0C9A
0DAE:  MOVFF  02,98
0DB2:  MOVFF  01,97
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
0DB6:  MOVFF  92,9D
0DBA:  MOVFF  91,9C
0DBE:  MOVFF  90,9B
0DC2:  MOVFF  8F,9A
0DC6:  CLRF   xA1
0DC8:  CLRF   xA0
0DCA:  CLRF   x9F
0DCC:  MOVLW  70
0DCE:  MOVWF  x9E
0DD0:  CALL   03E6
0DD4:  MOVFF  03,9D
0DD8:  MOVFF  02,9C
0DDC:  MOVFF  01,9B
0DE0:  MOVFF  00,9A
0DE4:  MOVFF  98,9F
0DE8:  MOVFF  97,9E
0DEC:  CALL   03B0
0DF0:  BSF    FD8.1
0DF2:  MOVFF  9D,A1
0DF6:  MOVFF  9C,A0
0DFA:  MOVFF  9B,9F
0DFE:  MOVFF  9A,9E
0E02:  MOVFF  03,A5
0E06:  MOVFF  02,A4
0E0A:  MOVFF  01,A3
0E0E:  MOVFF  00,A2
0E12:  RCALL  0632
0E14:  CLRF   x9D
0E16:  CLRF   x9C
0E18:  CLRF   x9B
0E1A:  MOVLW  8E
0E1C:  MOVWF  x9A
0E1E:  MOVFF  03,A1
0E22:  MOVFF  02,A0
0E26:  MOVFF  01,9F
0E2A:  MOVFF  00,9E
0E2E:  CALL   03E6
0E32:  MOVFF  03,92
0E36:  MOVFF  02,91
0E3A:  MOVFF  01,90
0E3E:  MOVFF  00,8F
....................       res = 32768.0*(float32)l; 
0E42:  MOVFF  98,9F
0E46:  MOVFF  97,9E
0E4A:  CALL   03B0
0E4E:  CLRF   x9D
0E50:  CLRF   x9C
0E52:  CLRF   x9B
0E54:  MOVLW  8E
0E56:  MOVWF  x9A
0E58:  MOVFF  03,A1
0E5C:  MOVFF  02,A0
0E60:  MOVFF  01,9F
0E64:  MOVFF  00,9E
0E68:  CALL   03E6
0E6C:  MOVFF  03,96
0E70:  MOVFF  02,95
0E74:  MOVFF  01,94
0E78:  MOVFF  00,93
....................       res += (float32)(unsigned int16)y; 
0E7C:  MOVFF  92,9D
0E80:  MOVFF  91,9C
0E84:  MOVFF  90,9B
0E88:  MOVFF  8F,9A
0E8C:  RCALL  0C9A
0E8E:  MOVFF  02,9F
0E92:  MOVFF  01,9E
0E96:  CALL   03B0
0E9A:  BCF    FD8.1
0E9C:  MOVFF  96,A1
0EA0:  MOVFF  95,A0
0EA4:  MOVFF  94,9F
0EA8:  MOVFF  93,9E
0EAC:  MOVFF  03,A5
0EB0:  MOVFF  02,A4
0EB4:  MOVFF  01,A3
0EB8:  MOVFF  00,A2
0EBC:  CALL   0632
0EC0:  MOVFF  03,96
0EC4:  MOVFF  02,95
0EC8:  MOVFF  01,94
0ECC:  MOVFF  00,93
....................    } 
0ED0:  BRA    0EE2
....................  
....................  else 
....................   res = y; 
0ED2:  MOVFF  92,96
0ED6:  MOVFF  91,95
0EDA:  MOVFF  90,94
0EDE:  MOVFF  8F,93
....................  
....................  y = y - (float32)(unsigned int16)y; 
0EE2:  MOVFF  92,9D
0EE6:  MOVFF  91,9C
0EEA:  MOVFF  90,9B
0EEE:  MOVFF  8F,9A
0EF2:  RCALL  0C9A
0EF4:  MOVFF  02,9F
0EF8:  MOVFF  01,9E
0EFC:  CALL   03B0
0F00:  BSF    FD8.1
0F02:  MOVFF  92,A1
0F06:  MOVFF  91,A0
0F0A:  MOVFF  90,9F
0F0E:  MOVFF  8F,9E
0F12:  MOVFF  03,A5
0F16:  MOVFF  02,A4
0F1A:  MOVFF  01,A3
0F1E:  MOVFF  00,A2
0F22:  CALL   0632
0F26:  MOVFF  03,92
0F2A:  MOVFF  02,91
0F2E:  MOVFF  01,90
0F32:  MOVFF  00,8F
....................  
....................  if (s) 
0F36:  BTFSS  x99.0
0F38:  BRA    0F40
....................   res = -res; 
0F3A:  MOVF   x94,W
0F3C:  XORLW  80
0F3E:  MOVWF  x94
....................  
....................  if (y != 0) 
0F40:  MOVFF  92,9D
0F44:  MOVFF  91,9C
0F48:  MOVFF  90,9B
0F4C:  MOVFF  8F,9A
0F50:  CLRF   xA1
0F52:  CLRF   xA0
0F54:  CLRF   x9F
0F56:  CLRF   x9E
0F58:  RCALL  089C
0F5A:  BZ    0FCC
....................  { 
....................   if (s == 1 && n == 0) 
0F5C:  BTFSS  x99.0
0F5E:  BRA    0F94
0F60:  MOVF   x8E,F
0F62:  BNZ   0F94
....................    res -= 1.0; 
0F64:  BSF    FD8.1
0F66:  MOVFF  96,A1
0F6A:  MOVFF  95,A0
0F6E:  MOVFF  94,9F
0F72:  MOVFF  93,9E
0F76:  CLRF   xA5
0F78:  CLRF   xA4
0F7A:  CLRF   xA3
0F7C:  MOVLW  7F
0F7E:  MOVWF  xA2
0F80:  CALL   0632
0F84:  MOVFF  03,96
0F88:  MOVFF  02,95
0F8C:  MOVFF  01,94
0F90:  MOVFF  00,93
....................  
....................   if (s == 0 && n == 1) 
0F94:  BTFSC  x99.0
0F96:  BRA    0FCC
0F98:  DECFSZ x8E,W
0F9A:  BRA    0FCC
....................    res += 1.0; 
0F9C:  BCF    FD8.1
0F9E:  MOVFF  96,A1
0FA2:  MOVFF  95,A0
0FA6:  MOVFF  94,9F
0FAA:  MOVFF  93,9E
0FAE:  CLRF   xA5
0FB0:  CLRF   xA4
0FB2:  CLRF   xA3
0FB4:  MOVLW  7F
0FB6:  MOVWF  xA2
0FB8:  CALL   0632
0FBC:  MOVFF  03,96
0FC0:  MOVFF  02,95
0FC4:  MOVFF  01,94
0FC8:  MOVFF  00,93
....................  } 
....................  if (x == 0) 
0FCC:  MOVFF  8D,9D
0FD0:  MOVFF  8C,9C
0FD4:  MOVFF  8B,9B
0FD8:  MOVFF  8A,9A
0FDC:  CLRF   xA1
0FDE:  CLRF   xA0
0FE0:  CLRF   x9F
0FE2:  CLRF   x9E
0FE4:  RCALL  089C
0FE6:  BNZ   0FF0
....................     res = 0; 
0FE8:  CLRF   x96
0FEA:  CLRF   x95
0FEC:  CLRF   x94
0FEE:  CLRF   x93
....................  
....................  return (res); 
0FF0:  MOVFF  93,00
0FF4:  MOVFF  94,01
0FF8:  MOVFF  95,02
0FFC:  MOVFF  96,03
1000:  RETURN 0
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
*
101C:  MOVFF  89,8D
1020:  MOVFF  88,8C
1024:  MOVFF  87,8B
1028:  MOVFF  86,8A
102C:  CLRF   x8E
102E:  RCALL  0CD2
1030:  GOTO   1132 (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
1002:  MOVFF  89,8D
1006:  MOVFF  88,8C
100A:  MOVFF  87,8B
100E:  MOVFF  86,8A
1012:  MOVLW  01
1014:  MOVWF  x8E
1016:  RCALL  0CD2
1018:  GOTO   10EA (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
*
1034:  MOVFF  7D,9D
1038:  MOVFF  7C,9C
103C:  MOVFF  7B,9B
1040:  MOVFF  7A,9A
1044:  CLRF   xA1
1046:  CLRF   xA0
1048:  CLRF   x9F
104A:  CLRF   x9E
104C:  RCALL  089C
104E:  BTFSC  FD8.2
1050:  BRA    118E
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
1052:  MOVFF  79,96
1056:  MOVFF  78,95
105A:  MOVFF  77,94
105E:  MOVFF  76,93
1062:  MOVFF  7D,9A
1066:  MOVFF  7C,99
106A:  MOVFF  7B,98
106E:  MOVFF  7A,97
1072:  CALL   04D8
1076:  MOVFF  03,85
107A:  MOVFF  02,84
107E:  MOVFF  01,83
1082:  MOVFF  00,82
1086:  MOVFF  03,9D
108A:  MOVFF  02,9C
108E:  MOVFF  01,9B
1092:  MOVFF  00,9A
1096:  CLRF   xA1
1098:  CLRF   xA0
109A:  CLRF   x9F
109C:  CLRF   x9E
109E:  CALL   089C
10A2:  BNC   10EC
10A4:  MOVFF  79,96
10A8:  MOVFF  78,95
10AC:  MOVFF  77,94
10B0:  MOVFF  76,93
10B4:  MOVFF  7D,9A
10B8:  MOVFF  7C,99
10BC:  MOVFF  7B,98
10C0:  MOVFF  7A,97
10C4:  CALL   04D8
10C8:  MOVFF  03,85
10CC:  MOVFF  02,84
10D0:  MOVFF  01,83
10D4:  MOVFF  00,82
10D8:  MOVFF  03,89
10DC:  MOVFF  02,88
10E0:  MOVFF  01,87
10E4:  MOVFF  00,86
10E8:  BRA    1002
10EA:  BRA    1132
10EC:  MOVFF  79,96
10F0:  MOVFF  78,95
10F4:  MOVFF  77,94
10F8:  MOVFF  76,93
10FC:  MOVFF  7D,9A
1100:  MOVFF  7C,99
1104:  MOVFF  7B,98
1108:  MOVFF  7A,97
110C:  CALL   04D8
1110:  MOVFF  03,85
1114:  MOVFF  02,84
1118:  MOVFF  01,83
111C:  MOVFF  00,82
1120:  MOVFF  03,89
1124:  MOVFF  02,88
1128:  MOVFF  01,87
112C:  MOVFF  00,86
1130:  BRA    101C
1132:  MOVFF  03,81
1136:  MOVFF  02,80
113A:  MOVFF  01,7F
113E:  MOVFF  00,7E
....................       return(x-(i*y)); 
1142:  MOVFF  81,9D
1146:  MOVFF  80,9C
114A:  MOVFF  7F,9B
114E:  MOVFF  7E,9A
1152:  MOVFF  7D,A1
1156:  MOVFF  7C,A0
115A:  MOVFF  7B,9F
115E:  MOVFF  7A,9E
1162:  CALL   03E6
1166:  BSF    FD8.1
1168:  MOVFF  79,A1
116C:  MOVFF  78,A0
1170:  MOVFF  77,9F
1174:  MOVFF  76,9E
1178:  MOVFF  03,A5
117C:  MOVFF  02,A4
1180:  MOVFF  01,A3
1184:  MOVFF  00,A2
1188:  CALL   0632
118C:  BRA    118E
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
118E:  RETURN 0
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
1190:  MOVFF  7D,9D
1194:  MOVFF  7C,9C
1198:  MOVFF  7B,9B
119C:  MOVFF  7A,9A
11A0:  MOVLW  3B
11A2:  MOVWF  xA1
11A4:  MOVLW  AA
11A6:  MOVWF  xA0
11A8:  MOVLW  38
11AA:  MOVWF  x9F
11AC:  MOVLW  7F
11AE:  MOVWF  x9E
11B0:  CALL   03E6
11B4:  MOVFF  03,9D
11B8:  MOVFF  02,9C
11BC:  MOVFF  01,9B
11C0:  MOVFF  00,9A
11C4:  RCALL  0C9A
11C6:  MOVFF  01,8A
....................    s = 0; 
11CA:  BCF    x8B.0
....................    y = x; 
11CC:  MOVFF  7D,81
11D0:  MOVFF  7C,80
11D4:  MOVFF  7B,7F
11D8:  MOVFF  7A,7E
....................  
....................    if (x < 0) 
11DC:  MOVFF  7D,9D
11E0:  MOVFF  7C,9C
11E4:  MOVFF  7B,9B
11E8:  MOVFF  7A,9A
11EC:  CLRF   xA1
11EE:  CLRF   xA0
11F0:  CLRF   x9F
11F2:  CLRF   x9E
11F4:  CALL   089C
11F8:  BNC   1204
....................    { 
....................       s = 1; 
11FA:  BSF    x8B.0
....................       n = -n; 
11FC:  NEGF   x8A
....................       y = -y; 
11FE:  MOVF   x7F,W
1200:  XORLW  80
1202:  MOVWF  x7F
....................    } 
....................  
....................    res = 0.0; 
1204:  CLRF   x85
1206:  CLRF   x84
1208:  CLRF   x83
120A:  CLRF   x82
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
120C:  CLRF   x8D
120E:  MOVLW  82
1210:  MOVWF  FE9
1212:  MOVFF  8D,FEA
1216:  MOVLW  7F
1218:  ADDWF  x8A,W
121A:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
121C:  MOVFF  81,9D
1220:  MOVFF  80,9C
1224:  MOVFF  7F,9B
1228:  MOVFF  7E,9A
122C:  MOVLW  3B
122E:  MOVWF  xA1
1230:  MOVLW  AA
1232:  MOVWF  xA0
1234:  MOVLW  38
1236:  MOVWF  x9F
1238:  MOVLW  7F
123A:  MOVWF  x9E
123C:  CALL   03E6
1240:  MOVFF  03,8F
1244:  MOVFF  02,8E
1248:  MOVFF  01,8D
124C:  MOVFF  00,8C
1250:  CLRF   x91
1252:  MOVFF  8A,90
1256:  BTFSC  x90.7
1258:  DECF   x91,F
125A:  CALL   0912
125E:  BSF    FD8.1
1260:  MOVFF  8F,A1
1264:  MOVFF  8E,A0
1268:  MOVFF  8D,9F
126C:  MOVFF  8C,9E
1270:  MOVFF  03,A5
1274:  MOVFF  02,A4
1278:  MOVFF  01,A3
127C:  MOVFF  00,A2
1280:  CALL   0632
1284:  MOVFF  03,81
1288:  MOVFF  02,80
128C:  MOVFF  01,7F
1290:  MOVFF  00,7E
....................  
....................    r = pe[0]*y + pe[1]; 
1294:  MOVLW  7C
1296:  MOVWF  x9D
1298:  MOVLW  88
129A:  MOVWF  x9C
129C:  MOVLW  59
129E:  MOVWF  x9B
12A0:  MOVLW  72
12A2:  MOVWF  x9A
12A4:  MOVFF  81,A1
12A8:  MOVFF  80,A0
12AC:  MOVFF  7F,9F
12B0:  MOVFF  7E,9E
12B4:  CALL   03E6
12B8:  MOVFF  03,8F
12BC:  MOVFF  02,8E
12C0:  MOVFF  01,8D
12C4:  MOVFF  00,8C
12C8:  BCF    FD8.1
12CA:  MOVFF  03,A1
12CE:  MOVFF  02,A0
12D2:  MOVFF  01,9F
12D6:  MOVFF  00,9E
12DA:  MOVLW  E0
12DC:  MOVWF  xA5
12DE:  MOVLW  97
12E0:  MOVWF  xA4
12E2:  MOVLW  26
12E4:  MOVWF  xA3
12E6:  MOVLW  75
12E8:  MOVWF  xA2
12EA:  CALL   0632
12EE:  MOVFF  03,89
12F2:  MOVFF  02,88
12F6:  MOVFF  01,87
12FA:  MOVFF  00,86
....................    r = r*y + pe[2]; 
12FE:  MOVFF  89,9D
1302:  MOVFF  88,9C
1306:  MOVFF  87,9B
130A:  MOVFF  86,9A
130E:  MOVFF  81,A1
1312:  MOVFF  80,A0
1316:  MOVFF  7F,9F
131A:  MOVFF  7E,9E
131E:  CALL   03E6
1322:  MOVFF  03,8F
1326:  MOVFF  02,8E
132A:  MOVFF  01,8D
132E:  MOVFF  00,8C
1332:  BCF    FD8.1
1334:  MOVFF  03,A1
1338:  MOVFF  02,A0
133C:  MOVFF  01,9F
1340:  MOVFF  00,9E
1344:  MOVLW  C4
1346:  MOVWF  xA5
1348:  MOVLW  1D
134A:  MOVWF  xA4
134C:  MOVLW  1E
134E:  MOVWF  xA3
1350:  MOVLW  78
1352:  MOVWF  xA2
1354:  CALL   0632
1358:  MOVFF  03,89
135C:  MOVFF  02,88
1360:  MOVFF  01,87
1364:  MOVFF  00,86
....................    r = r*y + pe[3]; 
1368:  MOVFF  89,9D
136C:  MOVFF  88,9C
1370:  MOVFF  87,9B
1374:  MOVFF  86,9A
1378:  MOVFF  81,A1
137C:  MOVFF  80,A0
1380:  MOVFF  7F,9F
1384:  MOVFF  7E,9E
1388:  CALL   03E6
138C:  MOVFF  03,8F
1390:  MOVFF  02,8E
1394:  MOVFF  01,8D
1398:  MOVFF  00,8C
139C:  BCF    FD8.1
139E:  MOVFF  03,A1
13A2:  MOVFF  02,A0
13A6:  MOVFF  01,9F
13AA:  MOVFF  00,9E
13AE:  MOVLW  5E
13B0:  MOVWF  xA5
13B2:  MOVLW  50
13B4:  MOVWF  xA4
13B6:  MOVLW  63
13B8:  MOVWF  xA3
13BA:  MOVLW  7A
13BC:  MOVWF  xA2
13BE:  CALL   0632
13C2:  MOVFF  03,89
13C6:  MOVFF  02,88
13CA:  MOVFF  01,87
13CE:  MOVFF  00,86
....................    r = r*y + pe[4]; 
13D2:  MOVFF  89,9D
13D6:  MOVFF  88,9C
13DA:  MOVFF  87,9B
13DE:  MOVFF  86,9A
13E2:  MOVFF  81,A1
13E6:  MOVFF  80,A0
13EA:  MOVFF  7F,9F
13EE:  MOVFF  7E,9E
13F2:  CALL   03E6
13F6:  MOVFF  03,8F
13FA:  MOVFF  02,8E
13FE:  MOVFF  01,8D
1402:  MOVFF  00,8C
1406:  BCF    FD8.1
1408:  MOVFF  03,A1
140C:  MOVFF  02,A0
1410:  MOVFF  01,9F
1414:  MOVFF  00,9E
1418:  MOVLW  1A
141A:  MOVWF  xA5
141C:  MOVLW  FE
141E:  MOVWF  xA4
1420:  MOVLW  75
1422:  MOVWF  xA3
1424:  MOVLW  7C
1426:  MOVWF  xA2
1428:  CALL   0632
142C:  MOVFF  03,89
1430:  MOVFF  02,88
1434:  MOVFF  01,87
1438:  MOVFF  00,86
....................    r = r*y + pe[5]; 
143C:  MOVFF  89,9D
1440:  MOVFF  88,9C
1444:  MOVFF  87,9B
1448:  MOVFF  86,9A
144C:  MOVFF  81,A1
1450:  MOVFF  80,A0
1454:  MOVFF  7F,9F
1458:  MOVFF  7E,9E
145C:  CALL   03E6
1460:  MOVFF  03,8F
1464:  MOVFF  02,8E
1468:  MOVFF  01,8D
146C:  MOVFF  00,8C
1470:  BCF    FD8.1
1472:  MOVFF  03,A1
1476:  MOVFF  02,A0
147A:  MOVFF  01,9F
147E:  MOVFF  00,9E
1482:  MOVLW  18
1484:  MOVWF  xA5
1486:  MOVLW  72
1488:  MOVWF  xA4
148A:  MOVLW  31
148C:  MOVWF  xA3
148E:  MOVLW  7E
1490:  MOVWF  xA2
1492:  CALL   0632
1496:  MOVFF  03,89
149A:  MOVFF  02,88
149E:  MOVFF  01,87
14A2:  MOVFF  00,86
....................  
....................    res = res*(1.0 + y*r); 
14A6:  MOVFF  81,9D
14AA:  MOVFF  80,9C
14AE:  MOVFF  7F,9B
14B2:  MOVFF  7E,9A
14B6:  MOVFF  89,A1
14BA:  MOVFF  88,A0
14BE:  MOVFF  87,9F
14C2:  MOVFF  86,9E
14C6:  CALL   03E6
14CA:  BCF    FD8.1
14CC:  CLRF   xA1
14CE:  CLRF   xA0
14D0:  CLRF   x9F
14D2:  MOVLW  7F
14D4:  MOVWF  x9E
14D6:  MOVFF  03,A5
14DA:  MOVFF  02,A4
14DE:  MOVFF  01,A3
14E2:  MOVFF  00,A2
14E6:  CALL   0632
14EA:  MOVFF  85,9D
14EE:  MOVFF  84,9C
14F2:  MOVFF  83,9B
14F6:  MOVFF  82,9A
14FA:  MOVFF  03,A1
14FE:  MOVFF  02,A0
1502:  MOVFF  01,9F
1506:  MOVFF  00,9E
150A:  CALL   03E6
150E:  MOVFF  03,85
1512:  MOVFF  02,84
1516:  MOVFF  01,83
151A:  MOVFF  00,82
....................  
....................    if (s) 
151E:  BTFSS  x8B.0
1520:  BRA    1550
....................       res = 1.0/res; 
1522:  CLRF   x96
1524:  CLRF   x95
1526:  CLRF   x94
1528:  MOVLW  7F
152A:  MOVWF  x93
152C:  MOVFF  85,9A
1530:  MOVFF  84,99
1534:  MOVFF  83,98
1538:  MOVFF  82,97
153C:  CALL   04D8
1540:  MOVFF  03,85
1544:  MOVFF  02,84
1548:  MOVFF  01,83
154C:  MOVFF  00,82
....................    return(res); 
1550:  MOVFF  82,00
1554:  MOVFF  83,01
1558:  MOVFF  84,02
155C:  MOVFF  85,03
1560:  RETURN 0
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
*
095A:  MOVFF  7D,81
095E:  MOVFF  7C,80
0962:  MOVFF  7B,7F
0966:  MOVFF  7A,7E
....................  
....................    if (y != 1.0) 
096A:  MOVFF  81,9D
096E:  MOVFF  80,9C
0972:  MOVFF  7F,9B
0976:  MOVFF  7E,9A
097A:  CLRF   xA1
097C:  CLRF   xA0
097E:  CLRF   x9F
0980:  MOVLW  7F
0982:  MOVWF  x9E
0984:  RCALL  089C
0986:  BTFSC  FD8.2
0988:  BRA    0C80
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
098A:  CLRF   x90
098C:  MOVLW  7E
098E:  MOVWF  FE9
0990:  MOVFF  90,FEA
0994:  MOVLW  7E
0996:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
0998:  BSF    FD8.1
099A:  MOVFF  81,A1
099E:  MOVFF  80,A0
09A2:  MOVFF  7F,9F
09A6:  MOVFF  7E,9E
09AA:  CLRF   xA5
09AC:  CLRF   xA4
09AE:  CLRF   xA3
09B0:  MOVLW  7F
09B2:  MOVWF  xA2
09B4:  RCALL  0632
09B6:  MOVFF  03,92
09BA:  MOVFF  02,91
09BE:  MOVFF  01,90
09C2:  MOVFF  00,8F
09C6:  BCF    FD8.1
09C8:  MOVFF  81,A1
09CC:  MOVFF  80,A0
09D0:  MOVFF  7F,9F
09D4:  MOVFF  7E,9E
09D8:  CLRF   xA5
09DA:  CLRF   xA4
09DC:  CLRF   xA3
09DE:  MOVLW  7F
09E0:  MOVWF  xA2
09E2:  RCALL  0632
09E4:  MOVFF  92,96
09E8:  MOVFF  91,95
09EC:  MOVFF  90,94
09F0:  MOVFF  8F,93
09F4:  MOVFF  03,9A
09F8:  MOVFF  02,99
09FC:  MOVFF  01,98
0A00:  MOVFF  00,97
0A04:  RCALL  04D8
0A06:  MOVFF  03,81
0A0A:  MOVFF  02,80
0A0E:  MOVFF  01,7F
0A12:  MOVFF  00,7E
....................  
....................       y2=y*y; 
0A16:  MOVFF  81,9D
0A1A:  MOVFF  80,9C
0A1E:  MOVFF  7F,9B
0A22:  MOVFF  7E,9A
0A26:  MOVFF  81,A1
0A2A:  MOVFF  80,A0
0A2E:  MOVFF  7F,9F
0A32:  MOVFF  7E,9E
0A36:  RCALL  03E6
0A38:  MOVFF  03,8D
0A3C:  MOVFF  02,8C
0A40:  MOVFF  01,8B
0A44:  MOVFF  00,8A
....................  
....................       res = pl[0]*y2 + pl[1]; 
0A48:  MOVLW  99
0A4A:  MOVWF  x9D
0A4C:  MOVLW  47
0A4E:  MOVWF  x9C
0A50:  MOVLW  8A
0A52:  MOVWF  x9B
0A54:  MOVLW  7F
0A56:  MOVWF  x9A
0A58:  MOVFF  8D,A1
0A5C:  MOVFF  8C,A0
0A60:  MOVFF  8B,9F
0A64:  MOVFF  8A,9E
0A68:  RCALL  03E6
0A6A:  MOVFF  03,92
0A6E:  MOVFF  02,91
0A72:  MOVFF  01,90
0A76:  MOVFF  00,8F
0A7A:  BCF    FD8.1
0A7C:  MOVFF  03,A1
0A80:  MOVFF  02,A0
0A84:  MOVFF  01,9F
0A88:  MOVFF  00,9E
0A8C:  CLRF   xA5
0A8E:  CLRF   xA4
0A90:  CLRF   xA3
0A92:  MOVLW  80
0A94:  MOVWF  xA2
0A96:  RCALL  0632
0A98:  MOVFF  03,85
0A9C:  MOVFF  02,84
0AA0:  MOVFF  01,83
0AA4:  MOVFF  00,82
....................  
....................       r = ql[0]*y2 + ql[1]; 
0AA8:  MOVLW  4C
0AAA:  MOVWF  x9D
0AAC:  MOVLW  F3
0AAE:  MOVWF  x9C
0AB0:  MOVLW  3A
0AB2:  MOVWF  x9B
0AB4:  MOVLW  7B
0AB6:  MOVWF  x9A
0AB8:  MOVFF  8D,A1
0ABC:  MOVFF  8C,A0
0AC0:  MOVFF  8B,9F
0AC4:  MOVFF  8A,9E
0AC8:  RCALL  03E6
0ACA:  MOVFF  03,92
0ACE:  MOVFF  02,91
0AD2:  MOVFF  01,90
0AD6:  MOVFF  00,8F
0ADA:  BCF    FD8.1
0ADC:  MOVFF  03,A1
0AE0:  MOVFF  02,A0
0AE4:  MOVFF  01,9F
0AE8:  MOVFF  00,9E
0AEC:  MOVLW  2B
0AEE:  MOVWF  xA5
0AF0:  MOVLW  9D
0AF2:  MOVWF  xA4
0AF4:  MOVLW  DF
0AF6:  MOVWF  xA3
0AF8:  MOVLW  7E
0AFA:  MOVWF  xA2
0AFC:  RCALL  0632
0AFE:  MOVFF  03,89
0B02:  MOVFF  02,88
0B06:  MOVFF  01,87
0B0A:  MOVFF  00,86
....................       r = r*y2 + 1.0; 
0B0E:  MOVFF  89,9D
0B12:  MOVFF  88,9C
0B16:  MOVFF  87,9B
0B1A:  MOVFF  86,9A
0B1E:  MOVFF  8D,A1
0B22:  MOVFF  8C,A0
0B26:  MOVFF  8B,9F
0B2A:  MOVFF  8A,9E
0B2E:  RCALL  03E6
0B30:  MOVFF  03,92
0B34:  MOVFF  02,91
0B38:  MOVFF  01,90
0B3C:  MOVFF  00,8F
0B40:  BCF    FD8.1
0B42:  MOVFF  03,A1
0B46:  MOVFF  02,A0
0B4A:  MOVFF  01,9F
0B4E:  MOVFF  00,9E
0B52:  CLRF   xA5
0B54:  CLRF   xA4
0B56:  CLRF   xA3
0B58:  MOVLW  7F
0B5A:  MOVWF  xA2
0B5C:  RCALL  0632
0B5E:  MOVFF  03,89
0B62:  MOVFF  02,88
0B66:  MOVFF  01,87
0B6A:  MOVFF  00,86
....................  
....................       res = y*res/r; 
0B6E:  MOVFF  81,9D
0B72:  MOVFF  80,9C
0B76:  MOVFF  7F,9B
0B7A:  MOVFF  7E,9A
0B7E:  MOVFF  85,A1
0B82:  MOVFF  84,A0
0B86:  MOVFF  83,9F
0B8A:  MOVFF  82,9E
0B8E:  RCALL  03E6
0B90:  MOVFF  03,92
0B94:  MOVFF  02,91
0B98:  MOVFF  01,90
0B9C:  MOVFF  00,8F
0BA0:  MOVFF  03,96
0BA4:  MOVFF  02,95
0BA8:  MOVFF  01,94
0BAC:  MOVFF  00,93
0BB0:  MOVFF  89,9A
0BB4:  MOVFF  88,99
0BB8:  MOVFF  87,98
0BBC:  MOVFF  86,97
0BC0:  RCALL  04D8
0BC2:  MOVFF  03,85
0BC6:  MOVFF  02,84
0BCA:  MOVFF  01,83
0BCE:  MOVFF  00,82
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
0BD2:  CLRF   x90
0BD4:  MOVLW  7A
0BD6:  MOVWF  FE9
0BD8:  MOVFF  90,FEA
0BDC:  MOVLW  7E
0BDE:  SUBWF  FEF,W
0BE0:  MOVWF  x8E
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
0BE2:  BTFSS  x8E.7
0BE4:  BRA    0C0A
....................          r = -(float32)-n; 
0BE6:  MOVLW  00
0BE8:  BSF    FD8.0
0BEA:  SUBFWB x8E,W
0BEC:  CLRF   x91
0BEE:  MOVWF  x90
0BF0:  BTFSC  x90.7
0BF2:  DECF   x91,F
0BF4:  RCALL  0912
0BF6:  MOVFF  00,86
0BFA:  MOVF   01,W
0BFC:  XORLW  80
0BFE:  MOVWF  x87
0C00:  MOVFF  02,88
0C04:  MOVFF  03,89
0C08:  BRA    0C26
....................       else 
....................          r = (float32)n; 
0C0A:  CLRF   x91
0C0C:  MOVFF  8E,90
0C10:  BTFSC  x90.7
0C12:  DECF   x91,F
0C14:  RCALL  0912
0C16:  MOVFF  03,89
0C1A:  MOVFF  02,88
0C1E:  MOVFF  01,87
0C22:  MOVFF  00,86
....................  
....................       res += r*LN2; 
0C26:  MOVFF  89,9D
0C2A:  MOVFF  88,9C
0C2E:  MOVFF  87,9B
0C32:  MOVFF  86,9A
0C36:  MOVLW  18
0C38:  MOVWF  xA1
0C3A:  MOVLW  72
0C3C:  MOVWF  xA0
0C3E:  MOVLW  31
0C40:  MOVWF  x9F
0C42:  MOVLW  7E
0C44:  MOVWF  x9E
0C46:  CALL   03E6
0C4A:  BCF    FD8.1
0C4C:  MOVFF  85,A1
0C50:  MOVFF  84,A0
0C54:  MOVFF  83,9F
0C58:  MOVFF  82,9E
0C5C:  MOVFF  03,A5
0C60:  MOVFF  02,A4
0C64:  MOVFF  01,A3
0C68:  MOVFF  00,A2
0C6C:  RCALL  0632
0C6E:  MOVFF  03,85
0C72:  MOVFF  02,84
0C76:  MOVFF  01,83
0C7A:  MOVFF  00,82
....................    } 
0C7E:  BRA    0C88
....................  
....................    else 
....................       res = 0.0; 
0C80:  CLRF   x85
0C82:  CLRF   x84
0C84:  CLRF   x83
0C86:  CLRF   x82
....................  
....................    return(res); 
0C88:  MOVFF  82,00
0C8C:  MOVFF  83,01
0C90:  MOVFF  84,02
0C94:  MOVFF  85,03
0C98:  RETURN 0
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
*
1562:  MOVFF  71,9D
1566:  MOVFF  70,9C
156A:  MOVFF  6F,9B
156E:  MOVFF  6E,9A
1572:  CLRF   xA1
1574:  CLRF   xA0
1576:  CLRF   x9F
1578:  CLRF   x9E
157A:  CALL   089C
157E:  BTFSS  FD8.0
1580:  BRA    1718
1582:  MOVFF  75,79
1586:  MOVFF  74,78
158A:  MOVFF  73,77
158E:  MOVFF  72,76
1592:  CLRF   x7D
1594:  CLRF   x7C
1596:  CLRF   x7B
1598:  MOVLW  7F
159A:  MOVWF  x7A
159C:  RCALL  1034
159E:  MOVFF  03,79
15A2:  MOVFF  02,78
15A6:  MOVFF  01,77
15AA:  MOVFF  00,76
15AE:  MOVFF  03,9D
15B2:  MOVFF  02,9C
15B6:  MOVFF  01,9B
15BA:  MOVFF  00,9A
15BE:  CLRF   xA1
15C0:  CLRF   xA0
15C2:  CLRF   x9F
15C4:  CLRF   x9E
15C6:  CALL   089C
15CA:  BTFSS  FD8.2
15CC:  BRA    1718
....................       if(fmod(y, 2) == 0) { 
15CE:  MOVFF  75,79
15D2:  MOVFF  74,78
15D6:  MOVFF  73,77
15DA:  MOVFF  72,76
15DE:  CLRF   x7D
15E0:  CLRF   x7C
15E2:  CLRF   x7B
15E4:  MOVLW  80
15E6:  MOVWF  x7A
15E8:  RCALL  1034
15EA:  MOVFF  03,79
15EE:  MOVFF  02,78
15F2:  MOVFF  01,77
15F6:  MOVFF  00,76
15FA:  MOVFF  03,9D
15FE:  MOVFF  02,9C
1602:  MOVFF  01,9B
1606:  MOVFF  00,9A
160A:  CLRF   xA1
160C:  CLRF   xA0
160E:  CLRF   x9F
1610:  CLRF   x9E
1612:  CALL   089C
1616:  BNZ   1696
....................          return (exp(log(-x) * y)); 
1618:  MOVFF  6E,76
161C:  MOVF   x6F,W
161E:  XORLW  80
1620:  MOVWF  x77
1622:  MOVFF  70,78
1626:  MOVFF  71,79
162A:  MOVFF  71,7D
162E:  MOVFF  70,7C
1632:  MOVWF  x7B
1634:  MOVFF  6E,7A
1638:  CALL   095A
163C:  MOVFF  03,79
1640:  MOVFF  02,78
1644:  MOVFF  01,77
1648:  MOVFF  00,76
164C:  MOVFF  03,9D
1650:  MOVFF  02,9C
1654:  MOVFF  01,9B
1658:  MOVFF  00,9A
165C:  MOVFF  75,A1
1660:  MOVFF  74,A0
1664:  MOVFF  73,9F
1668:  MOVFF  72,9E
166C:  CALL   03E6
1670:  MOVFF  03,79
1674:  MOVFF  02,78
1678:  MOVFF  01,77
167C:  MOVFF  00,76
1680:  MOVFF  03,7D
1684:  MOVFF  02,7C
1688:  MOVFF  01,7B
168C:  MOVFF  00,7A
1690:  RCALL  1190
1692:  BRA    1834
....................       } else { 
1694:  BRA    1716
....................          return (-exp(log(-x) * y)); 
1696:  MOVFF  6E,76
169A:  MOVF   x6F,W
169C:  XORLW  80
169E:  MOVWF  x77
16A0:  MOVFF  70,78
16A4:  MOVFF  71,79
16A8:  MOVFF  71,7D
16AC:  MOVFF  70,7C
16B0:  MOVWF  x7B
16B2:  MOVFF  6E,7A
16B6:  CALL   095A
16BA:  MOVFF  03,79
16BE:  MOVFF  02,78
16C2:  MOVFF  01,77
16C6:  MOVFF  00,76
16CA:  MOVFF  03,9D
16CE:  MOVFF  02,9C
16D2:  MOVFF  01,9B
16D6:  MOVFF  00,9A
16DA:  MOVFF  75,A1
16DE:  MOVFF  74,A0
16E2:  MOVFF  73,9F
16E6:  MOVFF  72,9E
16EA:  CALL   03E6
16EE:  MOVFF  03,79
16F2:  MOVFF  02,78
16F6:  MOVFF  01,77
16FA:  MOVFF  00,76
16FE:  MOVFF  03,7D
1702:  MOVFF  02,7C
1706:  MOVFF  01,7B
170A:  MOVFF  00,7A
170E:  RCALL  1190
1710:  MOVLW  80
1712:  XORWF  01,F
1714:  BRA    1834
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
1716:  BRA    1834
1718:  MOVFF  71,9D
171C:  MOVFF  70,9C
1720:  MOVFF  6F,9B
1724:  MOVFF  6E,9A
1728:  CLRF   xA1
172A:  CLRF   xA0
172C:  CLRF   x9F
172E:  CLRF   x9E
1730:  CALL   089C
1734:  BNC   178C
1736:  MOVFF  75,79
173A:  MOVFF  74,78
173E:  MOVFF  73,77
1742:  MOVFF  72,76
1746:  CLRF   x7D
1748:  CLRF   x7C
174A:  CLRF   x7B
174C:  MOVLW  7F
174E:  MOVWF  x7A
1750:  RCALL  1034
1752:  MOVFF  03,79
1756:  MOVFF  02,78
175A:  MOVFF  01,77
175E:  MOVFF  00,76
1762:  MOVFF  03,9D
1766:  MOVFF  02,9C
176A:  MOVFF  01,9B
176E:  MOVFF  00,9A
1772:  CLRF   xA1
1774:  CLRF   xA0
1776:  CLRF   x9F
1778:  CLRF   x9E
177A:  CALL   089C
177E:  BZ    178C
....................       return 0; 
1780:  CLRF   00
1782:  CLRF   01
1784:  CLRF   02
1786:  CLRF   03
1788:  BRA    1834
....................    } else { 
178A:  BRA    1834
....................       if(x != 0 || 0 >= y) { 
178C:  MOVFF  71,9D
1790:  MOVFF  70,9C
1794:  MOVFF  6F,9B
1798:  MOVFF  6E,9A
179C:  CLRF   xA1
179E:  CLRF   xA0
17A0:  CLRF   x9F
17A2:  CLRF   x9E
17A4:  CALL   089C
17A8:  BNZ   17CA
17AA:  MOVFF  75,9D
17AE:  MOVFF  74,9C
17B2:  MOVFF  73,9B
17B6:  MOVFF  72,9A
17BA:  CLRF   xA1
17BC:  CLRF   xA0
17BE:  CLRF   x9F
17C0:  CLRF   x9E
17C2:  CALL   089C
17C6:  BC    17CA
17C8:  BNZ   1834
....................          return (exp(log(x) * y)); 
17CA:  MOVFF  71,7D
17CE:  MOVFF  70,7C
17D2:  MOVFF  6F,7B
17D6:  MOVFF  6E,7A
17DA:  CALL   095A
17DE:  MOVFF  03,79
17E2:  MOVFF  02,78
17E6:  MOVFF  01,77
17EA:  MOVFF  00,76
17EE:  MOVFF  03,9D
17F2:  MOVFF  02,9C
17F6:  MOVFF  01,9B
17FA:  MOVFF  00,9A
17FE:  MOVFF  75,A1
1802:  MOVFF  74,A0
1806:  MOVFF  73,9F
180A:  MOVFF  72,9E
180E:  CALL   03E6
1812:  MOVFF  03,79
1816:  MOVFF  02,78
181A:  MOVFF  01,77
181E:  MOVFF  00,76
1822:  MOVFF  03,7D
1826:  MOVFF  02,7C
182A:  MOVFF  01,7B
182E:  MOVFF  00,7A
1832:  RCALL  1190
....................       } 
....................    } 
1834:  GOTO   19DC (RETURN)
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #fuses HS,NOWDT,PUT,NOBROWNOUT,NOLVP   // configuração dos fuses do pic  
.................... #define  t_filtro 400  
.................... #use   delay(clock=20000000)// Informa a função delay, o clock utilizado 
*
0306:  CLRF   FEA
0308:  MOVLW  70
030A:  MOVWF  FE9
030C:  MOVF   FEF,W
030E:  BZ    032A
0310:  MOVLW  06
0312:  MOVWF  01
0314:  CLRF   00
0316:  DECFSZ 00,F
0318:  BRA    0316
031A:  DECFSZ 01,F
031C:  BRA    0314
031E:  MOVLW  7B
0320:  MOVWF  00
0322:  DECFSZ 00,F
0324:  BRA    0322
0326:  DECFSZ FEF,F
0328:  BRA    0310
032A:  RETURN 0
*
1C84:  MOVLW  03
1C86:  SUBWF  x70,F
1C88:  BNC   1C9C
1C8A:  CLRF   FEA
1C8C:  MOVLW  70
1C8E:  MOVWF  FE9
1C90:  MOVF   FEF,W
1C92:  BZ    1C9C
1C94:  BRA    1C98
1C96:  BRA    1C98
1C98:  DECFSZ FEF,F
1C9A:  BRA    1C96
1C9C:  RETURN 0
.................... #BIT Data_Pin = 0x06.7                       // Pin mapped to PORTB.7 
.................... #BIT Data_Pin_Direction = 0x86.7             // Pin direction mapped to TRISB.7 
....................  
....................    //modo rápido de inicialização das portas 
....................    #use   fast_io(a) 
....................    #use   fast_io(b) 
....................    #use   fast_io(d) 
....................    #use   fast_io(e) 
....................     
....................    // atribui o nome "porta" ao registrador  port  
....................    #byte   porta = 0xf80  
....................    #byte   portb = 0xf81  
....................    #byte   portd = 0xf83 
....................    #byte   porte = 0xf84 
....................    #byte   portc = 0xf82 
....................     
....................    // pinos de entrada  
....................    #bit NTC = porta.0    //  Pino de leitura do NTC  
....................    #bit PIN_COOLER = portc.0  //  Pino de leitura do DHT11 
....................   // #bit POT_SET_TEMP = porta.1 //Pino de leitura do potenciometro de set da temperatura  
....................    //#bit POT_SET_UMI = porta.2 //Pino de leitura do potenciometro de set da umidade  
....................    #bit BOT_BLK_LTH = portb.0 // Pino do botao paraligar a luz do lcd 
....................    #bit config_Bot  = portb.4 // botao para navegação no lcd; auxilia na configuraçao dos parametros 
....................    #bit BOT_INI  = portb.1 // botao para navegação no lcd; auxilia na configuraçao dos parametros 
....................    
....................    // pinos de saida 
....................    #bit PIN_SERV = portb.3 
....................    #bit RELE_LAMP = portb.2  //  pino que acionamento do relé da lampada/aquecedor 
....................    #bit DHT11 = portb.7 // Pino de acionamento do cooler via transistor  
....................    #bit rs =porte.0 //  via do lcd que sinaliza recepção de dados ou comando  
....................    #bit enable = porte.1 // habilita o lcd 
....................    #byte DISPLAY = portd //  seleciona o port no qual o lcd esta ligado ( o mesmo valor que esta no arquivo.h) 
....................    #INCLUDE <lcd.h> // inclui a biblioteca do modulo lcd 
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *      Rotina que envia um COMANDO para o LCD                 * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void comando_lcd(int caracter) 
.................... { 
....................    rs = 0;               // seleciona o envio de um caracter 
*
02EA:  BCF    F84.0
....................    portd = caracter;         // carrega o portc com o caracter 
02EC:  MOVFF  6F,F83
....................    enable = 1 ;            // gera pulso no enable 
02F0:  BSF    F84.1
....................    delay_us(1);            // espera 1 microsegundos 
02F2:  BRA    02F4
02F4:  BRA    02F6
02F6:  NOP   
....................    enable = 0;            // desce o pino de enable 
02F8:  BCF    F84.1
....................  
....................    delay_us(40);            // espera mínimo 40 microsegundos 
02FA:  MOVLW  42
02FC:  MOVWF  00
02FE:  DECFSZ 00,F
0300:  BRA    02FE
0302:  NOP   
....................     
....................    return;               // retorna 
0304:  RETURN 0
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *      Rotina que envia um DADO a ser escrito no LCD              * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void escreve_lcd(int caracter) 
.................... { 
....................    rs = 1;               // seleciona o envio de um comando 
*
0374:  BSF    F84.0
....................    portd = caracter;         // carrega o portc com o valor do comando 
0376:  MOVFF  7B,F83
....................    enable = 1;            // gera pulso no enable 
037A:  BSF    F84.1
....................    delay_us(1);            // espera 3 microsegundos 
037C:  BRA    037E
037E:  BRA    0380
0380:  NOP   
....................    enable = 0;            // desce o pino de enable 
0382:  BCF    F84.1
....................  
....................    delay_us(40);            // espera mínimo 40 microsegundos 
0384:  MOVLW  42
0386:  MOVWF  00
0388:  DECFSZ 00,F
038A:  BRA    0388
038C:  NOP   
....................     
....................    return;               // retorna 
038E:  RETURN 0
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *              Função para limpar o LCD                 * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void limpa_lcd() 
.................... { 
....................    comando_lcd(0x01);         // limpa lcd    
*
032C:  MOVLW  01
032E:  MOVWF  x6F
0330:  RCALL  02EA
....................    delay_ms (2); 
0332:  MOVLW  02
0334:  MOVWF  x70
0336:  RCALL  0306
....................    return; 
0338:  RETURN 0
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *           Inicialização do Display de LCD                 * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void inicializa_lcd() 
.................... { 
....................    comando_lcd(0x30);         // envia comando para inicializar display 
033A:  MOVLW  30
033C:  MOVWF  x6F
033E:  RCALL  02EA
....................    delay_ms(4);            // espera 4 milisengundos 
0340:  MOVLW  04
0342:  MOVWF  x70
0344:  RCALL  0306
....................  
....................    comando_lcd(0x30);         // envia comando para inicializar display 
0346:  MOVLW  30
0348:  MOVWF  x6F
034A:  RCALL  02EA
....................    delay_us(100);            // espera 100 microsengundos 
034C:  MOVLW  A6
034E:  MOVWF  00
0350:  DECFSZ 00,F
0352:  BRA    0350
0354:  NOP   
....................  
....................    comando_lcd(0x30);         // envia comando para inicializar display 
0356:  MOVLW  30
0358:  MOVWF  x6F
035A:  RCALL  02EA
....................  
....................    comando_lcd(0x38);         // liga o display, sem cursor e sem blink 
035C:  MOVLW  38
035E:  MOVWF  x6F
0360:  RCALL  02EA
....................  
....................    limpa_lcd();            // limpa lcd 
0362:  RCALL  032C
....................  
....................    comando_lcd(0x0c);         // display sem cursor 
0364:  MOVLW  0C
0366:  MOVWF  x6F
0368:  RCALL  02EA
....................  
....................    comando_lcd(0x06);         // desloca cursor para a direita 
036A:  MOVLW  06
036C:  MOVWF  x6F
036E:  RCALL  02EA
....................  
....................    return;               // retorna 
0370:  GOTO   26DA (RETURN)
.................... }    
....................  
....................     
....................  
.................... char message2[] = "RH   = 00.0 %"; //  vetor de mensagem para a umidade  
.................... short Time_out; //  variavel para as funçoes referentes ao sensor de umidade dht11 
.................... unsigned  int8 RH_byte1, RH_byte2, CheckSum; //  variaveis para as funçoes do dht11 
....................  
.................... float ntc_val = 0; // variavel responsavel por receber o valor digital do ntc 
.................... float rntc = 0; //  valor da resistencia do divisor de tensao do ntc  
.................... float b1=0;  //  variavel auxiliar para função do ntc 
.................... float c1=0;//  variavel auxiliar para função do ntc 
.................... float temp=0;//  variavel auxiliar para função do ntc 
.................... float temperatura=0;//  variavel auxiliar para função do ntc 
.................... char umidade;//  variavel auxiliar para função do ntc 
.................... double a = 0.0011303; //  constantes fisicas do sensor ntc 10k 
.................... double b = 0.0002339; //  constantes fisicas do sensor ntc 10k 
.................... double c = 0.00000008863; //  constantes fisicas do sensor ntc 10k 
.................... int cont=0; // auxila no que vai ser mostrado na tela default 
.................... long int cont_int = 0; 
.................... int horas=0; 
....................       //variáveis 
....................       int cont_ini=0; // variavel contadora utilizada todda vez q o btao inciar é pressionado 
....................       int cont_aux=0; 
....................       int cont_rotina=0;// usada pra fazer o laço de rotina do progrma quando o botao iniciar for pressionado 
....................       long valor_AD; // recebe o valor da conversao AD 
....................       long INT filtro_b1  = t_filtro; 
....................       long INT filtro_INI  = t_filtro; 
....................       int flags=0;            // utilizada para no deboccing para sinalizar 
....................       int cont_config=0;            // variavel q sinaliza quando o botao configuraçao é pressionado por mais de 500ms 
....................       float value1;         // auxilia na conversão do valor OBTIDO APOS ADC para TEMPERATURA E UMIDADE 
....................       float set_temp =0;   // valor de refeencia pra temperatura maxima 
....................       float set_umi =0; // valor de referencia para a umidade 
....................       #bit  BTN_B1 = flags.0 // flag do botao configuraçao 
....................       #bit  BTN_INI = flags.1 // flag do botao inciar 
....................       #bit  UNLOCK = flags.2 // flag para bloquear o inicio do programa se a configuração nao tiver sido feita 
....................  
....................  
....................  
.................... // Interrupção para acionar o servo motor a cada 3 horas 
.................... #int_timer0 
.................... void trata_tmr0 () 
.................... { 
....................    set_timer0(131 + get_timer0()); 
*
0096:  MOVF   FD6,W
0098:  MOVFF  FD7,03
009C:  ADDLW  83
009E:  MOVWF  xAE
00A0:  MOVLW  00
00A2:  ADDWFC FD7,W
00A4:  MOVWF  FD7
00A6:  MOVFF  AE,FD6
....................    cont_int++; 
00AA:  INCF   54,F
00AC:  BTFSC  FD8.2
00AE:  INCF   55,F
....................    if(cont_int > 2246400) // uma hora 2246400  MIN 37440 
....................    { 
....................       cont_int = 0; 
....................       horas++;       
....................    } 
....................     
....................   
00B0:  BCF    FF2.2
00B2:  GOTO   0054
.................... } 
....................  
....................  
....................  
.................... // FUNÇÃO POR INICIAR A DHT11 
.................... void start_signal(){ 
....................   Data_Pin_Direction = 0;              // Configure connection pin as output 
*
1B04:  BCF    x86.7
....................   Data_Pin = 0;                        // Connection pin output low 
1B06:  BCF    06.7
....................   delay_ms(25); 
1B08:  MOVLW  19
1B0A:  MOVWF  x70
1B0C:  CALL   0306
....................   Data_Pin = 1;                        // Connection pin output high 
1B10:  BSF    06.7
....................   delay_us(30); 
1B12:  MOVLW  31
1B14:  MOVWF  00
1B16:  DECFSZ 00,F
1B18:  BRA    1B16
1B1A:  BRA    1B1C
....................   Data_Pin_Direction = 1;              // Configure connection pin as input 
1B1C:  BSF    x86.7
1B1E:  GOTO   1C28 (RETURN)
.................... } 
....................  
.................... // FUNÇAÕ POR VERIFICAR SE O SENSOR ESTA RESPONDENDO  
....................  
....................   short check_response(){ 
....................   delay_us(40); 
1B22:  MOVLW  42
1B24:  MOVWF  00
1B26:  DECFSZ 00,F
1B28:  BRA    1B26
1B2A:  NOP   
....................   if(!Data_Pin){                     // Read and test if connection pin is low 
1B2C:  BTFSC  06.7
1B2E:  BRA    1B50
....................     delay_us(80); 
1B30:  MOVLW  84
1B32:  MOVWF  00
1B34:  DECFSZ 00,F
1B36:  BRA    1B34
1B38:  BRA    1B3A
1B3A:  NOP   
....................     if(Data_Pin){                    // Read and test if connection pin is high 
1B3C:  BTFSS  06.7
1B3E:  BRA    1B50
....................       delay_us(50); 
1B40:  MOVLW  52
1B42:  MOVWF  00
1B44:  DECFSZ 00,F
1B46:  BRA    1B44
1B48:  BRA    1B4A
1B4A:  NOP   
....................       return 1;} 
1B4C:  MOVLW  01
1B4E:  MOVWF  01
....................     } 
1B50:  GOTO   1C2A (RETURN)
.................... } 
....................  
....................  
.................... // FUNÇÃO PARA A OBTENÇÃO DO VALOR DE HUMIDADE 
.................... unsigned int8 Read_Data(){ 
1B54:  CLRF   x70
....................   unsigned int8 i, k, _data = 0;     // k is used to count 1 bit reading duration 
....................   if(Time_out) 
1B56:  BTFSS  2A.0
1B58:  BRA    1B5A
....................     break; 
....................   for(i = 0; i < 8; i++){ 
1B5A:  CLRF   x6E
1B5C:  MOVF   x6E,W
1B5E:  SUBLW  07
1B60:  BNC   1BE6
....................     k = 0; 
1B62:  CLRF   x6F
....................     while(!Data_Pin){                          // Wait until pin goes high 
1B64:  BTFSC  06.7
1B66:  BRA    1B7C
....................       k++; 
1B68:  INCF   x6F,F
....................       if (k > 100) {Time_out = 1; break;} 
1B6A:  MOVF   x6F,W
1B6C:  SUBLW  64
1B6E:  BC    1B74
1B70:  BSF    2A.0
1B72:  BRA    1B7C
....................       delay_us(1);} 
1B74:  BRA    1B76
1B76:  BRA    1B78
1B78:  NOP   
1B7A:  BRA    1B64
....................     delay_us(30); 
1B7C:  MOVLW  31
1B7E:  MOVWF  00
1B80:  DECFSZ 00,F
1B82:  BRA    1B80
1B84:  BRA    1B86
....................     if(!Data_Pin) 
1B86:  BTFSC  06.7
1B88:  BRA    1BAC
....................       bit_clear(_data, (7 - i));               // Clear bit (7 - i) 
1B8A:  MOVLW  07
1B8C:  BSF    FD8.0
1B8E:  SUBFWB x6E,W
1B90:  MOVWF  x71
1B92:  MOVLW  01
1B94:  MOVWF  00
1B96:  MOVF   x71,W
1B98:  MOVWF  01
1B9A:  BZ    1BA4
1B9C:  BCF    FD8.0
1B9E:  RLCF   00,F
1BA0:  DECFSZ 01,F
1BA2:  BRA    1B9C
1BA4:  MOVF   00,W
1BA6:  XORLW  FF
1BA8:  ANDWF  x70,F
1BAA:  BRA    1BE2
....................     else{ 
....................       bit_set(_data, (7 - i));                 // Set bit (7 - i) 
1BAC:  MOVLW  07
1BAE:  BSF    FD8.0
1BB0:  SUBFWB x6E,W
1BB2:  MOVWF  x71
1BB4:  MOVLW  01
1BB6:  MOVWF  00
1BB8:  MOVF   x71,W
1BBA:  MOVWF  01
1BBC:  BZ    1BC6
1BBE:  BCF    FD8.0
1BC0:  RLCF   00,F
1BC2:  DECFSZ 01,F
1BC4:  BRA    1BBE
1BC6:  MOVF   00,W
1BC8:  IORWF  x70,F
....................       while(Data_Pin){                         // Wait until pin goes low 
1BCA:  BTFSS  06.7
1BCC:  BRA    1BE2
....................       k++; 
1BCE:  INCF   x6F,F
....................       if (k > 100) {Time_out = 1; break;} 
1BD0:  MOVF   x6F,W
1BD2:  SUBLW  64
1BD4:  BC    1BDA
1BD6:  BSF    2A.0
1BD8:  BRA    1BE2
....................       delay_us(1);} 
1BDA:  BRA    1BDC
1BDC:  BRA    1BDE
1BDE:  NOP   
1BE0:  BRA    1BCA
....................     } 
1BE2:  INCF   x6E,F
1BE4:  BRA    1B5C
....................   } 
....................   return _data; 
1BE6:  MOVFF  70,01
1BEA:  RETURN 0
.................... } 
....................  
.................... // FUNÇÃO PRINCIPAL QUE RETORNARA A UMIDADE  
....................  
.................... char dht11(){ 
....................    delay_ms(1000); 
*
1C14:  MOVLW  04
1C16:  MOVWF  x6E
1C18:  MOVLW  FA
1C1A:  MOVWF  x70
1C1C:  CALL   0306
1C20:  DECFSZ x6E,F
1C22:  BRA    1C18
....................    Time_out = 0; 
1C24:  BCF    2A.0
....................    Start_signal(); 
1C26:  BRA    1B04
....................    if(check_response()){// If there is response from sensor 
1C28:  BRA    1B22
1C2A:  MOVF   01,F
1C2C:  BZ    1C78
....................    RH_byte1=Read_Data();// read RH byte1 
1C2E:  RCALL  1B54
1C30:  MOVFF  01,2B
....................    RH_byte2=Read_Data();// read RH byte2 
1C34:  RCALL  1B54
1C36:  MOVFF  01,2C
....................    Checksum=Read_Data();// read checksum                    
1C3A:  RCALL  1B54
1C3C:  MOVFF  01,2D
....................       if(CheckSum==((RH_Byte1+RH_Byte2)& 0xFF)){ 
1C40:  MOVF   2C,W
1C42:  ADDWF  2B,W
1C44:  SUBWF  2D,W
1C46:  BNZ   1C78
....................       message2[7]=RH_Byte1/10+48; 
1C48:  MOVFF  2B,6E
1C4C:  MOVLW  0A
1C4E:  MOVWF  x6F
1C50:  RCALL  1BEC
1C52:  MOVLW  30
1C54:  ADDWF  01,W
1C56:  MOVWF  23
....................              message2[8]= RH_Byte1%10+48; 
1C58:  MOVFF  2B,6E
1C5C:  MOVLW  0A
1C5E:  MOVWF  x6F
1C60:  RCALL  1BEC
1C62:  MOVLW  30
1C64:  ADDWF  00,W
1C66:  MOVWF  24
....................              message2[10] = RH_Byte2/10+48;                             
1C68:  MOVFF  2C,6E
1C6C:  MOVLW  0A
1C6E:  MOVWF  x6F
1C70:  RCALL  1BEC
1C72:  MOVLW  30
1C74:  ADDWF  01,W
1C76:  MOVWF  26
....................        } 
....................    }  
....................    return message2; 
1C78:  MOVLW  1C
1C7A:  MOVWF  01
1C7C:  MOVLW  00
1C7E:  MOVWF  02
1C80:  GOTO   2804 (RETURN)
.................... } 
....................  
....................  
....................  
....................  
....................    float ntc(){ 
....................        set_adc_channel(0); //  escolhe o pino analogico para ler   
*
1838:  MOVLW  00
183A:  MOVWF  01
183C:  MOVF   FC2,W
183E:  ANDLW  C3
1840:  IORWF  01,W
1842:  MOVWF  FC2
....................        delay_us(10); // delay para começar a conversão 
1844:  MOVLW  10
1846:  MOVWF  00
1848:  DECFSZ 00,F
184A:  BRA    1848
184C:  NOP   
....................        read_adc(ADC_START_ONLY ); 
184E:  BSF    FC2.1
....................       while(!adc_done()){ 
1850:  BTFSS  FC2.1
1852:  BRA    1856
1854:  BRA    1850
....................       } 
....................       ntc_val = read_adc(ADC_READ_ONLY ); // le o valor na porta analogica 
1856:  BTFSC  FC2.1
1858:  BRA    1856
185A:  MOVFF  FC4,03
185E:  MOVFF  FC3,9E
1862:  MOVFF  FC4,9F
1866:  CALL   03B0
186A:  MOVFF  03,31
186E:  MOVFF  02,30
1872:  MOVFF  01,2F
1876:  MOVFF  00,2E
....................       ntc_val *=5; // multiplica o valor digitalizado pelo valor de tensão de alimentação 
187A:  MOVFF  31,9D
187E:  MOVFF  30,9C
1882:  MOVFF  2F,9B
1886:  MOVFF  2E,9A
188A:  CLRF   xA1
188C:  CLRF   xA0
188E:  MOVLW  20
1890:  MOVWF  x9F
1892:  MOVLW  81
1894:  MOVWF  x9E
1896:  CALL   03E6
189A:  MOVFF  03,31
189E:  MOVFF  02,30
18A2:  MOVFF  01,2F
18A6:  MOVFF  00,2E
....................       ntc_val/=1023;  // divide  o valor acima por 1023 
18AA:  MOVFF  31,96
18AE:  MOVFF  30,95
18B2:  MOVFF  2F,94
18B6:  MOVFF  2E,93
18BA:  CLRF   x9A
18BC:  MOVLW  C0
18BE:  MOVWF  x99
18C0:  MOVLW  7F
18C2:  MOVWF  x98
18C4:  MOVLW  88
18C6:  MOVWF  x97
18C8:  CALL   04D8
18CC:  MOVFF  03,31
18D0:  MOVFF  02,30
18D4:  MOVFF  01,2F
18D8:  MOVFF  00,2E
....................       // Inicio calculo de equação de  Steinhart & Hart  
....................       rntc=50000/ntc_val;      
18DC:  CLRF   x96
18DE:  MOVLW  50
18E0:  MOVWF  x95
18E2:  MOVLW  43
18E4:  MOVWF  x94
18E6:  MOVLW  8E
18E8:  MOVWF  x93
18EA:  MOVFF  31,9A
18EE:  MOVFF  30,99
18F2:  MOVFF  2F,98
18F6:  MOVFF  2E,97
18FA:  CALL   04D8
18FE:  MOVFF  03,35
1902:  MOVFF  02,34
1906:  MOVFF  01,33
190A:  MOVFF  00,32
....................              rntc=rntc-10000;       
190E:  BSF    FD8.1
1910:  MOVFF  35,A1
1914:  MOVFF  34,A0
1918:  MOVFF  33,9F
191C:  MOVFF  32,9E
1920:  CLRF   xA5
1922:  MOVLW  40
1924:  MOVWF  xA4
1926:  MOVLW  1C
1928:  MOVWF  xA3
192A:  MOVLW  8C
192C:  MOVWF  xA2
192E:  CALL   0632
1932:  MOVFF  03,35
1936:  MOVFF  02,34
193A:  MOVFF  01,33
193E:  MOVFF  00,32
....................              b1=log(rntc);           
1942:  MOVFF  35,7D
1946:  MOVFF  34,7C
194A:  MOVFF  33,7B
194E:  MOVFF  32,7A
1952:  CALL   095A
1956:  MOVFF  03,39
195A:  MOVFF  02,38
195E:  MOVFF  01,37
1962:  MOVFF  00,36
....................              b1=b1*b;                
1966:  MOVFF  39,9D
196A:  MOVFF  38,9C
196E:  MOVFF  37,9B
1972:  MOVFF  36,9A
1976:  MOVFF  4E,A1
197A:  MOVFF  4D,A0
197E:  MOVFF  4C,9F
1982:  MOVFF  4B,9E
1986:  CALL   03E6
198A:  MOVFF  03,39
198E:  MOVFF  02,38
1992:  MOVFF  01,37
1996:  MOVFF  00,36
....................              c1=log(rntc);           
199A:  MOVFF  35,7D
199E:  MOVFF  34,7C
19A2:  MOVFF  33,7B
19A6:  MOVFF  32,7A
19AA:  CALL   095A
19AE:  MOVFF  03,3D
19B2:  MOVFF  02,3C
19B6:  MOVFF  01,3B
19BA:  MOVFF  00,3A
....................              c1=pow(c1,3);           
19BE:  MOVFF  3D,71
19C2:  MOVFF  3C,70
19C6:  MOVFF  3B,6F
19CA:  MOVFF  3A,6E
19CE:  CLRF   x75
19D0:  CLRF   x74
19D2:  MOVLW  40
19D4:  MOVWF  x73
19D6:  MOVLW  80
19D8:  MOVWF  x72
19DA:  BRA    1562
19DC:  MOVFF  03,3D
19E0:  MOVFF  02,3C
19E4:  MOVFF  01,3B
19E8:  MOVFF  00,3A
....................              c1=c1*c;                
19EC:  MOVFF  3D,9D
19F0:  MOVFF  3C,9C
19F4:  MOVFF  3B,9B
19F8:  MOVFF  3A,9A
19FC:  MOVFF  52,A1
1A00:  MOVFF  51,A0
1A04:  MOVFF  50,9F
1A08:  MOVFF  4F,9E
1A0C:  CALL   03E6
1A10:  MOVFF  03,3D
1A14:  MOVFF  02,3C
1A18:  MOVFF  01,3B
1A1C:  MOVFF  00,3A
....................              temp=a+b1+c1;           
1A20:  BCF    FD8.1
1A22:  MOVFF  4A,A1
1A26:  MOVFF  49,A0
1A2A:  MOVFF  48,9F
1A2E:  MOVFF  47,9E
1A32:  MOVFF  39,A5
1A36:  MOVFF  38,A4
1A3A:  MOVFF  37,A3
1A3E:  MOVFF  36,A2
1A42:  CALL   0632
1A46:  MOVFF  03,71
1A4A:  MOVFF  02,70
1A4E:  MOVFF  01,6F
1A52:  MOVFF  00,6E
1A56:  BCF    FD8.1
1A58:  MOVFF  03,A1
1A5C:  MOVFF  02,A0
1A60:  MOVFF  01,9F
1A64:  MOVFF  00,9E
1A68:  MOVFF  3D,A5
1A6C:  MOVFF  3C,A4
1A70:  MOVFF  3B,A3
1A74:  MOVFF  3A,A2
1A78:  CALL   0632
1A7C:  MOVFF  03,41
1A80:  MOVFF  02,40
1A84:  MOVFF  01,3F
1A88:  MOVFF  00,3E
....................              temp=1/temp;            
1A8C:  CLRF   x96
1A8E:  CLRF   x95
1A90:  CLRF   x94
1A92:  MOVLW  7F
1A94:  MOVWF  x93
1A96:  MOVFF  41,9A
1A9A:  MOVFF  40,99
1A9E:  MOVFF  3F,98
1AA2:  MOVFF  3E,97
1AA6:  CALL   04D8
1AAA:  MOVFF  03,41
1AAE:  MOVFF  02,40
1AB2:  MOVFF  01,3F
1AB6:  MOVFF  00,3E
....................              temp=temp-273.15; 
1ABA:  BSF    FD8.1
1ABC:  MOVFF  41,A1
1AC0:  MOVFF  40,A0
1AC4:  MOVFF  3F,9F
1AC8:  MOVFF  3E,9E
1ACC:  MOVLW  33
1ACE:  MOVWF  xA5
1AD0:  MOVLW  93
1AD2:  MOVWF  xA4
1AD4:  MOVLW  08
1AD6:  MOVWF  xA3
1AD8:  MOVLW  87
1ADA:  MOVWF  xA2
1ADC:  CALL   0632
1AE0:  MOVFF  03,41
1AE4:  MOVFF  02,40
1AE8:  MOVFF  01,3F
1AEC:  MOVFF  00,3E
....................              return temp; 
1AF0:  MOVFF  3E,00
1AF4:  MOVFF  3F,01
1AF8:  MOVFF  40,02
1AFC:  MOVFF  41,03
1B00:  GOTO   27F0 (RETURN)
....................       // Fim do calculo de equação de  Steinhart & Hart 
....................       } 
....................     
....................     
....................  
....................  
....................  
.................... void mexeovos () {  
....................    limpa_lcd(); 
*
1C9E:  CALL   032C
....................    comando_lcd(0x83); //  posiciona o cursor no endereço 0x83 
1CA2:  MOVLW  83
1CA4:  MOVWF  x6F
1CA6:  CALL   02EA
....................    printf(escreve_lcd,"MEXENDO" ); 
1CAA:  MOVLW  B6
1CAC:  MOVWF  FF6
1CAE:  MOVLW  00
1CB0:  MOVWF  FF7
1CB2:  CALL   0390
....................       for(int i=0;  i<50; i++){                       
1CB6:  CLRF   x6E
1CB8:  MOVF   x6E,W
1CBA:  SUBLW  31
1CBC:  BNC   1CE2
....................       PIN_SERV=1; 
1CBE:  BSF    F81.3
....................       delay_us(800); 
1CC0:  MOVLW  04
1CC2:  MOVWF  x6F
1CC4:  MOVLW  C7
1CC6:  MOVWF  x70
1CC8:  RCALL  1C84
1CCA:  DECFSZ x6F,F
1CCC:  BRA    1CC4
....................       PIN_SERV=0; 
1CCE:  BCF    F81.3
....................       delay_us(19200); 
1CD0:  MOVLW  13
1CD2:  MOVWF  x70
1CD4:  CALL   0306
1CD8:  MOVLW  C8
1CDA:  MOVWF  x70
1CDC:  RCALL  1C84
1CDE:  INCF   x6E,F
1CE0:  BRA    1CB8
....................       } 
....................       delay_ms(2000); 
1CE2:  MOVLW  08
1CE4:  MOVWF  x6F
1CE6:  MOVLW  FA
1CE8:  MOVWF  x70
1CEA:  CALL   0306
1CEE:  DECFSZ x6F,F
1CF0:  BRA    1CE6
....................       for(i=0;  i<50; i++){ 
1CF2:  CLRF   x6E
1CF4:  MOVF   x6E,W
1CF6:  SUBLW  31
1CF8:  BNC   1D2E
....................       PIN_SERV=1; 
1CFA:  BSF    F81.3
....................       delay_us(1500); 
1CFC:  MOVLW  01
1CFE:  MOVWF  x70
1D00:  CALL   0306
1D04:  MOVLW  02
1D06:  MOVWF  x6F
1D08:  MOVLW  F9
1D0A:  MOVWF  x70
1D0C:  RCALL  1C84
1D0E:  DECFSZ x6F,F
1D10:  BRA    1D08
....................       PIN_SERV=0; 
1D12:  BCF    F81.3
....................       delay_us(18500); 
1D14:  MOVLW  12
1D16:  MOVWF  x70
1D18:  CALL   0306
1D1C:  MOVLW  02
1D1E:  MOVWF  x6F
1D20:  MOVLW  F9
1D22:  MOVWF  x70
1D24:  RCALL  1C84
1D26:  DECFSZ x6F,F
1D28:  BRA    1D20
1D2A:  INCF   x6E,F
1D2C:  BRA    1CF4
....................       } 
....................       delay_ms(2000); 
1D2E:  MOVLW  08
1D30:  MOVWF  x6F
1D32:  MOVLW  FA
1D34:  MOVWF  x70
1D36:  CALL   0306
1D3A:  DECFSZ x6F,F
1D3C:  BRA    1D32
1D3E:  GOTO   2812 (RETURN)
....................     
.................... } 
....................  
....................  
....................  
.................... // Função Para conversao do valor obtido na ADC, para o fundo de escala trabalhando para a temperatura 0->50  
.................... void conversao_temp (){   
....................        set_adc_channel(2); //  escolhe o pino analogico para ler   
*
1FB2:  MOVLW  08
1FB4:  MOVWF  01
1FB6:  MOVF   FC2,W
1FB8:  ANDLW  C3
1FBA:  IORWF  01,W
1FBC:  MOVWF  FC2
....................        delay_us(10); // delay para começar a conversão 
1FBE:  MOVLW  10
1FC0:  MOVWF  00
1FC2:  DECFSZ 00,F
1FC4:  BRA    1FC2
1FC6:  NOP   
....................        read_adc(ADC_START_ONLY ); 
1FC8:  BSF    FC2.1
....................       while(!adc_done()){ 
1FCA:  BTFSS  FC2.1
1FCC:  BRA    1FD0
1FCE:  BRA    1FCA
....................       } 
....................       valor_AD = read_adc(ADC_READ_ONLY ); // le o valor na porta analogica 
1FD0:  BTFSC  FC2.1
1FD2:  BRA    1FD0
1FD4:  MOVFF  FC3,5A
1FD8:  MOVFF  FC4,5B
....................      
....................       value1= (float)valor_AD; // passa o valor de 0 a 1023 para float; atribiu este a variavel auxiliar value1 
1FDC:  MOVFF  5B,9F
1FE0:  MOVFF  5A,9E
1FE4:  CALL   03B0
1FE8:  MOVFF  03,65
1FEC:  MOVFF  02,64
1FF0:  MOVFF  01,63
1FF4:  MOVFF  00,62
....................       value1=value1*0.5/10.23; // Faz o ajuste de escala 0°->0 e 50°->1023; o valor 0.5 é o resoluçao 
1FF8:  MOVFF  65,9D
1FFC:  MOVFF  64,9C
2000:  MOVFF  63,9B
2004:  MOVFF  62,9A
2008:  CLRF   xA1
200A:  CLRF   xA0
200C:  CLRF   x9F
200E:  MOVLW  7E
2010:  MOVWF  x9E
2012:  CALL   03E6
2016:  MOVFF  03,71
201A:  MOVFF  02,70
201E:  MOVFF  01,6F
2022:  MOVFF  00,6E
2026:  MOVFF  03,96
202A:  MOVFF  02,95
202E:  MOVFF  01,94
2032:  MOVFF  00,93
2036:  MOVLW  14
2038:  MOVWF  x9A
203A:  MOVLW  AE
203C:  MOVWF  x99
203E:  MOVLW  23
2040:  MOVWF  x98
2042:  MOVLW  82
2044:  MOVWF  x97
2046:  CALL   04D8
204A:  MOVFF  03,65
204E:  MOVFF  02,64
2052:  MOVFF  01,63
2056:  MOVFF  00,62
....................        
....................       value1 = (float)((int)((value1 + 0.4f) * 2.0f)) * 0.5f; 
205A:  BCF    FD8.1
205C:  MOVFF  65,A1
2060:  MOVFF  64,A0
2064:  MOVFF  63,9F
2068:  MOVFF  62,9E
206C:  MOVLW  CD
206E:  MOVWF  xA5
2070:  MOVLW  CC
2072:  MOVWF  xA4
2074:  MOVLW  4C
2076:  MOVWF  xA3
2078:  MOVLW  7D
207A:  MOVWF  xA2
207C:  CALL   0632
2080:  MOVFF  03,71
2084:  MOVFF  02,70
2088:  MOVFF  01,6F
208C:  MOVFF  00,6E
2090:  MOVFF  03,9D
2094:  MOVFF  02,9C
2098:  MOVFF  01,9B
209C:  MOVFF  00,9A
20A0:  CLRF   xA1
20A2:  CLRF   xA0
20A4:  CLRF   x9F
20A6:  MOVLW  80
20A8:  MOVWF  x9E
20AA:  CALL   03E6
20AE:  MOVFF  03,9D
20B2:  MOVFF  02,9C
20B6:  MOVFF  01,9B
20BA:  MOVFF  00,9A
20BE:  CALL   0C9A
20C2:  CLRF   x9F
20C4:  MOVFF  01,9E
20C8:  CALL   03B0
20CC:  MOVFF  03,71
20D0:  MOVFF  02,70
20D4:  MOVFF  01,6F
20D8:  MOVFF  00,6E
20DC:  MOVFF  03,9D
20E0:  MOVFF  02,9C
20E4:  MOVFF  01,9B
20E8:  MOVFF  00,9A
20EC:  CLRF   xA1
20EE:  CLRF   xA0
20F0:  CLRF   x9F
20F2:  MOVLW  7E
20F4:  MOVWF  x9E
20F6:  CALL   03E6
20FA:  MOVFF  03,65
20FE:  MOVFF  02,64
2102:  MOVFF  01,63
2106:  MOVFF  00,62
210A:  GOTO   22B4 (RETURN)
.................... } 
....................  
.................... // Função Para conversao do valor obtido na ADC, para o fundo de escala trabalhando para a umidade 0->100  
.................... void conversao_umi (){ 
....................  
....................       set_adc_channel(2); //  escolhe o pino analogico para ler   
210E:  MOVLW  08
2110:  MOVWF  01
2112:  MOVF   FC2,W
2114:  ANDLW  C3
2116:  IORWF  01,W
2118:  MOVWF  FC2
....................       delay_us(10); // delay para começar a conversão 
211A:  MOVLW  10
211C:  MOVWF  00
211E:  DECFSZ 00,F
2120:  BRA    211E
2122:  NOP   
....................       read_adc(ADC_START_ONLY ); 
2124:  BSF    FC2.1
....................       while(!adc_done()){ 
2126:  BTFSS  FC2.1
2128:  BRA    212C
212A:  BRA    2126
....................       } 
....................      valor_AD= read_adc(ADC_READ_ONLY ); // le o valor na porta analogica 
212C:  BTFSC  FC2.1
212E:  BRA    212C
2130:  MOVFF  FC3,5A
2134:  MOVFF  FC4,5B
....................       
....................       value1= (float)valor_AD; // passa o valor de 0 a 1023 para float; atribiu este a variavel auxiliar value1 
2138:  MOVFF  5B,9F
213C:  MOVFF  5A,9E
2140:  CALL   03B0
2144:  MOVFF  03,65
2148:  MOVFF  02,64
214C:  MOVFF  01,63
2150:  MOVFF  00,62
....................       value1= value1*10/102.3;// Faz o ajuste de escala 0->0 e 100->1023; o valor 10 é o resoluçao 
2154:  MOVFF  65,9D
2158:  MOVFF  64,9C
215C:  MOVFF  63,9B
2160:  MOVFF  62,9A
2164:  CLRF   xA1
2166:  CLRF   xA0
2168:  MOVLW  20
216A:  MOVWF  x9F
216C:  MOVLW  82
216E:  MOVWF  x9E
2170:  CALL   03E6
2174:  MOVFF  03,71
2178:  MOVFF  02,70
217C:  MOVFF  01,6F
2180:  MOVFF  00,6E
2184:  MOVFF  03,96
2188:  MOVFF  02,95
218C:  MOVFF  01,94
2190:  MOVFF  00,93
2194:  MOVLW  9A
2196:  MOVWF  x9A
2198:  MOVLW  99
219A:  MOVWF  x99
219C:  MOVLW  4C
219E:  MOVWF  x98
21A0:  MOVLW  85
21A2:  MOVWF  x97
21A4:  CALL   04D8
21A8:  MOVFF  03,65
21AC:  MOVFF  02,64
21B0:  MOVFF  01,63
21B4:  MOVFF  00,62
....................       value1 = (float)((int)((value1 + 0.4f) * 2.0f)) * 0.5f; 
21B8:  BCF    FD8.1
21BA:  MOVFF  65,A1
21BE:  MOVFF  64,A0
21C2:  MOVFF  63,9F
21C6:  MOVFF  62,9E
21CA:  MOVLW  CD
21CC:  MOVWF  xA5
21CE:  MOVLW  CC
21D0:  MOVWF  xA4
21D2:  MOVLW  4C
21D4:  MOVWF  xA3
21D6:  MOVLW  7D
21D8:  MOVWF  xA2
21DA:  CALL   0632
21DE:  MOVFF  03,71
21E2:  MOVFF  02,70
21E6:  MOVFF  01,6F
21EA:  MOVFF  00,6E
21EE:  MOVFF  03,9D
21F2:  MOVFF  02,9C
21F6:  MOVFF  01,9B
21FA:  MOVFF  00,9A
21FE:  CLRF   xA1
2200:  CLRF   xA0
2202:  CLRF   x9F
2204:  MOVLW  80
2206:  MOVWF  x9E
2208:  CALL   03E6
220C:  MOVFF  03,9D
2210:  MOVFF  02,9C
2214:  MOVFF  01,9B
2218:  MOVFF  00,9A
221C:  CALL   0C9A
2220:  CLRF   x9F
2222:  MOVFF  01,9E
2226:  CALL   03B0
222A:  MOVFF  03,71
222E:  MOVFF  02,70
2232:  MOVFF  01,6F
2236:  MOVFF  00,6E
223A:  MOVFF  03,9D
223E:  MOVFF  02,9C
2242:  MOVFF  01,9B
2246:  MOVFF  00,9A
224A:  CLRF   xA1
224C:  CLRF   xA0
224E:  CLRF   x9F
2250:  MOVLW  7E
2252:  MOVWF  x9E
2254:  CALL   03E6
2258:  MOVFF  03,65
225C:  MOVFF  02,64
2260:  MOVFF  01,63
2264:  MOVFF  00,62
2268:  GOTO   2332 (RETURN)
.................... } 
....................  
.................... // Funçao para a configuraçao dos parametros de temperatura e umidade da incubadora 
.................... void configuracao () { 
....................                   
....................                      cont_config++;// toda vez que o botao é pressionado o contador é incrementado 
226C:  INCF   x61,F
....................                      limpa_lcd (); // limpa o lcd 
226E:  CALL   032C
....................                     if(cont_config==7){ 
2272:  MOVF   x61,W
2274:  SUBLW  07
2276:  BNZ   227A
....................                        cont_config=0; 
2278:  CLRF   x61
....................                     } 
....................                     if(cont_config==1){ 
227A:  DECFSZ x61,W
227C:  BRA    22AE
....................                         printf(escreve_lcd, "CONFIGURACAO"); 
227E:  MOVLW  BE
2280:  MOVWF  FF6
2282:  MOVLW  00
2284:  MOVWF  FF7
2286:  CALL   0390
....................                         comando_lcd(0xC0); 
228A:  MOVLW  C0
228C:  MOVWF  x6F
228E:  CALL   02EA
....................                         printf(escreve_lcd, "INCUBADORA"); 
2292:  MOVLW  CC
2294:  MOVWF  FF6
2296:  MOVLW  00
2298:  MOVWF  FF7
229A:  CALL   0390
....................                          delay_ms (3000); 
229E:  MOVLW  0C
22A0:  MOVWF  x6E
22A2:  MOVLW  FA
22A4:  MOVWF  x70
22A6:  CALL   0306
22AA:  DECFSZ x6E,F
22AC:  BRA    22A2
....................                      
....................                     } 
....................                    while(cont_config==1){ // neste primeiro laço a temperatura max. deverá ser definida por meio do poteciometro 
22AE:  DECFSZ x61,W
22B0:  BRA    25CA
....................                          
....................                         
....................                         
....................                         conversao_temp ();// chama a funçao para a conversao  
22B2:  BRA    1FB2
....................                         printf(escreve_lcd, "CONFIGURACAO"); 
22B4:  MOVLW  D8
22B6:  MOVWF  FF6
22B8:  MOVLW  00
22BA:  MOVWF  FF7
22BC:  CALL   0390
....................                         comando_lcd(0xC0);// posiciona o cursor no endereço 83h 
22C0:  MOVLW  C0
22C2:  MOVWF  x6F
22C4:  CALL   02EA
....................                   
....................                         printf(escreve_lcd, "SET TEMP: %.1f       ", value1);  // escrever no lcd os valores de temperatura correpontedes a variaçao do potenciometro 
22C8:  MOVLW  E6
22CA:  MOVWF  FF6
22CC:  MOVLW  00
22CE:  MOVWF  FF7
22D0:  MOVLW  0A
22D2:  MOVWF  x6E
22D4:  RCALL  1D42
22D6:  MOVLW  89
22D8:  MOVWF  FE9
22DA:  MOVFF  65,71
22DE:  MOVFF  64,70
22E2:  MOVFF  63,6F
22E6:  MOVFF  62,6E
22EA:  MOVLW  01
22EC:  MOVWF  x72
22EE:  RCALL  1E30
22F0:  MOVLW  F4
22F2:  MOVWF  FF6
22F4:  MOVLW  00
22F6:  MOVWF  FF7
22F8:  MOVLW  07
22FA:  MOVWF  x6E
22FC:  RCALL  1D42
....................                         delay_ms (400); //  delay necessario para que o estado da porta onde o botao está ligado volte ao estado incial apos o aperto. 
22FE:  MOVLW  02
2300:  MOVWF  x6E
2302:  MOVLW  C8
2304:  MOVWF  x70
2306:  CALL   0306
230A:  DECFSZ x6E,F
230C:  BRA    2302
....................                       
....................                        
....................                          
....................                         if(config_Bot==0){ // ao pressionar o botão por um tempo superior a 500ms Ffinaliza o primeiro laço e entra no segundo laço. 
230E:  BTFSC  F81.4
2310:  BRA    232A
....................                             limpa_lcd (); 
2312:  CALL   032C
....................                             set_temp = value1; // ATUALIZAÇAO DO VALOR DA VARIAVEL DE REFERENCIA APOS A ESCOLHA DO VALOR ATRAVÉS DO POTENCIOMETRO 
2316:  MOVFF  65,69
231A:  MOVFF  64,68
231E:  MOVFF  63,67
2322:  MOVFF  62,66
....................                              cont_config=2; 
2326:  MOVLW  02
2328:  MOVWF  x61
....................                         } 
....................                    
....................                         while(cont_config==2){ // Neste segundo laço será defenido o valor da temperatura min. e imprimmi no lcd 
232A:  MOVF   x61,W
232C:  SUBLW  02
232E:  BNZ   23AA
....................                            conversao_umi ();  
2330:  BRA    210E
....................                           printf(escreve_lcd, "CONFIGURACAO"); 
2332:  MOVLW  FC
2334:  MOVWF  FF6
2336:  MOVLW  00
2338:  MOVWF  FF7
233A:  CALL   0390
....................                            comando_lcd(0xC0); 
233E:  MOVLW  C0
2340:  MOVWF  x6F
2342:  CALL   02EA
....................                            printf(escreve_lcd, "SET UMI: %.1f      ", value1); 
2346:  MOVLW  0A
2348:  MOVWF  FF6
234A:  MOVLW  01
234C:  MOVWF  FF7
234E:  MOVLW  09
2350:  MOVWF  x6E
2352:  RCALL  1D42
2354:  MOVLW  89
2356:  MOVWF  FE9
2358:  MOVFF  65,71
235C:  MOVFF  64,70
2360:  MOVFF  63,6F
2364:  MOVFF  62,6E
2368:  MOVLW  01
236A:  MOVWF  x72
236C:  RCALL  1E30
236E:  MOVLW  17
2370:  MOVWF  FF6
2372:  MOVLW  01
2374:  MOVWF  FF7
2376:  MOVLW  06
2378:  MOVWF  x6E
237A:  RCALL  1D42
....................                            delay_ms (400); 
237C:  MOVLW  02
237E:  MOVWF  x6E
2380:  MOVLW  C8
2382:  MOVWF  x70
2384:  CALL   0306
2388:  DECFSZ x6E,F
238A:  BRA    2380
....................                              
....................                             
....................                        
....................                            if(config_Bot==0){ 
238C:  BTFSC  F81.4
238E:  BRA    23A8
....................                                limpa_lcd (); 
2390:  CALL   032C
....................                                set_umi = value1; // ATUALIZAÇAO DO VALOR DA VARIAVEL DE REFERENCIA APOS A ESCOLHA DO VALOR ATRAVÉS DO POTENCIOMETRO 
2394:  MOVFF  65,6D
2398:  MOVFF  64,6C
239C:  MOVFF  63,6B
23A0:  MOVFF  62,6A
....................                                cont_config=4; 
23A4:  MOVLW  04
23A6:  MOVWF  x61
....................                            } 
23A8:  BRA    232A
....................                         }//fim do 2 laço 
....................                              
....................                               while(cont_config==4){  
23AA:  MOVF   x61,W
23AC:  SUBLW  04
23AE:  BTFSS  FD8.2
23B0:  BRA    25C8
....................                                  cont_aux++; 
23B2:  INCF   58,F
....................                              if (cont_aux==1){ 
23B4:  DECFSZ 58,W
23B6:  BRA    2486
....................                               limpa_lcd(); 
23B8:  CALL   032C
....................                               comando_lcd(0x80); 
23BC:  MOVLW  80
23BE:  MOVWF  x6F
23C0:  CALL   02EA
....................                               printf(escreve_lcd, "FIM DA"); 
23C4:  MOVLW  1E
23C6:  MOVWF  FF6
23C8:  MOVLW  01
23CA:  MOVWF  FF7
23CC:  CALL   0390
....................                               comando_lcd(0xC0); 
23D0:  MOVLW  C0
23D2:  MOVWF  x6F
23D4:  CALL   02EA
....................                               printf(escreve_lcd, "CONFIGURACAO"); 
23D8:  MOVLW  26
23DA:  MOVWF  FF6
23DC:  MOVLW  01
23DE:  MOVWF  FF7
23E0:  CALL   0390
....................                               delay_ms (1000); 
23E4:  MOVLW  04
23E6:  MOVWF  x6E
23E8:  MOVLW  FA
23EA:  MOVWF  x70
23EC:  CALL   0306
23F0:  DECFSZ x6E,F
23F2:  BRA    23E8
....................                                
....................                               limpa_lcd(); 
23F4:  CALL   032C
....................                               comando_lcd(0x80); 
23F8:  MOVLW  80
23FA:  MOVWF  x6F
23FC:  CALL   02EA
....................                               printf(escreve_lcd, "SET TEMP:  %.1f        ", set_temp); 
2400:  MOVLW  34
2402:  MOVWF  FF6
2404:  MOVLW  01
2406:  MOVWF  FF7
2408:  MOVLW  0B
240A:  MOVWF  x6E
240C:  RCALL  1D42
240E:  MOVLW  89
2410:  MOVWF  FE9
2412:  MOVFF  69,71
2416:  MOVFF  68,70
241A:  MOVFF  67,6F
241E:  MOVFF  66,6E
2422:  MOVLW  01
2424:  MOVWF  x72
2426:  RCALL  1E30
2428:  MOVLW  43
242A:  MOVWF  FF6
242C:  MOVLW  01
242E:  MOVWF  FF7
2430:  MOVLW  08
2432:  MOVWF  x6E
2434:  RCALL  1D42
....................                               comando_lcd(0xC0); 
2436:  MOVLW  C0
2438:  MOVWF  x6F
243A:  CALL   02EA
....................                               printf(escreve_lcd, "SET UMI:   %.1f       ", set_umi); 
243E:  MOVLW  4C
2440:  MOVWF  FF6
2442:  MOVLW  01
2444:  MOVWF  FF7
2446:  MOVLW  0B
2448:  MOVWF  x6E
244A:  RCALL  1D42
244C:  MOVLW  89
244E:  MOVWF  FE9
2450:  MOVFF  6D,71
2454:  MOVFF  6C,70
2458:  MOVFF  6B,6F
245C:  MOVFF  6A,6E
2460:  MOVLW  01
2462:  MOVWF  x72
2464:  RCALL  1E30
2466:  MOVLW  5B
2468:  MOVWF  FF6
246A:  MOVLW  01
246C:  MOVWF  FF7
246E:  MOVLW  07
2470:  MOVWF  x6E
2472:  RCALL  1D42
....................                               delay_ms (3000); 
2474:  MOVLW  0C
2476:  MOVWF  x6E
2478:  MOVLW  FA
247A:  MOVWF  x70
247C:  CALL   0306
2480:  DECFSZ x6E,F
2482:  BRA    2478
....................                               cont_aux++; 
2484:  INCF   58,F
....................                           
....................                              } 
....................                                
....................                             
....................                                
....................                          limpa_lcd(); 
2486:  CALL   032C
....................                          comando_lcd(0x80); 
248A:  MOVLW  80
248C:  MOVWF  x6F
248E:  CALL   02EA
....................                          printf(escreve_lcd, "P/VOLTAR A "); 
2492:  MOVLW  64
2494:  MOVWF  FF6
2496:  MOVLW  01
2498:  MOVWF  FF7
249A:  CALL   0390
....................                          comando_lcd(0xC0); 
249E:  MOVLW  C0
24A0:  MOVWF  x6F
24A2:  CALL   02EA
....................                          printf(escreve_lcd, "CONFIGURACAO"); 
24A6:  MOVLW  70
24A8:  MOVWF  FF6
24AA:  MOVLW  01
24AC:  MOVWF  FF7
24AE:  CALL   0390
....................                          delay_ms (1000); 
24B2:  MOVLW  04
24B4:  MOVWF  x6E
24B6:  MOVLW  FA
24B8:  MOVWF  x70
24BA:  CALL   0306
24BE:  DECFSZ x6E,F
24C0:  BRA    24B6
....................                          limpa_lcd(); 
24C2:  CALL   032C
....................                          comando_lcd(0x80); 
24C6:  MOVLW  80
24C8:  MOVWF  x6F
24CA:  CALL   02EA
....................                          printf(escreve_lcd, "PRESSIONE O "); 
24CE:  MOVLW  7E
24D0:  MOVWF  FF6
24D2:  MOVLW  01
24D4:  MOVWF  FF7
24D6:  CALL   0390
....................                          comando_lcd(0xC0); 
24DA:  MOVLW  C0
24DC:  MOVWF  x6F
24DE:  CALL   02EA
....................                          printf(escreve_lcd, "BOT. CONFIGURACAO"); 
24E2:  MOVLW  8C
24E4:  MOVWF  FF6
24E6:  MOVLW  01
24E8:  MOVWF  FF7
24EA:  CALL   0390
....................                          delay_ms (1000); 
24EE:  MOVLW  04
24F0:  MOVWF  x6E
24F2:  MOVLW  FA
24F4:  MOVWF  x70
24F6:  CALL   0306
24FA:  DECFSZ x6E,F
24FC:  BRA    24F2
....................                          limpa_lcd(); 
24FE:  CALL   032C
....................                          comando_lcd(0x80); 
2502:  MOVLW  80
2504:  MOVWF  x6F
2506:  CALL   02EA
....................                          printf(escreve_lcd, "OU PRESSIONE"); 
250A:  MOVLW  9E
250C:  MOVWF  FF6
250E:  MOVLW  01
2510:  MOVWF  FF7
2512:  CALL   0390
....................                          comando_lcd(0xC0); 
2516:  MOVLW  C0
2518:  MOVWF  x6F
251A:  CALL   02EA
....................                          printf(escreve_lcd, "BOTAO INICIAR"); 
251E:  MOVLW  AC
2520:  MOVWF  FF6
2522:  MOVLW  01
2524:  MOVWF  FF7
2526:  CALL   0390
....................                          delay_ms (1000); 
252A:  MOVLW  04
252C:  MOVWF  x6E
252E:  MOVLW  FA
2530:  MOVWF  x70
2532:  CALL   0306
2536:  DECFSZ x6E,F
2538:  BRA    252E
....................                          limpa_lcd(); 
253A:  CALL   032C
....................                                
....................                               if(config_Bot==0){ 
253E:  BTFSC  F81.4
2540:  BRA    257C
....................                               limpa_lcd (); 
2542:  CALL   032C
....................                               cont_config=1; 
2546:  MOVLW  01
2548:  MOVWF  x61
....................                               cont_aux=0; 
254A:  CLRF   58
....................                               printf(escreve_lcd, "CONFIGURACAO"); 
254C:  MOVLW  BA
254E:  MOVWF  FF6
2550:  MOVLW  01
2552:  MOVWF  FF7
2554:  CALL   0390
....................                               comando_lcd(0xC0); 
2558:  MOVLW  C0
255A:  MOVWF  x6F
255C:  CALL   02EA
....................                               printf(escreve_lcd, "INCUBADORA"); 
2560:  MOVLW  C8
2562:  MOVWF  FF6
2564:  MOVLW  01
2566:  MOVWF  FF7
2568:  CALL   0390
....................                               delay_ms (3000); 
256C:  MOVLW  0C
256E:  MOVWF  x6E
2570:  MOVLW  FA
2572:  MOVWF  x70
2574:  CALL   0306
2578:  DECFSZ x6E,F
257A:  BRA    2570
....................                                 
....................                            } 
....................                              if(BOT_INI==0){ 
257C:  BTFSC  F81.1
257E:  BRA    25C6
....................                                limpa_lcd (); 
2580:  CALL   032C
....................                                comando_lcd(0x80); 
2584:  MOVLW  80
2586:  MOVWF  x6F
2588:  CALL   02EA
....................                                printf(escreve_lcd, "INCIANDO A "); 
258C:  MOVLW  D4
258E:  MOVWF  FF6
2590:  MOVLW  01
2592:  MOVWF  FF7
2594:  CALL   0390
....................                                comando_lcd(0xC0); 
2598:  MOVLW  C0
259A:  MOVWF  x6F
259C:  CALL   02EA
....................                                printf(escreve_lcd, "INCUBADORA"); 
25A0:  MOVLW  E0
25A2:  MOVWF  FF6
25A4:  MOVLW  01
25A6:  MOVWF  FF7
25A8:  CALL   0390
....................                                delay_ms (4000); 
25AC:  MOVLW  10
25AE:  MOVWF  x6E
25B0:  MOVLW  FA
25B2:  MOVWF  x70
25B4:  CALL   0306
25B8:  DECFSZ x6E,F
25BA:  BRA    25B0
....................                                cont_aux=0; 
25BC:  CLRF   58
....................                                cont_config=0; 
25BE:  CLRF   x61
....................                                UNLOCK=1; 
25C0:  BSF    x60.2
....................                                cont=1; 
25C2:  MOVLW  01
25C4:  MOVWF  53
....................                             
....................                            } 
25C6:  BRA    23AA
....................                                
....................                          }// fim do 3 laço 
25C8:  BRA    22AE
....................                           
....................                           
....................                         
....................  } // fim do 1 laço 
25CA:  GOTO   2A80 (RETURN)
....................  
....................  
.................... } // FIM DA FUNÇÃO CONFIGURAÇAO 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... void main (void){ 
25CE:  CLRF   FF8
25D0:  BCF    FD0.7
25D2:  BSF    07.7
25D4:  CLRF   31
25D6:  CLRF   30
25D8:  CLRF   2F
25DA:  CLRF   2E
25DC:  CLRF   35
25DE:  CLRF   34
25E0:  CLRF   33
25E2:  CLRF   32
25E4:  CLRF   39
25E6:  CLRF   38
25E8:  CLRF   37
25EA:  CLRF   36
25EC:  CLRF   3D
25EE:  CLRF   3C
25F0:  CLRF   3B
25F2:  CLRF   3A
25F4:  CLRF   41
25F6:  CLRF   40
25F8:  CLRF   3F
25FA:  CLRF   3E
25FC:  CLRF   45
25FE:  CLRF   44
2600:  CLRF   43
2602:  CLRF   42
2604:  MOVLW  93
2606:  MOVWF  4A
2608:  MOVLW  26
260A:  MOVWF  49
260C:  MOVLW  14
260E:  MOVWF  48
2610:  MOVLW  75
2612:  MOVWF  47
2614:  MOVLW  0E
2616:  MOVWF  4E
2618:  MOVLW  43
261A:  MOVWF  4D
261C:  MOVLW  75
261E:  MOVWF  4C
2620:  MOVLW  72
2622:  MOVWF  4B
2624:  MOVLW  DC
2626:  MOVWF  52
2628:  MOVLW  54
262A:  MOVWF  51
262C:  MOVLW  3E
262E:  MOVWF  50
2630:  MOVLW  67
2632:  MOVWF  4F
2634:  CLRF   53
2636:  CLRF   55
2638:  CLRF   54
263A:  CLRF   56
263C:  CLRF   57
263E:  CLRF   58
2640:  CLRF   59
2642:  MOVLW  01
2644:  MOVWF  5D
2646:  MOVLW  90
2648:  MOVWF  5C
264A:  MOVLW  01
264C:  MOVWF  5F
264E:  MOVLW  90
2650:  MOVWF  5E
2652:  CLRF   x60
2654:  CLRF   x61
2656:  CLRF   x69
2658:  CLRF   x68
265A:  CLRF   x67
265C:  CLRF   x66
265E:  CLRF   x6D
2660:  CLRF   x6C
2662:  CLRF   x6B
2664:  CLRF   x6A
2666:  MOVF   FC1,W
2668:  ANDLW  C0
266A:  IORLW  0F
266C:  MOVWF  FC1
266E:  MOVLW  07
2670:  MOVWF  FB4
2672:  CLRF   16
2674:  CLRF   17
2676:  MOVLW  52
2678:  MOVWF  1C
267A:  MOVLW  48
267C:  MOVWF  1D
267E:  MOVLW  A0
2680:  MOVWF  1E
2682:  MOVWF  1F
2684:  MOVWF  20
2686:  MOVLW  3D
2688:  MOVWF  21
268A:  MOVLW  A0
268C:  MOVWF  22
268E:  MOVLW  30
2690:  MOVWF  23
2692:  MOVWF  24
2694:  MOVLW  2E
2696:  MOVWF  25
2698:  MOVLW  30
269A:  MOVWF  26
269C:  MOVLW  A0
269E:  MOVWF  27
26A0:  MOVLW  25
26A2:  MOVWF  28
26A4:  CLRF   29
....................  
....................       // configura os tris 
....................       set_tris_a(0b00001111);  
26A6:  MOVLW  0F
26A8:  MOVWF  F92
....................       set_tris_b(0b10010010);   
26AA:  MOVLW  92
26AC:  MOVWF  F93
....................       set_tris_c(0b00000000); 
26AE:  MOVLW  00
26B0:  MOVWF  F94
....................       set_tris_d(0b00000000);   
26B2:  MOVWF  F95
....................       set_tris_e(0b00000100); 
26B4:  MOVLW  04
26B6:  MOVWF  F96
....................        
....................       // inicializa os ports 
....................       porta=0x00;            // limpa porta 
26B8:  CLRF   F80
....................       portb=0x00;            // limpa portb 
26BA:  CLRF   F81
....................       portc=0x00;            // limpa portc 
26BC:  CLRF   F82
....................       portd=0x00;            // limpa portd 
26BE:  CLRF   F83
....................       porte=0x00;            // limpa porte 
26C0:  CLRF   F84
....................        
....................       setup_adc(ADC_CLOCK_DIV_32); //  configura o clock utilizado para o conversor ad e o pior clock ele usa a malha RC é lenta  
26C2:  MOVF   FC0,W
26C4:  ANDLW  C0
26C6:  IORLW  02
26C8:  MOVWF  FC0
26CA:  BSF    FC0.7
26CC:  BSF    FC2.0
....................       setup_adc_ports( AN0_TO_AN2 ); // selecionaos pinos A0 a A2 como pinos de sinais analogicos  
26CE:  MOVF   FC1,W
26D0:  ANDLW  C0
26D2:  IORLW  0C
26D4:  MOVWF  FC1
....................       inicializa_lcd(); // função responsavel por inicializar o modulo lcd 
26D6:  GOTO   033A
....................            
....................            
....................           comando_lcd(0x80); //  posiciona o cursor no endereço 0x83 
26DA:  MOVLW  80
26DC:  MOVWF  x6F
26DE:  CALL   02EA
....................           printf(escreve_lcd,"INCUBADORA"); 
26E2:  MOVLW  EC
26E4:  MOVWF  FF6
26E6:  MOVLW  01
26E8:  MOVWF  FF7
26EA:  CALL   0390
....................           comando_lcd(0xC0); //  posiciona o cursor no endereço 0x83 
26EE:  MOVLW  C0
26F0:  MOVWF  x6F
26F2:  CALL   02EA
....................           printf(escreve_lcd,"DE OVOS"); 
26F6:  MOVLW  F8
26F8:  MOVWF  FF6
26FA:  MOVLW  01
26FC:  MOVWF  FF7
26FE:  CALL   0390
....................           delay_ms(3000); 
2702:  MOVLW  0C
2704:  MOVWF  x6E
2706:  MOVLW  FA
2708:  MOVWF  x70
270A:  CALL   0306
270E:  DECFSZ x6E,F
2710:  BRA    2706
....................           comando_lcd(0x80); //  posiciona o cursor no endereço 0x83 
2712:  MOVLW  80
2714:  MOVWF  x6F
2716:  CALL   02EA
....................           printf(escreve_lcd,"APERTE O BOTAO"); 
271A:  MOVLW  00
271C:  MOVWF  FF6
271E:  MOVLW  02
2720:  MOVWF  FF7
2722:  CALL   0390
....................           comando_lcd(0xC0); //  posiciona o cursor no endereço 0x83 
2726:  MOVLW  C0
2728:  MOVWF  x6F
272A:  CALL   02EA
....................           printf(escreve_lcd,"CONFIGURACAO"); 
272E:  MOVLW  10
2730:  MOVWF  FF6
2732:  MOVLW  02
2734:  MOVWF  FF7
2736:  CALL   0390
....................           delay_ms(3000); 
273A:  MOVLW  0C
273C:  MOVWF  x6E
273E:  MOVLW  FA
2740:  MOVWF  x70
2742:  CALL   0306
2746:  DECFSZ x6E,F
2748:  BRA    273E
....................            
....................             // CONFIGURA?+O DO TIMER0 
....................                setup_timer_0 (RTCC_INTERNAL | RTCC_8_BIT | RTCC_DIV_64); 
274A:  MOVLW  C5
274C:  MOVWF  FD5
....................                set_timer0(131); 
274E:  CLRF   FD7
2750:  MOVLW  83
2752:  MOVWF  FD6
....................                enable_interrupts(GLOBAL);//chave principal das interrup??es 
2754:  MOVLW  C0
2756:  IORWF  FF2,F
....................                enable_interrupts(int_timer0); // interrup??o do TIMER 0 
2758:  BSF    FF2.5
....................              
....................              
....................   while(true){ 
....................    
....................     
....................           
....................           if (cont==1){ // escreve a mensagem apenas uma vez no lcd   
275A:  DECFSZ 53,W
275C:  BRA    278C
....................           limpa_lcd(); 
275E:  CALL   032C
....................           comando_lcd(0x80); //  posiciona o cursor no endereço 0x83 
2762:  MOVLW  80
2764:  MOVWF  x6F
2766:  CALL   02EA
....................           printf(escreve_lcd,"APERTE O BOTAO"); 
276A:  MOVLW  1E
276C:  MOVWF  FF6
276E:  MOVLW  02
2770:  MOVWF  FF7
2772:  CALL   0390
....................           comando_lcd(0xC0); //  posiciona o cursor no endereço 0x83 
2776:  MOVLW  C0
2778:  MOVWF  x6F
277A:  CALL   02EA
....................           printf(escreve_lcd,"INI OU CONFIG"); 
277E:  MOVLW  2E
2780:  MOVWF  FF6
2782:  MOVLW  02
2784:  MOVWF  FF7
2786:  CALL   0390
....................           cont=0; 
278A:  CLRF   53
....................           } 
....................          if( UNLOCK==1){   
278C:  BTFSS  x60.2
278E:  BRA    2A62
....................           if (!BOT_INI){   // o botao do motor 1 foi pressionado? 
2790:  BTFSC  F81.1
2792:  BRA    2A58
....................             if (! (BTN_INI)){ // O botão UP já foi tratato ? 
2794:  BTFSC  x60.1
2796:  BRA    2A56
....................              
....................                // não. 
....................                if (filtro_INI != 0) // Fim do filtro do botão UP ? 
2798:  MOVF   5E,F
279A:  BNZ   27A0
279C:  MOVF   5F,F
279E:  BZ    27AA
....................                   filtro_INI--; // Não, então decrementa o filtro 
27A0:  MOVF   5E,W
27A2:  BTFSC  FD8.2
27A4:  DECF   5F,F
27A6:  DECF   5E,F
27A8:  BRA    2A56
....................                   else {  
....................                        limpa_lcd(); 
27AA:  CALL   032C
....................                                comando_lcd(0x80); //  posiciona o cursor no endereço 0x83 
27AE:  MOVLW  80
27B0:  MOVWF  x6F
27B2:  CALL   02EA
....................                                printf(escreve_lcd,"AJUSTANDO"); 
27B6:  MOVLW  3C
27B8:  MOVWF  FF6
27BA:  MOVLW  02
27BC:  MOVWF  FF7
27BE:  CALL   0390
....................                                
....................                                comando_lcd(0xC0); //  posiciona o cursor no endereço 0x83 
27C2:  MOVLW  C0
27C4:  MOVWF  x6F
27C6:  CALL   02EA
....................                                printf(escreve_lcd,"PARAMENTROS..."); 
27CA:  MOVLW  46
27CC:  MOVWF  FF6
27CE:  MOVLW  02
27D0:  MOVWF  FF7
27D2:  CALL   0390
....................                                delay_ms(2000); 
27D6:  MOVLW  08
27D8:  MOVWF  x6E
27DA:  MOVLW  FA
27DC:  MOVWF  x70
27DE:  CALL   0306
27E2:  DECFSZ x6E,F
27E4:  BRA    27DA
....................                                cont_rotina++; 
27E6:  INCF   59,F
....................                         
....................                                while (cont_rotina==1 ){ 
27E8:  DECFSZ 59,W
27EA:  BRA    2A54
....................                                       
....................                                       
....................                                      temperatura = ntc(); //  le o valor  de temperatura em graus celsius que a função do ntc retorna 
27EC:  GOTO   1838
27F0:  MOVFF  03,45
27F4:  MOVFF  02,44
27F8:  MOVFF  01,43
27FC:  MOVFF  00,42
....................                                      umidade = dht11(); 
2800:  GOTO   1C14
2804:  MOVFF  01,46
....................                                        if(horas == 3){ //  HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH 
2808:  MOVF   56,W
280A:  SUBLW  03
280C:  BNZ   2814
....................                                        mexeovos(); 
280E:  GOTO   1C9E
....................                                        horas=0; 
2812:  CLRF   56
....................                                        } 
....................     
....................                                     if(cont_ini==0 ){ // aqui fica a rotina princiapal mostranso os valorres de temperatura e umidade 
2814:  MOVF   57,F
2816:  BNZ   2860
....................                                      comando_lcd(0x80); //  posiciona o cursor no endereço 0x83 
2818:  MOVLW  80
281A:  MOVWF  x6F
281C:  CALL   02EA
....................                                      
....................                                      printf(escreve_lcd,"UMIDADE:00000 "); 
2820:  MOVLW  56
2822:  MOVWF  FF6
2824:  MOVLW  02
2826:  MOVWF  FF7
2828:  CALL   0390
....................                                    
....................                                      comando_lcd(0xC0); //  posiciona o cursor no endereço 0x83 
282C:  MOVLW  C0
282E:  MOVWF  x6F
2830:  CALL   02EA
....................                                      printf(escreve_lcd,"TEMP. %f",temperatura); 
2834:  MOVLW  66
2836:  MOVWF  FF6
2838:  MOVLW  02
283A:  MOVWF  FF7
283C:  MOVLW  06
283E:  MOVWF  x6E
2840:  CALL   1D42
2844:  MOVLW  89
2846:  MOVWF  FE9
2848:  MOVFF  45,71
284C:  MOVFF  44,70
2850:  MOVFF  43,6F
2854:  MOVFF  42,6E
2858:  MOVLW  02
285A:  MOVWF  x72
285C:  CALL   1E30
....................                                     } 
....................                                      if(cont_ini==1 ){ 
2860:  DECFSZ 57,W
2862:  BRA    289C
....................                                      comando_lcd(0x80); 
2864:  MOVLW  80
2866:  MOVWF  x6F
2868:  CALL   02EA
....................                                      printf(escreve_lcd,"DESEJA PARAR A "); 
286C:  MOVLW  70
286E:  MOVWF  FF6
2870:  MOVLW  02
2872:  MOVWF  FF7
2874:  CALL   0390
....................                                      comando_lcd(0xC0); //  posiciona o cursor no endereço 0x83 
2878:  MOVLW  C0
287A:  MOVWF  x6F
287C:  CALL   02EA
....................                                      printf(escreve_lcd,"INCUBACAO?"); 
2880:  MOVLW  80
2882:  MOVWF  FF6
2884:  MOVLW  02
2886:  MOVWF  FF7
2888:  CALL   0390
....................                                      delay_ms(500); 
288C:  MOVLW  02
288E:  MOVWF  x6E
2890:  MOVLW  FA
2892:  MOVWF  x70
2894:  CALL   0306
2898:  DECFSZ x6E,F
289A:  BRA    2890
....................                                       
....................                                      
....................                                      } 
....................                                      // implementação da rotina de controle de  temperatura  
....................                                     if(temperatura<=set_temp){   //  verifica se da temperatura de menor que 38 graus e faz  a rotina  
289C:  MOVFF  45,9D
28A0:  MOVFF  44,9C
28A4:  MOVFF  43,9B
28A8:  MOVFF  42,9A
28AC:  MOVFF  69,A1
28B0:  MOVFF  68,A0
28B4:  MOVFF  67,9F
28B8:  MOVFF  66,9E
28BC:  CALL   089C
28C0:  BC    28C4
28C2:  BNZ   28C8
....................                                       PIN_COOLER =0 ; 
28C4:  BCF    F82.0
....................                                       RELE_LAMP = 1 ; 
28C6:  BSF    F81.2
....................                                      } 
....................                                      if(temperatura>set_temp){ 
28C8:  MOVFF  69,9D
28CC:  MOVFF  68,9C
28D0:  MOVFF  67,9B
28D4:  MOVFF  66,9A
28D8:  MOVFF  45,A1
28DC:  MOVFF  44,A0
28E0:  MOVFF  43,9F
28E4:  MOVFF  42,9E
28E8:  CALL   089C
28EC:  BNC   28F2
....................                                      PIN_COOLER =1 ; 
28EE:  BSF    F82.0
....................                                      RELE_LAMP = 0 ;  
28F0:  BCF    F81.2
....................                                      } 
....................                                      delay_ms(500); 
28F2:  MOVLW  02
28F4:  MOVWF  x6E
28F6:  MOVLW  FA
28F8:  MOVWF  x70
28FA:  CALL   0306
28FE:  DECFSZ x6E,F
2900:  BRA    28F6
....................                                      if (BOT_INI==0){ 
2902:  BTFSC  F81.1
2904:  BRA    292E
....................                                            if (cont_ini==0){ 
2906:  MOVF   57,F
2908:  BNZ   292E
....................                                           limpa_lcd(); 
290A:  CALL   032C
....................                                           printf(escreve_lcd,"AGURADE..."); 
290E:  MOVLW  8C
2910:  MOVWF  FF6
2912:  MOVLW  02
2914:  MOVWF  FF7
2916:  CALL   0390
....................                                           delay_ms(1000); 
291A:  MOVLW  04
291C:  MOVWF  x6E
291E:  MOVLW  FA
2920:  MOVWF  x70
2922:  CALL   0306
2926:  DECFSZ x6E,F
2928:  BRA    291E
....................                                           cont_ini=1; 
292A:  MOVLW  01
292C:  MOVWF  57
....................                                            } 
....................                                      } 
....................                                      if (BOT_INI==0){ 
292E:  BTFSC  F81.1
2930:  BRA    2970
....................                                        if (cont_ini==1){ 
2932:  DECFSZ 57,W
2934:  BRA    2970
....................                                           limpa_lcd(); 
2936:  CALL   032C
....................                                           printf(escreve_lcd,"OK"); 
293A:  MOVLW  4F
293C:  MOVWF  x7B
293E:  CALL   0374
2942:  MOVLW  4B
2944:  MOVWF  x7B
2946:  CALL   0374
....................                                           comando_lcd(0xC0); //  posiciona o cursor no endereço 0x83 
294A:  MOVLW  C0
294C:  MOVWF  x6F
294E:  CALL   02EA
....................                                           printf(escreve_lcd,"INCUBACAO"); 
2952:  MOVLW  98
2954:  MOVWF  FF6
2956:  MOVLW  02
2958:  MOVWF  FF7
295A:  CALL   0390
....................                                           delay_ms(1000); 
295E:  MOVLW  04
2960:  MOVWF  x6E
2962:  MOVLW  FA
2964:  MOVWF  x70
2966:  CALL   0306
296A:  DECFSZ x6E,F
296C:  BRA    2962
....................                                           cont_ini=0; 
296E:  CLRF   57
....................                                            
....................                                      } 
....................                                       
....................                                      } 
....................                                       if (config_bot==0){    // ESTE IF INTERROMPE A INCUBAÇAO 
2970:  BTFSC  F81.4
2972:  BRA    29B8
....................                                        if (cont_ini==1){ 
2974:  DECFSZ 57,W
2976:  BRA    29B8
....................                                              PIN_COOLER =0 ; 
2978:  BCF    F82.0
....................                                              RELE_LAMP = 0 ; 
297A:  BCF    F81.2
....................                                              limpa_lcd(); 
297C:  CALL   032C
....................                                              printf(escreve_lcd,"INCUBACAO"); 
2980:  MOVLW  A2
2982:  MOVWF  FF6
2984:  MOVLW  02
2986:  MOVWF  FF7
2988:  CALL   0390
....................                                              comando_lcd(0xC0); //  posiciona o cursor no endereço 0x83 
298C:  MOVLW  C0
298E:  MOVWF  x6F
2990:  CALL   02EA
....................                                              printf(escreve_lcd,"INTERROMPIDA"); 
2994:  MOVLW  AC
2996:  MOVWF  FF6
2998:  MOVLW  02
299A:  MOVWF  FF7
299C:  CALL   0390
....................                                               
....................                                              
....................                                           delay_ms(1000); 
29A0:  MOVLW  04
29A2:  MOVWF  x6E
29A4:  MOVLW  FA
29A6:  MOVWF  x70
29A8:  CALL   0306
29AC:  DECFSZ x6E,F
29AE:  BRA    29A4
....................                                           cont_ini=0; // VARIAVEL QUE INDICA O Q DEVE SER MOSTRAADO NO LCD;  
29B0:  CLRF   57
....................                                           cont_rotina=0; // SINALIZA QUE A ROTINA DE INCUBAÇAO ESTÁ ENCERRADA 
29B2:  CLRF   59
....................                                           cont=1; 
29B4:  MOVLW  01
29B6:  MOVWF  53
....................                                      } 
....................                                       
....................                                      } 
....................                                      WHILE (config_bot==0){    // QUANDO O BOTAO CONFIGURAÇAO É PRESSIONADO DURANTE A INCUBAÇAO ELE MOSTRA OS VALORES SET. 
29B8:  BTFSC  F81.4
29BA:  BRA    2A52
....................                                        
....................                                             comando_lcd(0x80); 
29BC:  MOVLW  80
29BE:  MOVWF  x6F
29C0:  CALL   02EA
....................                                              printf(escreve_lcd, "SET TEMP:  %.1f        ", set_temp); 
29C4:  MOVLW  BA
29C6:  MOVWF  FF6
29C8:  MOVLW  02
29CA:  MOVWF  FF7
29CC:  MOVLW  0B
29CE:  MOVWF  x6E
29D0:  CALL   1D42
29D4:  MOVLW  89
29D6:  MOVWF  FE9
29D8:  MOVFF  69,71
29DC:  MOVFF  68,70
29E0:  MOVFF  67,6F
29E4:  MOVFF  66,6E
29E8:  MOVLW  01
29EA:  MOVWF  x72
29EC:  CALL   1E30
29F0:  MOVLW  C9
29F2:  MOVWF  FF6
29F4:  MOVLW  02
29F6:  MOVWF  FF7
29F8:  MOVLW  08
29FA:  MOVWF  x6E
29FC:  CALL   1D42
....................                                              comando_lcd(0xC0); 
2A00:  MOVLW  C0
2A02:  MOVWF  x6F
2A04:  CALL   02EA
....................                                              printf(escreve_lcd, "SET UMI:   %.1f       ", set_umi); 
2A08:  MOVLW  D2
2A0A:  MOVWF  FF6
2A0C:  MOVLW  02
2A0E:  MOVWF  FF7
2A10:  MOVLW  0B
2A12:  MOVWF  x6E
2A14:  CALL   1D42
2A18:  MOVLW  89
2A1A:  MOVWF  FE9
2A1C:  MOVFF  6D,71
2A20:  MOVFF  6C,70
2A24:  MOVFF  6B,6F
2A28:  MOVFF  6A,6E
2A2C:  MOVLW  01
2A2E:  MOVWF  x72
2A30:  CALL   1E30
2A34:  MOVLW  E1
2A36:  MOVWF  FF6
2A38:  MOVLW  02
2A3A:  MOVWF  FF7
2A3C:  MOVLW  07
2A3E:  MOVWF  x6E
2A40:  CALL   1D42
....................                                              delay_ms(100); 
2A44:  MOVLW  64
2A46:  MOVWF  x70
2A48:  CALL   0306
....................                                             limpa_lcd(); 
2A4C:  CALL   032C
2A50:  BRA    29B8
....................                                       
....................                                      } 
2A52:  BRA    27E8
....................                                       
....................                                       
....................                                       
....................                                }// fim da rotina 
....................                        
....................                            
....................                         
....................                        
....................                         
....................                         
....................                        BTN_INI = 1;  
2A54:  BSF    x60.1
....................                   } 
....................                       
....................                   } 
....................                    
....................          }  
2A56:  BRA    2A62
....................           else{ 
....................               filtro_INI = t_filtro; 
2A58:  MOVLW  01
2A5A:  MOVWF  5F
2A5C:  MOVLW  90
2A5E:  MOVWF  5E
....................               BTN_INI = 0;  
2A60:  BCF    x60.1
....................       }        
....................            
....................            
....................            
....................            
....................            
....................            
....................   }// fim do unlock 
....................    
....................    
....................    
....................  // if (!UNLOCK){ // BOTAO CONFIGURAÇÃO NÃO FUCIONA QUANDO PROGRAMA ESTIVER NA ROTINA PRINCIPAL 
....................      if (!config_Bot){   // o botao do motor 1 foi pressionado? 
2A62:  BTFSC  F81.4
2A64:  BRA    2A84
....................             if (! (BTN_B1)){ // O botão UP já foi tratato ? 
2A66:  BTFSC  x60.0
2A68:  BRA    2A82
....................              
....................                // não. 
....................                if (filtro_b1 != 0) // Fim do filtro do botão UP ? 
2A6A:  MOVF   5C,F
2A6C:  BNZ   2A72
2A6E:  MOVF   5D,F
2A70:  BZ    2A7C
....................                   filtro_b1--; // Não, então decrementa o filtro 
2A72:  MOVF   5C,W
2A74:  BTFSC  FD8.2
2A76:  DECF   5D,F
2A78:  DECF   5C,F
2A7A:  BRA    2A82
....................                   else {  
....................                       configuracao (); // ao clicar no botão de configuraçao chama a função de configuração, onde serão passados os parametros de temperatura e umidade 
2A7C:  GOTO   226C
....................                       BTN_B1 = 1;  
2A80:  BSF    x60.0
....................                   } 
....................             }         
....................          }  
2A82:  BRA    2A8E
....................           else{ 
....................               filtro_b1 = t_filtro; 
2A84:  MOVLW  01
2A86:  MOVWF  5D
2A88:  MOVLW  90
2A8A:  MOVWF  5C
....................                BTN_B1 = 0;  
2A8C:  BCF    x60.0
....................       }  
2A8E:  BRA    275A
....................       
....................   //}   // FIM DA FLAG UNlock 
....................    
....................       
....................     
....................      
....................    
....................      
....................   }//FIM DA ROTINA PRINCIPAL 
....................    
....................    
.................... }// FIM DA VOID MAIN 
....................  
2A90:  SLEEP 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  

Configuration Fuses:
   Word  1: CC3F   PLL12 CPUDIV4 USBDIV HS FCMEN IESO
   Word  2: 1E38   PUT NOBROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
