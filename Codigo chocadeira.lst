CCS PCH C Compiler, Version 5.015, 5967               13-jun-17 16:49

               Filename:   C:\Users\henri\Documents\GitHub\Projeto-chocadeira\Codigo chocadeira.lst

               ROM used:   6208 bytes (19%)
                           Largest free fragment is 26556
               RAM used:   48 (2%) at main() level
                           112 (5%) worst case
               Stack used: 6 locations (0 in main + 6 for interrupts)
               Stack size: 31

*
0000:  GOTO   17E0
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  FF2.5
004A:  GOTO   0054
004E:  BTFSC  FF2.2
0050:  GOTO   152A
0054:  BTFSS  F9D.0
0056:  GOTO   0060
005A:  BTFSC  F9E.0
005C:  GOTO   17DA
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVF   04,W
0098:  MOVFF  06,FE0
009C:  MOVFF  05,FD8
00A0:  RETFIE 0
.................... #include<18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
00A2:  MOVLW  8E
00A4:  MOVWF  00
00A6:  MOVFF  61,01
00AA:  MOVFF  60,02
00AE:  CLRF   03
00B0:  MOVF   01,F
00B2:  BNZ   00C6
00B4:  MOVFF  02,01
00B8:  CLRF   02
00BA:  MOVLW  08
00BC:  SUBWF  00,F
00BE:  MOVF   01,F
00C0:  BNZ   00C6
00C2:  CLRF   00
00C4:  BRA    00D6
00C6:  BCF    FD8.0
00C8:  BTFSC  01.7
00CA:  BRA    00D4
00CC:  RLCF   02,F
00CE:  RLCF   01,F
00D0:  DECF   00,F
00D2:  BRA    00C6
00D4:  BCF    01.7
00D6:  RETURN 0
00D8:  MOVF   5C,W
00DA:  BTFSC  FD8.2
00DC:  BRA    01C0
00DE:  MOVWF  00
00E0:  MOVF   x60,W
00E2:  BTFSC  FD8.2
00E4:  BRA    01C0
00E6:  ADDWF  00,F
00E8:  BNC   00F2
00EA:  MOVLW  81
00EC:  ADDWF  00,F
00EE:  BC    01C0
00F0:  BRA    00FA
00F2:  MOVLW  7F
00F4:  SUBWF  00,F
00F6:  BNC   01C0
00F8:  BZ    01C0
00FA:  MOVFF  5D,64
00FE:  MOVF   x61,W
0100:  XORWF  x64,F
0102:  BSF    5D.7
0104:  BSF    x61.7
0106:  MOVF   5F,W
0108:  MULWF  x63
010A:  MOVFF  FF4,66
010E:  MOVF   5E,W
0110:  MULWF  x62
0112:  MOVFF  FF4,03
0116:  MOVFF  FF3,65
011A:  MULWF  x63
011C:  MOVF   FF3,W
011E:  ADDWF  x66,F
0120:  MOVF   FF4,W
0122:  ADDWFC x65,F
0124:  MOVLW  00
0126:  ADDWFC 03,F
0128:  MOVF   5F,W
012A:  MULWF  x62
012C:  MOVF   FF3,W
012E:  ADDWF  x66,F
0130:  MOVF   FF4,W
0132:  ADDWFC x65,F
0134:  MOVLW  00
0136:  CLRF   02
0138:  ADDWFC 03,F
013A:  ADDWFC 02,F
013C:  MOVF   5D,W
013E:  MULWF  x63
0140:  MOVF   FF3,W
0142:  ADDWF  x65,F
0144:  MOVF   FF4,W
0146:  ADDWFC 03,F
0148:  MOVLW  00
014A:  ADDWFC 02,F
014C:  MOVF   5D,W
014E:  MULWF  x62
0150:  MOVF   FF3,W
0152:  ADDWF  03,F
0154:  MOVF   FF4,W
0156:  ADDWFC 02,F
0158:  MOVLW  00
015A:  CLRF   01
015C:  ADDWFC 01,F
015E:  MOVF   5F,W
0160:  MULWF  x61
0162:  MOVF   FF3,W
0164:  ADDWF  x65,F
0166:  MOVF   FF4,W
0168:  ADDWFC 03,F
016A:  MOVLW  00
016C:  ADDWFC 02,F
016E:  ADDWFC 01,F
0170:  MOVF   5E,W
0172:  MULWF  x61
0174:  MOVF   FF3,W
0176:  ADDWF  03,F
0178:  MOVF   FF4,W
017A:  ADDWFC 02,F
017C:  MOVLW  00
017E:  ADDWFC 01,F
0180:  MOVF   5D,W
0182:  MULWF  x61
0184:  MOVF   FF3,W
0186:  ADDWF  02,F
0188:  MOVF   FF4,W
018A:  ADDWFC 01,F
018C:  INCF   00,F
018E:  BTFSC  01.7
0190:  BRA    019C
0192:  RLCF   x65,F
0194:  RLCF   03,F
0196:  RLCF   02,F
0198:  RLCF   01,F
019A:  DECF   00,F
019C:  MOVLW  00
019E:  BTFSS  x65.7
01A0:  BRA    01B6
01A2:  INCF   03,F
01A4:  ADDWFC 02,F
01A6:  ADDWFC 01,F
01A8:  MOVF   01,W
01AA:  BNZ   01B6
01AC:  MOVF   02,W
01AE:  BNZ   01B6
01B0:  MOVF   03,W
01B2:  BNZ   01B6
01B4:  INCF   00,F
01B6:  BTFSC  x64.7
01B8:  BSF    01.7
01BA:  BTFSS  x64.7
01BC:  BCF    01.7
01BE:  BRA    01C8
01C0:  CLRF   00
01C2:  CLRF   01
01C4:  CLRF   02
01C6:  CLRF   03
01C8:  RETURN 0
01CA:  MOVF   55,W
01CC:  BTFSC  FD8.2
01CE:  BRA    031A
01D0:  MOVWF  x61
01D2:  MOVF   59,W
01D4:  BTFSC  FD8.2
01D6:  BRA    031A
01D8:  SUBWF  x61,F
01DA:  BNC   01E6
01DC:  MOVLW  7F
01DE:  ADDWF  x61,F
01E0:  BTFSC  FD8.0
01E2:  BRA    031A
01E4:  BRA    01F2
01E6:  MOVLW  81
01E8:  SUBWF  x61,F
01EA:  BTFSS  FD8.0
01EC:  BRA    031A
01EE:  BTFSC  FD8.2
01F0:  BRA    031A
01F2:  MOVFF  61,00
01F6:  CLRF   01
01F8:  CLRF   02
01FA:  CLRF   03
01FC:  CLRF   x60
01FE:  MOVFF  56,5F
0202:  BSF    5F.7
0204:  MOVFF  57,5E
0208:  MOVFF  58,5D
020C:  MOVLW  19
020E:  MOVWF  x61
0210:  MOVF   5C,W
0212:  SUBWF  5D,F
0214:  BC    0230
0216:  MOVLW  01
0218:  SUBWF  5E,F
021A:  BC    0230
021C:  SUBWF  5F,F
021E:  BC    0230
0220:  SUBWF  x60,F
0222:  BC    0230
0224:  INCF   x60,F
0226:  INCF   5F,F
0228:  INCF   5E,F
022A:  MOVF   5C,W
022C:  ADDWF  5D,F
022E:  BRA    0280
0230:  MOVF   5B,W
0232:  SUBWF  5E,F
0234:  BC    025A
0236:  MOVLW  01
0238:  SUBWF  5F,F
023A:  BC    025A
023C:  SUBWF  x60,F
023E:  BC    025A
0240:  INCF   x60,F
0242:  INCF   5F,F
0244:  MOVF   5B,W
0246:  ADDWF  5E,F
0248:  MOVF   5C,W
024A:  ADDWF  5D,F
024C:  BNC   0280
024E:  INCF   5E,F
0250:  BNZ   0280
0252:  INCF   5F,F
0254:  BNZ   0280
0256:  INCF   x60,F
0258:  BRA    0280
025A:  MOVF   5A,W
025C:  IORLW  80
025E:  SUBWF  5F,F
0260:  BC    027E
0262:  MOVLW  01
0264:  SUBWF  x60,F
0266:  BC    027E
0268:  INCF   x60,F
026A:  MOVF   5A,W
026C:  IORLW  80
026E:  ADDWF  5F,F
0270:  MOVF   5B,W
0272:  ADDWF  5E,F
0274:  BNC   0248
0276:  INCF   5F,F
0278:  BNZ   0248
027A:  INCF   x60,F
027C:  BRA    0248
027E:  BSF    03.0
0280:  DECFSZ x61,F
0282:  BRA    0286
0284:  BRA    029C
0286:  BCF    FD8.0
0288:  RLCF   5D,F
028A:  RLCF   5E,F
028C:  RLCF   5F,F
028E:  RLCF   x60,F
0290:  BCF    FD8.0
0292:  RLCF   03,F
0294:  RLCF   02,F
0296:  RLCF   01,F
0298:  RLCF   x62,F
029A:  BRA    0210
029C:  BTFSS  x62.0
029E:  BRA    02AC
02A0:  BCF    FD8.0
02A2:  RRCF   01,F
02A4:  RRCF   02,F
02A6:  RRCF   03,F
02A8:  RRCF   x62,F
02AA:  BRA    02B0
02AC:  DECF   00,F
02AE:  BZ    031A
02B0:  BTFSC  x62.7
02B2:  BRA    02F0
02B4:  BCF    FD8.0
02B6:  RLCF   5D,F
02B8:  RLCF   5E,F
02BA:  RLCF   5F,F
02BC:  RLCF   x60,F
02BE:  MOVF   5C,W
02C0:  SUBWF  5D,F
02C2:  BC    02D2
02C4:  MOVLW  01
02C6:  SUBWF  5E,F
02C8:  BC    02D2
02CA:  SUBWF  5F,F
02CC:  BC    02D2
02CE:  SUBWF  x60,F
02D0:  BNC   0306
02D2:  MOVF   5B,W
02D4:  SUBWF  5E,F
02D6:  BC    02E2
02D8:  MOVLW  01
02DA:  SUBWF  5F,F
02DC:  BC    02E2
02DE:  SUBWF  x60,F
02E0:  BNC   0306
02E2:  MOVF   5A,W
02E4:  IORLW  80
02E6:  SUBWF  5F,F
02E8:  BC    02F0
02EA:  MOVLW  01
02EC:  SUBWF  x60,F
02EE:  BNC   0306
02F0:  INCF   03,F
02F2:  BNZ   0306
02F4:  INCF   02,F
02F6:  BNZ   0306
02F8:  INCF   01,F
02FA:  BNZ   0306
02FC:  INCF   00,F
02FE:  BZ    031A
0300:  RRCF   01,F
0302:  RRCF   02,F
0304:  RRCF   03,F
0306:  MOVFF  56,61
030A:  MOVF   5A,W
030C:  XORWF  x61,F
030E:  BTFSS  x61.7
0310:  BRA    0316
0312:  BSF    01.7
0314:  BRA    0322
0316:  BCF    01.7
0318:  BRA    0322
031A:  CLRF   00
031C:  CLRF   01
031E:  CLRF   02
0320:  CLRF   03
0322:  RETURN 0
0324:  MOVLW  80
0326:  BTFSC  FD8.1
0328:  XORWF  x65,F
032A:  CLRF   x6A
032C:  CLRF   x6B
032E:  MOVFF  61,69
0332:  MOVF   x65,W
0334:  XORWF  x69,F
0336:  MOVF   x60,W
0338:  BTFSC  FD8.2
033A:  BRA    04F4
033C:  MOVWF  x68
033E:  MOVWF  00
0340:  MOVF   x64,W
0342:  BTFSC  FD8.2
0344:  BRA    0506
0346:  SUBWF  x68,F
0348:  BTFSC  FD8.2
034A:  BRA    044E
034C:  BNC   03C8
034E:  MOVFF  65,6E
0352:  BSF    x6E.7
0354:  MOVFF  66,6D
0358:  MOVFF  67,6C
035C:  CLRF   x6B
035E:  BCF    FD8.0
0360:  RRCF   x6E,F
0362:  RRCF   x6D,F
0364:  RRCF   x6C,F
0366:  RRCF   x6B,F
0368:  DECFSZ x68,F
036A:  BRA    035C
036C:  BTFSS  x69.7
036E:  BRA    0376
0370:  BSF    x6A.0
0372:  BRA    052E
0374:  BCF    x6A.0
0376:  BCF    x68.0
0378:  BSF    x6A.4
037A:  CLRF   FEA
037C:  MOVLW  63
037E:  MOVWF  FE9
0380:  BRA    0554
0382:  BCF    x6A.4
0384:  BTFSC  x69.7
0386:  BRA    039C
0388:  BTFSS  x68.0
038A:  BRA    03B2
038C:  RRCF   x6E,F
038E:  RRCF   x6D,F
0390:  RRCF   x6C,F
0392:  RRCF   x6B,F
0394:  INCF   00,F
0396:  BTFSC  FD8.2
0398:  BRA    0524
039A:  BRA    03B2
039C:  BTFSC  x6E.7
039E:  BRA    03B8
03A0:  BCF    FD8.0
03A2:  RLCF   x6B,F
03A4:  RLCF   x6C,F
03A6:  RLCF   x6D,F
03A8:  RLCF   x6E,F
03AA:  DECF   00,F
03AC:  BTFSC  FD8.2
03AE:  BRA    0524
03B0:  BRA    039C
03B2:  BSF    x6A.6
03B4:  BRA    048C
03B6:  BCF    x6A.6
03B8:  MOVFF  61,69
03BC:  BTFSS  x61.7
03BE:  BRA    03C4
03C0:  BSF    x6E.7
03C2:  BRA    0516
03C4:  BCF    x6E.7
03C6:  BRA    0516
03C8:  MOVFF  64,68
03CC:  MOVFF  64,00
03D0:  MOVF   x60,W
03D2:  SUBWF  x68,F
03D4:  MOVFF  61,6E
03D8:  BSF    x6E.7
03DA:  MOVFF  62,6D
03DE:  MOVFF  63,6C
03E2:  CLRF   x6B
03E4:  BCF    FD8.0
03E6:  RRCF   x6E,F
03E8:  RRCF   x6D,F
03EA:  RRCF   x6C,F
03EC:  RRCF   x6B,F
03EE:  DECFSZ x68,F
03F0:  BRA    03E2
03F2:  BTFSS  x69.7
03F4:  BRA    03FC
03F6:  BSF    x6A.1
03F8:  BRA    052E
03FA:  BCF    x6A.1
03FC:  BCF    x68.0
03FE:  BSF    x6A.5
0400:  CLRF   FEA
0402:  MOVLW  67
0404:  MOVWF  FE9
0406:  BRA    0554
0408:  BCF    x6A.5
040A:  BTFSC  x69.7
040C:  BRA    0422
040E:  BTFSS  x68.0
0410:  BRA    0438
0412:  RRCF   x6E,F
0414:  RRCF   x6D,F
0416:  RRCF   x6C,F
0418:  RRCF   x6B,F
041A:  INCF   00,F
041C:  BTFSC  FD8.2
041E:  BRA    0524
0420:  BRA    0438
0422:  BTFSC  x6E.7
0424:  BRA    043E
0426:  BCF    FD8.0
0428:  RLCF   x6B,F
042A:  RLCF   x6C,F
042C:  RLCF   x6D,F
042E:  RLCF   x6E,F
0430:  DECF   00,F
0432:  BTFSC  FD8.2
0434:  BRA    0524
0436:  BRA    0422
0438:  BSF    x6A.7
043A:  BRA    048C
043C:  BCF    x6A.7
043E:  MOVFF  65,69
0442:  BTFSS  x65.7
0444:  BRA    044A
0446:  BSF    x6E.7
0448:  BRA    0516
044A:  BCF    x6E.7
044C:  BRA    0516
044E:  MOVFF  65,6E
0452:  BSF    x6E.7
0454:  MOVFF  66,6D
0458:  MOVFF  67,6C
045C:  BTFSS  x69.7
045E:  BRA    0468
0460:  BCF    x6E.7
0462:  BSF    x6A.2
0464:  BRA    052E
0466:  BCF    x6A.2
0468:  CLRF   x6B
046A:  BCF    x68.0
046C:  CLRF   FEA
046E:  MOVLW  63
0470:  MOVWF  FE9
0472:  BRA    0554
0474:  BTFSC  x69.7
0476:  BRA    04B0
0478:  MOVFF  61,69
047C:  BTFSS  x68.0
047E:  BRA    048C
0480:  RRCF   x6E,F
0482:  RRCF   x6D,F
0484:  RRCF   x6C,F
0486:  RRCF   x6B,F
0488:  INCF   00,F
048A:  BZ    0524
048C:  BTFSS  x6B.7
048E:  BRA    04A6
0490:  INCF   x6C,F
0492:  BNZ   04A6
0494:  INCF   x6D,F
0496:  BNZ   04A6
0498:  INCF   x6E,F
049A:  BNZ   04A6
049C:  RRCF   x6E,F
049E:  RRCF   x6D,F
04A0:  RRCF   x6C,F
04A2:  INCF   00,F
04A4:  BZ    0524
04A6:  BTFSC  x6A.6
04A8:  BRA    03B6
04AA:  BTFSC  x6A.7
04AC:  BRA    043C
04AE:  BRA    04E8
04B0:  MOVLW  80
04B2:  XORWF  x6E,F
04B4:  BTFSS  x6E.7
04B6:  BRA    04C0
04B8:  BRA    052E
04BA:  MOVFF  65,69
04BE:  BRA    04D4
04C0:  MOVFF  61,69
04C4:  MOVF   x6E,F
04C6:  BNZ   04D4
04C8:  MOVF   x6D,F
04CA:  BNZ   04D4
04CC:  MOVF   x6C,F
04CE:  BNZ   04D4
04D0:  CLRF   00
04D2:  BRA    0516
04D4:  BTFSC  x6E.7
04D6:  BRA    04E8
04D8:  BCF    FD8.0
04DA:  RLCF   x6B,F
04DC:  RLCF   x6C,F
04DE:  RLCF   x6D,F
04E0:  RLCF   x6E,F
04E2:  DECFSZ 00,F
04E4:  BRA    04D4
04E6:  BRA    0524
04E8:  BTFSS  x69.7
04EA:  BRA    04F0
04EC:  BSF    x6E.7
04EE:  BRA    0516
04F0:  BCF    x6E.7
04F2:  BRA    0516
04F4:  MOVFF  64,00
04F8:  MOVFF  65,6E
04FC:  MOVFF  66,6D
0500:  MOVFF  67,6C
0504:  BRA    0516
0506:  MOVFF  60,00
050A:  MOVFF  61,6E
050E:  MOVFF  62,6D
0512:  MOVFF  63,6C
0516:  MOVFF  6E,01
051A:  MOVFF  6D,02
051E:  MOVFF  6C,03
0522:  BRA    058C
0524:  CLRF   00
0526:  CLRF   01
0528:  CLRF   02
052A:  CLRF   03
052C:  BRA    058C
052E:  CLRF   x6B
0530:  COMF   x6C,F
0532:  COMF   x6D,F
0534:  COMF   x6E,F
0536:  COMF   x6B,F
0538:  INCF   x6B,F
053A:  BNZ   0546
053C:  INCF   x6C,F
053E:  BNZ   0546
0540:  INCF   x6D,F
0542:  BNZ   0546
0544:  INCF   x6E,F
0546:  BTFSC  x6A.0
0548:  BRA    0374
054A:  BTFSC  x6A.1
054C:  BRA    03FA
054E:  BTFSC  x6A.2
0550:  BRA    0466
0552:  BRA    04BA
0554:  MOVF   FEF,W
0556:  ADDWF  x6C,F
0558:  BNC   0564
055A:  INCF   x6D,F
055C:  BNZ   0564
055E:  INCF   x6E,F
0560:  BTFSC  FD8.2
0562:  BSF    x68.0
0564:  MOVF   FED,F
0566:  MOVF   FEF,W
0568:  ADDWF  x6D,F
056A:  BNC   0572
056C:  INCF   x6E,F
056E:  BTFSC  FD8.2
0570:  BSF    x68.0
0572:  MOVF   FED,F
0574:  MOVF   FEF,W
0576:  BTFSC  FEF.7
0578:  BRA    057C
057A:  XORLW  80
057C:  ADDWF  x6E,F
057E:  BTFSC  FD8.0
0580:  BSF    x68.0
0582:  BTFSC  x6A.4
0584:  BRA    0382
0586:  BTFSC  x6A.5
0588:  BRA    0408
058A:  BRA    0474
058C:  RETURN 0
058E:  MOVFF  5D,64
0592:  MOVF   x61,W
0594:  XORWF  x64,F
0596:  BTFSS  x64.7
0598:  BRA    05A4
059A:  BCF    FD8.2
059C:  BCF    FD8.0
059E:  BTFSC  5D.7
05A0:  BSF    FD8.0
05A2:  BRA    0602
05A4:  MOVFF  5D,64
05A8:  MOVFF  60,65
05AC:  MOVF   5C,W
05AE:  SUBWF  x65,F
05B0:  BZ    05BE
05B2:  BTFSS  x64.7
05B4:  BRA    0602
05B6:  MOVF   FD8,W
05B8:  XORLW  01
05BA:  MOVWF  FD8
05BC:  BRA    0602
05BE:  MOVFF  61,65
05C2:  MOVF   5D,W
05C4:  SUBWF  x65,F
05C6:  BZ    05D4
05C8:  BTFSS  x64.7
05CA:  BRA    0602
05CC:  MOVF   FD8,W
05CE:  XORLW  01
05D0:  MOVWF  FD8
05D2:  BRA    0602
05D4:  MOVFF  62,65
05D8:  MOVF   5E,W
05DA:  SUBWF  x65,F
05DC:  BZ    05EA
05DE:  BTFSS  x64.7
05E0:  BRA    0602
05E2:  MOVF   FD8,W
05E4:  XORLW  01
05E6:  MOVWF  FD8
05E8:  BRA    0602
05EA:  MOVFF  63,65
05EE:  MOVF   5F,W
05F0:  SUBWF  x65,F
05F2:  BZ    0600
05F4:  BTFSS  x64.7
05F6:  BRA    0602
05F8:  MOVF   FD8,W
05FA:  XORLW  01
05FC:  MOVWF  FD8
05FE:  BRA    0602
0600:  BCF    FD8.0
0602:  RETURN 0
0604:  MOVLW  8E
0606:  MOVWF  00
0608:  MOVFF  53,01
060C:  MOVFF  52,02
0610:  CLRF   03
0612:  BTFSS  53.7
0614:  BRA    0620
0616:  COMF   01,F
0618:  COMF   02,F
061A:  INCF   02,F
061C:  BNZ   0620
061E:  INCF   01,F
0620:  MOVF   01,F
0622:  BNZ   0636
0624:  MOVFF  02,01
0628:  CLRF   02
062A:  MOVLW  08
062C:  SUBWF  00,F
062E:  MOVF   01,F
0630:  BNZ   0636
0632:  CLRF   00
0634:  BRA    064A
0636:  BCF    FD8.0
0638:  BTFSC  01.7
063A:  BRA    0644
063C:  RLCF   02,F
063E:  RLCF   01,F
0640:  DECF   00,F
0642:  BRA    0636
0644:  BTFSC  53.7
0646:  BRA    064A
0648:  BCF    01.7
064A:  RETURN 0
*
098C:  MOVLW  8E
098E:  MOVWF  00
0990:  MOVF   5C,W
0992:  SUBWF  00,F
0994:  MOVFF  5D,02
0998:  MOVFF  5E,01
099C:  BSF    02.7
099E:  MOVF   00,F
09A0:  BZ    09B4
09A2:  BCF    FD8.0
09A4:  MOVF   02,F
09A6:  BNZ   09AC
09A8:  MOVF   01,F
09AA:  BZ    09B4
09AC:  RRCF   02,F
09AE:  RRCF   01,F
09B0:  DECFSZ 00,F
09B2:  BRA    09A2
09B4:  BTFSS  5D.7
09B6:  BRA    09C2
09B8:  COMF   01,F
09BA:  COMF   02,F
09BC:  INCF   01,F
09BE:  BTFSC  FD8.2
09C0:  INCF   02,F
09C2:  RETURN 0
....................  
.................... #list 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
09C4:  BCF    5B.0
....................    y = x; 
09C6:  MOVFF  4F,54
09CA:  MOVFF  4E,53
09CE:  MOVFF  4D,52
09D2:  MOVFF  4C,51
....................  
....................    if (x < 0) 
09D6:  MOVFF  4F,5F
09DA:  MOVFF  4E,5E
09DE:  MOVFF  4D,5D
09E2:  MOVFF  4C,5C
09E6:  CLRF   x63
09E8:  CLRF   x62
09EA:  CLRF   x61
09EC:  CLRF   x60
09EE:  RCALL  058E
09F0:  BNC   09FA
....................    { 
....................       s = 1; 
09F2:  BSF    5B.0
....................       y = -y; 
09F4:  MOVF   52,W
09F6:  XORLW  80
09F8:  MOVWF  52
....................    } 
....................  
....................    if (y <= 32768.0) 
09FA:  MOVFF  54,5F
09FE:  MOVFF  53,5E
0A02:  MOVFF  52,5D
0A06:  MOVFF  51,5C
0A0A:  CLRF   x63
0A0C:  CLRF   x62
0A0E:  CLRF   x61
0A10:  MOVLW  8E
0A12:  MOVWF  x60
0A14:  RCALL  058E
0A16:  BC    0A1A
0A18:  BNZ   0A4A
....................       res = (float32)(unsigned int16)y; 
0A1A:  MOVFF  54,5F
0A1E:  MOVFF  53,5E
0A22:  MOVFF  52,5D
0A26:  MOVFF  51,5C
0A2A:  RCALL  098C
0A2C:  MOVFF  02,61
0A30:  MOVFF  01,60
0A34:  CALL   00A2
0A38:  MOVFF  03,58
0A3C:  MOVFF  02,57
0A40:  MOVFF  01,56
0A44:  MOVFF  00,55
0A48:  BRA    0BD4
....................  
....................  else if (y < 10000000.0) 
0A4A:  MOVFF  54,5F
0A4E:  MOVFF  53,5E
0A52:  MOVFF  52,5D
0A56:  MOVFF  51,5C
0A5A:  MOVLW  80
0A5C:  MOVWF  x63
0A5E:  MOVLW  96
0A60:  MOVWF  x62
0A62:  MOVLW  18
0A64:  MOVWF  x61
0A66:  MOVLW  96
0A68:  MOVWF  x60
0A6A:  RCALL  058E
0A6C:  BTFSS  FD8.0
0A6E:  BRA    0BC4
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
0A70:  MOVFF  54,5F
0A74:  MOVFF  53,5E
0A78:  MOVFF  52,5D
0A7C:  MOVFF  51,5C
0A80:  CLRF   x63
0A82:  CLRF   x62
0A84:  CLRF   x61
0A86:  MOVLW  70
0A88:  MOVWF  x60
0A8A:  CALL   00D8
0A8E:  MOVFF  03,5F
0A92:  MOVFF  02,5E
0A96:  MOVFF  01,5D
0A9A:  MOVFF  00,5C
0A9E:  RCALL  098C
0AA0:  MOVFF  02,5A
0AA4:  MOVFF  01,59
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
0AA8:  MOVFF  54,5F
0AAC:  MOVFF  53,5E
0AB0:  MOVFF  52,5D
0AB4:  MOVFF  51,5C
0AB8:  CLRF   x63
0ABA:  CLRF   x62
0ABC:  CLRF   x61
0ABE:  MOVLW  70
0AC0:  MOVWF  x60
0AC2:  CALL   00D8
0AC6:  MOVFF  03,5F
0ACA:  MOVFF  02,5E
0ACE:  MOVFF  01,5D
0AD2:  MOVFF  00,5C
0AD6:  MOVFF  5A,61
0ADA:  MOVFF  59,60
0ADE:  CALL   00A2
0AE2:  BSF    FD8.1
0AE4:  MOVFF  5F,63
0AE8:  MOVFF  5E,62
0AEC:  MOVFF  5D,61
0AF0:  MOVFF  5C,60
0AF4:  MOVFF  03,67
0AF8:  MOVFF  02,66
0AFC:  MOVFF  01,65
0B00:  MOVFF  00,64
0B04:  RCALL  0324
0B06:  CLRF   5F
0B08:  CLRF   5E
0B0A:  CLRF   5D
0B0C:  MOVLW  8E
0B0E:  MOVWF  5C
0B10:  MOVFF  03,63
0B14:  MOVFF  02,62
0B18:  MOVFF  01,61
0B1C:  MOVFF  00,60
0B20:  CALL   00D8
0B24:  MOVFF  03,54
0B28:  MOVFF  02,53
0B2C:  MOVFF  01,52
0B30:  MOVFF  00,51
....................       res = 32768.0*(float32)l; 
0B34:  MOVFF  5A,61
0B38:  MOVFF  59,60
0B3C:  CALL   00A2
0B40:  CLRF   5F
0B42:  CLRF   5E
0B44:  CLRF   5D
0B46:  MOVLW  8E
0B48:  MOVWF  5C
0B4A:  MOVFF  03,63
0B4E:  MOVFF  02,62
0B52:  MOVFF  01,61
0B56:  MOVFF  00,60
0B5A:  CALL   00D8
0B5E:  MOVFF  03,58
0B62:  MOVFF  02,57
0B66:  MOVFF  01,56
0B6A:  MOVFF  00,55
....................       res += (float32)(unsigned int16)y; 
0B6E:  MOVFF  54,5F
0B72:  MOVFF  53,5E
0B76:  MOVFF  52,5D
0B7A:  MOVFF  51,5C
0B7E:  RCALL  098C
0B80:  MOVFF  02,61
0B84:  MOVFF  01,60
0B88:  CALL   00A2
0B8C:  BCF    FD8.1
0B8E:  MOVFF  58,63
0B92:  MOVFF  57,62
0B96:  MOVFF  56,61
0B9A:  MOVFF  55,60
0B9E:  MOVFF  03,67
0BA2:  MOVFF  02,66
0BA6:  MOVFF  01,65
0BAA:  MOVFF  00,64
0BAE:  CALL   0324
0BB2:  MOVFF  03,58
0BB6:  MOVFF  02,57
0BBA:  MOVFF  01,56
0BBE:  MOVFF  00,55
....................    } 
0BC2:  BRA    0BD4
....................  
....................  else 
....................   res = y; 
0BC4:  MOVFF  54,58
0BC8:  MOVFF  53,57
0BCC:  MOVFF  52,56
0BD0:  MOVFF  51,55
....................  
....................  y = y - (float32)(unsigned int16)y; 
0BD4:  MOVFF  54,5F
0BD8:  MOVFF  53,5E
0BDC:  MOVFF  52,5D
0BE0:  MOVFF  51,5C
0BE4:  RCALL  098C
0BE6:  MOVFF  02,61
0BEA:  MOVFF  01,60
0BEE:  CALL   00A2
0BF2:  BSF    FD8.1
0BF4:  MOVFF  54,63
0BF8:  MOVFF  53,62
0BFC:  MOVFF  52,61
0C00:  MOVFF  51,60
0C04:  MOVFF  03,67
0C08:  MOVFF  02,66
0C0C:  MOVFF  01,65
0C10:  MOVFF  00,64
0C14:  CALL   0324
0C18:  MOVFF  03,54
0C1C:  MOVFF  02,53
0C20:  MOVFF  01,52
0C24:  MOVFF  00,51
....................  
....................  if (s) 
0C28:  BTFSS  5B.0
0C2A:  BRA    0C32
....................   res = -res; 
0C2C:  MOVF   56,W
0C2E:  XORLW  80
0C30:  MOVWF  56
....................  
....................  if (y != 0) 
0C32:  MOVFF  54,5F
0C36:  MOVFF  53,5E
0C3A:  MOVFF  52,5D
0C3E:  MOVFF  51,5C
0C42:  CLRF   x63
0C44:  CLRF   x62
0C46:  CLRF   x61
0C48:  CLRF   x60
0C4A:  RCALL  058E
0C4C:  BZ    0CBE
....................  { 
....................   if (s == 1 && n == 0) 
0C4E:  BTFSS  5B.0
0C50:  BRA    0C86
0C52:  MOVF   50,F
0C54:  BNZ   0C86
....................    res -= 1.0; 
0C56:  BSF    FD8.1
0C58:  MOVFF  58,63
0C5C:  MOVFF  57,62
0C60:  MOVFF  56,61
0C64:  MOVFF  55,60
0C68:  CLRF   x67
0C6A:  CLRF   x66
0C6C:  CLRF   x65
0C6E:  MOVLW  7F
0C70:  MOVWF  x64
0C72:  CALL   0324
0C76:  MOVFF  03,58
0C7A:  MOVFF  02,57
0C7E:  MOVFF  01,56
0C82:  MOVFF  00,55
....................  
....................   if (s == 0 && n == 1) 
0C86:  BTFSC  5B.0
0C88:  BRA    0CBE
0C8A:  DECFSZ 50,W
0C8C:  BRA    0CBE
....................    res += 1.0; 
0C8E:  BCF    FD8.1
0C90:  MOVFF  58,63
0C94:  MOVFF  57,62
0C98:  MOVFF  56,61
0C9C:  MOVFF  55,60
0CA0:  CLRF   x67
0CA2:  CLRF   x66
0CA4:  CLRF   x65
0CA6:  MOVLW  7F
0CA8:  MOVWF  x64
0CAA:  CALL   0324
0CAE:  MOVFF  03,58
0CB2:  MOVFF  02,57
0CB6:  MOVFF  01,56
0CBA:  MOVFF  00,55
....................  } 
....................  if (x == 0) 
0CBE:  MOVFF  4F,5F
0CC2:  MOVFF  4E,5E
0CC6:  MOVFF  4D,5D
0CCA:  MOVFF  4C,5C
0CCE:  CLRF   x63
0CD0:  CLRF   x62
0CD2:  CLRF   x61
0CD4:  CLRF   x60
0CD6:  RCALL  058E
0CD8:  BNZ   0CE2
....................     res = 0; 
0CDA:  CLRF   58
0CDC:  CLRF   57
0CDE:  CLRF   56
0CE0:  CLRF   55
....................  
....................  return (res); 
0CE2:  MOVFF  55,00
0CE6:  MOVFF  56,01
0CEA:  MOVFF  57,02
0CEE:  MOVFF  58,03
0CF2:  RETURN 0
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
*
0D0E:  MOVFF  4B,4F
0D12:  MOVFF  4A,4E
0D16:  MOVFF  49,4D
0D1A:  MOVFF  48,4C
0D1E:  CLRF   50
0D20:  RCALL  09C4
0D22:  GOTO   0E24 (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
0CF4:  MOVFF  4B,4F
0CF8:  MOVFF  4A,4E
0CFC:  MOVFF  49,4D
0D00:  MOVFF  48,4C
0D04:  MOVLW  01
0D06:  MOVWF  50
0D08:  RCALL  09C4
0D0A:  GOTO   0DDC (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
*
0D26:  MOVFF  3F,5F
0D2A:  MOVFF  3E,5E
0D2E:  MOVFF  3D,5D
0D32:  MOVFF  3C,5C
0D36:  CLRF   x63
0D38:  CLRF   x62
0D3A:  CLRF   x61
0D3C:  CLRF   x60
0D3E:  RCALL  058E
0D40:  BTFSC  FD8.2
0D42:  BRA    0E80
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
0D44:  MOVFF  3B,58
0D48:  MOVFF  3A,57
0D4C:  MOVFF  39,56
0D50:  MOVFF  38,55
0D54:  MOVFF  3F,5C
0D58:  MOVFF  3E,5B
0D5C:  MOVFF  3D,5A
0D60:  MOVFF  3C,59
0D64:  CALL   01CA
0D68:  MOVFF  03,47
0D6C:  MOVFF  02,46
0D70:  MOVFF  01,45
0D74:  MOVFF  00,44
0D78:  MOVFF  03,5F
0D7C:  MOVFF  02,5E
0D80:  MOVFF  01,5D
0D84:  MOVFF  00,5C
0D88:  CLRF   x63
0D8A:  CLRF   x62
0D8C:  CLRF   x61
0D8E:  CLRF   x60
0D90:  CALL   058E
0D94:  BNC   0DDE
0D96:  MOVFF  3B,58
0D9A:  MOVFF  3A,57
0D9E:  MOVFF  39,56
0DA2:  MOVFF  38,55
0DA6:  MOVFF  3F,5C
0DAA:  MOVFF  3E,5B
0DAE:  MOVFF  3D,5A
0DB2:  MOVFF  3C,59
0DB6:  CALL   01CA
0DBA:  MOVFF  03,47
0DBE:  MOVFF  02,46
0DC2:  MOVFF  01,45
0DC6:  MOVFF  00,44
0DCA:  MOVFF  03,4B
0DCE:  MOVFF  02,4A
0DD2:  MOVFF  01,49
0DD6:  MOVFF  00,48
0DDA:  BRA    0CF4
0DDC:  BRA    0E24
0DDE:  MOVFF  3B,58
0DE2:  MOVFF  3A,57
0DE6:  MOVFF  39,56
0DEA:  MOVFF  38,55
0DEE:  MOVFF  3F,5C
0DF2:  MOVFF  3E,5B
0DF6:  MOVFF  3D,5A
0DFA:  MOVFF  3C,59
0DFE:  CALL   01CA
0E02:  MOVFF  03,47
0E06:  MOVFF  02,46
0E0A:  MOVFF  01,45
0E0E:  MOVFF  00,44
0E12:  MOVFF  03,4B
0E16:  MOVFF  02,4A
0E1A:  MOVFF  01,49
0E1E:  MOVFF  00,48
0E22:  BRA    0D0E
0E24:  MOVFF  03,43
0E28:  MOVFF  02,42
0E2C:  MOVFF  01,41
0E30:  MOVFF  00,40
....................       return(x-(i*y)); 
0E34:  MOVFF  43,5F
0E38:  MOVFF  42,5E
0E3C:  MOVFF  41,5D
0E40:  MOVFF  40,5C
0E44:  MOVFF  3F,63
0E48:  MOVFF  3E,62
0E4C:  MOVFF  3D,61
0E50:  MOVFF  3C,60
0E54:  CALL   00D8
0E58:  BSF    FD8.1
0E5A:  MOVFF  3B,63
0E5E:  MOVFF  3A,62
0E62:  MOVFF  39,61
0E66:  MOVFF  38,60
0E6A:  MOVFF  03,67
0E6E:  MOVFF  02,66
0E72:  MOVFF  01,65
0E76:  MOVFF  00,64
0E7A:  CALL   0324
0E7E:  BRA    0E80
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
0E80:  RETURN 0
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
0E82:  MOVFF  3F,5F
0E86:  MOVFF  3E,5E
0E8A:  MOVFF  3D,5D
0E8E:  MOVFF  3C,5C
0E92:  MOVLW  3B
0E94:  MOVWF  x63
0E96:  MOVLW  AA
0E98:  MOVWF  x62
0E9A:  MOVLW  38
0E9C:  MOVWF  x61
0E9E:  MOVLW  7F
0EA0:  MOVWF  x60
0EA2:  CALL   00D8
0EA6:  MOVFF  03,5F
0EAA:  MOVFF  02,5E
0EAE:  MOVFF  01,5D
0EB2:  MOVFF  00,5C
0EB6:  RCALL  098C
0EB8:  MOVFF  01,4C
....................    s = 0; 
0EBC:  BCF    4D.0
....................    y = x; 
0EBE:  MOVFF  3F,43
0EC2:  MOVFF  3E,42
0EC6:  MOVFF  3D,41
0ECA:  MOVFF  3C,40
....................  
....................    if (x < 0) 
0ECE:  MOVFF  3F,5F
0ED2:  MOVFF  3E,5E
0ED6:  MOVFF  3D,5D
0EDA:  MOVFF  3C,5C
0EDE:  CLRF   x63
0EE0:  CLRF   x62
0EE2:  CLRF   x61
0EE4:  CLRF   x60
0EE6:  CALL   058E
0EEA:  BNC   0EF6
....................    { 
....................       s = 1; 
0EEC:  BSF    4D.0
....................       n = -n; 
0EEE:  NEGF   4C
....................       y = -y; 
0EF0:  MOVF   41,W
0EF2:  XORLW  80
0EF4:  MOVWF  41
....................    } 
....................  
....................    res = 0.0; 
0EF6:  CLRF   47
0EF8:  CLRF   46
0EFA:  CLRF   45
0EFC:  CLRF   44
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
0EFE:  CLRF   4F
0F00:  MOVLW  44
0F02:  MOVWF  FE9
0F04:  MOVFF  4F,FEA
0F08:  MOVLW  7F
0F0A:  ADDWF  4C,W
0F0C:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
0F0E:  MOVFF  43,5F
0F12:  MOVFF  42,5E
0F16:  MOVFF  41,5D
0F1A:  MOVFF  40,5C
0F1E:  MOVLW  3B
0F20:  MOVWF  x63
0F22:  MOVLW  AA
0F24:  MOVWF  x62
0F26:  MOVLW  38
0F28:  MOVWF  x61
0F2A:  MOVLW  7F
0F2C:  MOVWF  x60
0F2E:  CALL   00D8
0F32:  MOVFF  03,51
0F36:  MOVFF  02,50
0F3A:  MOVFF  01,4F
0F3E:  MOVFF  00,4E
0F42:  CLRF   53
0F44:  MOVFF  4C,52
0F48:  BTFSC  52.7
0F4A:  DECF   53,F
0F4C:  CALL   0604
0F50:  BSF    FD8.1
0F52:  MOVFF  51,63
0F56:  MOVFF  50,62
0F5A:  MOVFF  4F,61
0F5E:  MOVFF  4E,60
0F62:  MOVFF  03,67
0F66:  MOVFF  02,66
0F6A:  MOVFF  01,65
0F6E:  MOVFF  00,64
0F72:  CALL   0324
0F76:  MOVFF  03,43
0F7A:  MOVFF  02,42
0F7E:  MOVFF  01,41
0F82:  MOVFF  00,40
....................  
....................    r = pe[0]*y + pe[1]; 
0F86:  MOVLW  7C
0F88:  MOVWF  5F
0F8A:  MOVLW  88
0F8C:  MOVWF  5E
0F8E:  MOVLW  59
0F90:  MOVWF  5D
0F92:  MOVLW  72
0F94:  MOVWF  5C
0F96:  MOVFF  43,63
0F9A:  MOVFF  42,62
0F9E:  MOVFF  41,61
0FA2:  MOVFF  40,60
0FA6:  CALL   00D8
0FAA:  MOVFF  03,51
0FAE:  MOVFF  02,50
0FB2:  MOVFF  01,4F
0FB6:  MOVFF  00,4E
0FBA:  BCF    FD8.1
0FBC:  MOVFF  03,63
0FC0:  MOVFF  02,62
0FC4:  MOVFF  01,61
0FC8:  MOVFF  00,60
0FCC:  MOVLW  E0
0FCE:  MOVWF  x67
0FD0:  MOVLW  97
0FD2:  MOVWF  x66
0FD4:  MOVLW  26
0FD6:  MOVWF  x65
0FD8:  MOVLW  75
0FDA:  MOVWF  x64
0FDC:  CALL   0324
0FE0:  MOVFF  03,4B
0FE4:  MOVFF  02,4A
0FE8:  MOVFF  01,49
0FEC:  MOVFF  00,48
....................    r = r*y + pe[2]; 
0FF0:  MOVFF  4B,5F
0FF4:  MOVFF  4A,5E
0FF8:  MOVFF  49,5D
0FFC:  MOVFF  48,5C
1000:  MOVFF  43,63
1004:  MOVFF  42,62
1008:  MOVFF  41,61
100C:  MOVFF  40,60
1010:  CALL   00D8
1014:  MOVFF  03,51
1018:  MOVFF  02,50
101C:  MOVFF  01,4F
1020:  MOVFF  00,4E
1024:  BCF    FD8.1
1026:  MOVFF  03,63
102A:  MOVFF  02,62
102E:  MOVFF  01,61
1032:  MOVFF  00,60
1036:  MOVLW  C4
1038:  MOVWF  x67
103A:  MOVLW  1D
103C:  MOVWF  x66
103E:  MOVLW  1E
1040:  MOVWF  x65
1042:  MOVLW  78
1044:  MOVWF  x64
1046:  CALL   0324
104A:  MOVFF  03,4B
104E:  MOVFF  02,4A
1052:  MOVFF  01,49
1056:  MOVFF  00,48
....................    r = r*y + pe[3]; 
105A:  MOVFF  4B,5F
105E:  MOVFF  4A,5E
1062:  MOVFF  49,5D
1066:  MOVFF  48,5C
106A:  MOVFF  43,63
106E:  MOVFF  42,62
1072:  MOVFF  41,61
1076:  MOVFF  40,60
107A:  CALL   00D8
107E:  MOVFF  03,51
1082:  MOVFF  02,50
1086:  MOVFF  01,4F
108A:  MOVFF  00,4E
108E:  BCF    FD8.1
1090:  MOVFF  03,63
1094:  MOVFF  02,62
1098:  MOVFF  01,61
109C:  MOVFF  00,60
10A0:  MOVLW  5E
10A2:  MOVWF  x67
10A4:  MOVLW  50
10A6:  MOVWF  x66
10A8:  MOVLW  63
10AA:  MOVWF  x65
10AC:  MOVLW  7A
10AE:  MOVWF  x64
10B0:  CALL   0324
10B4:  MOVFF  03,4B
10B8:  MOVFF  02,4A
10BC:  MOVFF  01,49
10C0:  MOVFF  00,48
....................    r = r*y + pe[4]; 
10C4:  MOVFF  4B,5F
10C8:  MOVFF  4A,5E
10CC:  MOVFF  49,5D
10D0:  MOVFF  48,5C
10D4:  MOVFF  43,63
10D8:  MOVFF  42,62
10DC:  MOVFF  41,61
10E0:  MOVFF  40,60
10E4:  CALL   00D8
10E8:  MOVFF  03,51
10EC:  MOVFF  02,50
10F0:  MOVFF  01,4F
10F4:  MOVFF  00,4E
10F8:  BCF    FD8.1
10FA:  MOVFF  03,63
10FE:  MOVFF  02,62
1102:  MOVFF  01,61
1106:  MOVFF  00,60
110A:  MOVLW  1A
110C:  MOVWF  x67
110E:  MOVLW  FE
1110:  MOVWF  x66
1112:  MOVLW  75
1114:  MOVWF  x65
1116:  MOVLW  7C
1118:  MOVWF  x64
111A:  CALL   0324
111E:  MOVFF  03,4B
1122:  MOVFF  02,4A
1126:  MOVFF  01,49
112A:  MOVFF  00,48
....................    r = r*y + pe[5]; 
112E:  MOVFF  4B,5F
1132:  MOVFF  4A,5E
1136:  MOVFF  49,5D
113A:  MOVFF  48,5C
113E:  MOVFF  43,63
1142:  MOVFF  42,62
1146:  MOVFF  41,61
114A:  MOVFF  40,60
114E:  CALL   00D8
1152:  MOVFF  03,51
1156:  MOVFF  02,50
115A:  MOVFF  01,4F
115E:  MOVFF  00,4E
1162:  BCF    FD8.1
1164:  MOVFF  03,63
1168:  MOVFF  02,62
116C:  MOVFF  01,61
1170:  MOVFF  00,60
1174:  MOVLW  18
1176:  MOVWF  x67
1178:  MOVLW  72
117A:  MOVWF  x66
117C:  MOVLW  31
117E:  MOVWF  x65
1180:  MOVLW  7E
1182:  MOVWF  x64
1184:  CALL   0324
1188:  MOVFF  03,4B
118C:  MOVFF  02,4A
1190:  MOVFF  01,49
1194:  MOVFF  00,48
....................  
....................    res = res*(1.0 + y*r); 
1198:  MOVFF  43,5F
119C:  MOVFF  42,5E
11A0:  MOVFF  41,5D
11A4:  MOVFF  40,5C
11A8:  MOVFF  4B,63
11AC:  MOVFF  4A,62
11B0:  MOVFF  49,61
11B4:  MOVFF  48,60
11B8:  CALL   00D8
11BC:  BCF    FD8.1
11BE:  CLRF   x63
11C0:  CLRF   x62
11C2:  CLRF   x61
11C4:  MOVLW  7F
11C6:  MOVWF  x60
11C8:  MOVFF  03,67
11CC:  MOVFF  02,66
11D0:  MOVFF  01,65
11D4:  MOVFF  00,64
11D8:  CALL   0324
11DC:  MOVFF  47,5F
11E0:  MOVFF  46,5E
11E4:  MOVFF  45,5D
11E8:  MOVFF  44,5C
11EC:  MOVFF  03,63
11F0:  MOVFF  02,62
11F4:  MOVFF  01,61
11F8:  MOVFF  00,60
11FC:  CALL   00D8
1200:  MOVFF  03,47
1204:  MOVFF  02,46
1208:  MOVFF  01,45
120C:  MOVFF  00,44
....................  
....................    if (s) 
1210:  BTFSS  4D.0
1212:  BRA    1242
....................       res = 1.0/res; 
1214:  CLRF   58
1216:  CLRF   57
1218:  CLRF   56
121A:  MOVLW  7F
121C:  MOVWF  55
121E:  MOVFF  47,5C
1222:  MOVFF  46,5B
1226:  MOVFF  45,5A
122A:  MOVFF  44,59
122E:  CALL   01CA
1232:  MOVFF  03,47
1236:  MOVFF  02,46
123A:  MOVFF  01,45
123E:  MOVFF  00,44
....................    return(res); 
1242:  MOVFF  44,00
1246:  MOVFF  45,01
124A:  MOVFF  46,02
124E:  MOVFF  47,03
1252:  RETURN 0
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
*
064C:  MOVFF  3F,43
0650:  MOVFF  3E,42
0654:  MOVFF  3D,41
0658:  MOVFF  3C,40
....................  
....................    if (y != 1.0) 
065C:  MOVFF  43,5F
0660:  MOVFF  42,5E
0664:  MOVFF  41,5D
0668:  MOVFF  40,5C
066C:  CLRF   x63
066E:  CLRF   x62
0670:  CLRF   x61
0672:  MOVLW  7F
0674:  MOVWF  x60
0676:  RCALL  058E
0678:  BTFSC  FD8.2
067A:  BRA    0972
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
067C:  CLRF   52
067E:  MOVLW  40
0680:  MOVWF  FE9
0682:  MOVFF  52,FEA
0686:  MOVLW  7E
0688:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
068A:  BSF    FD8.1
068C:  MOVFF  43,63
0690:  MOVFF  42,62
0694:  MOVFF  41,61
0698:  MOVFF  40,60
069C:  CLRF   x67
069E:  CLRF   x66
06A0:  CLRF   x65
06A2:  MOVLW  7F
06A4:  MOVWF  x64
06A6:  RCALL  0324
06A8:  MOVFF  03,54
06AC:  MOVFF  02,53
06B0:  MOVFF  01,52
06B4:  MOVFF  00,51
06B8:  BCF    FD8.1
06BA:  MOVFF  43,63
06BE:  MOVFF  42,62
06C2:  MOVFF  41,61
06C6:  MOVFF  40,60
06CA:  CLRF   x67
06CC:  CLRF   x66
06CE:  CLRF   x65
06D0:  MOVLW  7F
06D2:  MOVWF  x64
06D4:  RCALL  0324
06D6:  MOVFF  54,58
06DA:  MOVFF  53,57
06DE:  MOVFF  52,56
06E2:  MOVFF  51,55
06E6:  MOVFF  03,5C
06EA:  MOVFF  02,5B
06EE:  MOVFF  01,5A
06F2:  MOVFF  00,59
06F6:  RCALL  01CA
06F8:  MOVFF  03,43
06FC:  MOVFF  02,42
0700:  MOVFF  01,41
0704:  MOVFF  00,40
....................  
....................       y2=y*y; 
0708:  MOVFF  43,5F
070C:  MOVFF  42,5E
0710:  MOVFF  41,5D
0714:  MOVFF  40,5C
0718:  MOVFF  43,63
071C:  MOVFF  42,62
0720:  MOVFF  41,61
0724:  MOVFF  40,60
0728:  RCALL  00D8
072A:  MOVFF  03,4F
072E:  MOVFF  02,4E
0732:  MOVFF  01,4D
0736:  MOVFF  00,4C
....................  
....................       res = pl[0]*y2 + pl[1]; 
073A:  MOVLW  99
073C:  MOVWF  5F
073E:  MOVLW  47
0740:  MOVWF  5E
0742:  MOVLW  8A
0744:  MOVWF  5D
0746:  MOVLW  7F
0748:  MOVWF  5C
074A:  MOVFF  4F,63
074E:  MOVFF  4E,62
0752:  MOVFF  4D,61
0756:  MOVFF  4C,60
075A:  RCALL  00D8
075C:  MOVFF  03,54
0760:  MOVFF  02,53
0764:  MOVFF  01,52
0768:  MOVFF  00,51
076C:  BCF    FD8.1
076E:  MOVFF  03,63
0772:  MOVFF  02,62
0776:  MOVFF  01,61
077A:  MOVFF  00,60
077E:  CLRF   x67
0780:  CLRF   x66
0782:  CLRF   x65
0784:  MOVLW  80
0786:  MOVWF  x64
0788:  RCALL  0324
078A:  MOVFF  03,47
078E:  MOVFF  02,46
0792:  MOVFF  01,45
0796:  MOVFF  00,44
....................  
....................       r = ql[0]*y2 + ql[1]; 
079A:  MOVLW  4C
079C:  MOVWF  5F
079E:  MOVLW  F3
07A0:  MOVWF  5E
07A2:  MOVLW  3A
07A4:  MOVWF  5D
07A6:  MOVLW  7B
07A8:  MOVWF  5C
07AA:  MOVFF  4F,63
07AE:  MOVFF  4E,62
07B2:  MOVFF  4D,61
07B6:  MOVFF  4C,60
07BA:  RCALL  00D8
07BC:  MOVFF  03,54
07C0:  MOVFF  02,53
07C4:  MOVFF  01,52
07C8:  MOVFF  00,51
07CC:  BCF    FD8.1
07CE:  MOVFF  03,63
07D2:  MOVFF  02,62
07D6:  MOVFF  01,61
07DA:  MOVFF  00,60
07DE:  MOVLW  2B
07E0:  MOVWF  x67
07E2:  MOVLW  9D
07E4:  MOVWF  x66
07E6:  MOVLW  DF
07E8:  MOVWF  x65
07EA:  MOVLW  7E
07EC:  MOVWF  x64
07EE:  RCALL  0324
07F0:  MOVFF  03,4B
07F4:  MOVFF  02,4A
07F8:  MOVFF  01,49
07FC:  MOVFF  00,48
....................       r = r*y2 + 1.0; 
0800:  MOVFF  4B,5F
0804:  MOVFF  4A,5E
0808:  MOVFF  49,5D
080C:  MOVFF  48,5C
0810:  MOVFF  4F,63
0814:  MOVFF  4E,62
0818:  MOVFF  4D,61
081C:  MOVFF  4C,60
0820:  RCALL  00D8
0822:  MOVFF  03,54
0826:  MOVFF  02,53
082A:  MOVFF  01,52
082E:  MOVFF  00,51
0832:  BCF    FD8.1
0834:  MOVFF  03,63
0838:  MOVFF  02,62
083C:  MOVFF  01,61
0840:  MOVFF  00,60
0844:  CLRF   x67
0846:  CLRF   x66
0848:  CLRF   x65
084A:  MOVLW  7F
084C:  MOVWF  x64
084E:  RCALL  0324
0850:  MOVFF  03,4B
0854:  MOVFF  02,4A
0858:  MOVFF  01,49
085C:  MOVFF  00,48
....................  
....................       res = y*res/r; 
0860:  MOVFF  43,5F
0864:  MOVFF  42,5E
0868:  MOVFF  41,5D
086C:  MOVFF  40,5C
0870:  MOVFF  47,63
0874:  MOVFF  46,62
0878:  MOVFF  45,61
087C:  MOVFF  44,60
0880:  RCALL  00D8
0882:  MOVFF  03,54
0886:  MOVFF  02,53
088A:  MOVFF  01,52
088E:  MOVFF  00,51
0892:  MOVFF  03,58
0896:  MOVFF  02,57
089A:  MOVFF  01,56
089E:  MOVFF  00,55
08A2:  MOVFF  4B,5C
08A6:  MOVFF  4A,5B
08AA:  MOVFF  49,5A
08AE:  MOVFF  48,59
08B2:  RCALL  01CA
08B4:  MOVFF  03,47
08B8:  MOVFF  02,46
08BC:  MOVFF  01,45
08C0:  MOVFF  00,44
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
08C4:  CLRF   52
08C6:  MOVLW  3C
08C8:  MOVWF  FE9
08CA:  MOVFF  52,FEA
08CE:  MOVLW  7E
08D0:  SUBWF  FEF,W
08D2:  MOVWF  50
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
08D4:  BTFSS  50.7
08D6:  BRA    08FC
....................          r = -(float32)-n; 
08D8:  MOVLW  00
08DA:  BSF    FD8.0
08DC:  SUBFWB 50,W
08DE:  CLRF   53
08E0:  MOVWF  52
08E2:  BTFSC  52.7
08E4:  DECF   53,F
08E6:  RCALL  0604
08E8:  MOVFF  00,48
08EC:  MOVF   01,W
08EE:  XORLW  80
08F0:  MOVWF  49
08F2:  MOVFF  02,4A
08F6:  MOVFF  03,4B
08FA:  BRA    0918
....................       else 
....................          r = (float32)n; 
08FC:  CLRF   53
08FE:  MOVFF  50,52
0902:  BTFSC  52.7
0904:  DECF   53,F
0906:  RCALL  0604
0908:  MOVFF  03,4B
090C:  MOVFF  02,4A
0910:  MOVFF  01,49
0914:  MOVFF  00,48
....................  
....................       res += r*LN2; 
0918:  MOVFF  4B,5F
091C:  MOVFF  4A,5E
0920:  MOVFF  49,5D
0924:  MOVFF  48,5C
0928:  MOVLW  18
092A:  MOVWF  x63
092C:  MOVLW  72
092E:  MOVWF  x62
0930:  MOVLW  31
0932:  MOVWF  x61
0934:  MOVLW  7E
0936:  MOVWF  x60
0938:  CALL   00D8
093C:  BCF    FD8.1
093E:  MOVFF  47,63
0942:  MOVFF  46,62
0946:  MOVFF  45,61
094A:  MOVFF  44,60
094E:  MOVFF  03,67
0952:  MOVFF  02,66
0956:  MOVFF  01,65
095A:  MOVFF  00,64
095E:  RCALL  0324
0960:  MOVFF  03,47
0964:  MOVFF  02,46
0968:  MOVFF  01,45
096C:  MOVFF  00,44
....................    } 
0970:  BRA    097A
....................  
....................    else 
....................       res = 0.0; 
0972:  CLRF   47
0974:  CLRF   46
0976:  CLRF   45
0978:  CLRF   44
....................  
....................    return(res); 
097A:  MOVFF  44,00
097E:  MOVFF  45,01
0982:  MOVFF  46,02
0986:  MOVFF  47,03
098A:  RETURN 0
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
*
1254:  MOVFF  33,5F
1258:  MOVFF  32,5E
125C:  MOVFF  31,5D
1260:  MOVFF  30,5C
1264:  CLRF   x63
1266:  CLRF   x62
1268:  CLRF   x61
126A:  CLRF   x60
126C:  CALL   058E
1270:  BTFSS  FD8.0
1272:  BRA    140A
1274:  MOVFF  37,3B
1278:  MOVFF  36,3A
127C:  MOVFF  35,39
1280:  MOVFF  34,38
1284:  CLRF   3F
1286:  CLRF   3E
1288:  CLRF   3D
128A:  MOVLW  7F
128C:  MOVWF  3C
128E:  RCALL  0D26
1290:  MOVFF  03,3B
1294:  MOVFF  02,3A
1298:  MOVFF  01,39
129C:  MOVFF  00,38
12A0:  MOVFF  03,5F
12A4:  MOVFF  02,5E
12A8:  MOVFF  01,5D
12AC:  MOVFF  00,5C
12B0:  CLRF   x63
12B2:  CLRF   x62
12B4:  CLRF   x61
12B6:  CLRF   x60
12B8:  CALL   058E
12BC:  BTFSS  FD8.2
12BE:  BRA    140A
....................       if(fmod(y, 2) == 0) { 
12C0:  MOVFF  37,3B
12C4:  MOVFF  36,3A
12C8:  MOVFF  35,39
12CC:  MOVFF  34,38
12D0:  CLRF   3F
12D2:  CLRF   3E
12D4:  CLRF   3D
12D6:  MOVLW  80
12D8:  MOVWF  3C
12DA:  RCALL  0D26
12DC:  MOVFF  03,3B
12E0:  MOVFF  02,3A
12E4:  MOVFF  01,39
12E8:  MOVFF  00,38
12EC:  MOVFF  03,5F
12F0:  MOVFF  02,5E
12F4:  MOVFF  01,5D
12F8:  MOVFF  00,5C
12FC:  CLRF   x63
12FE:  CLRF   x62
1300:  CLRF   x61
1302:  CLRF   x60
1304:  CALL   058E
1308:  BNZ   1388
....................          return (exp(log(-x) * y)); 
130A:  MOVFF  30,38
130E:  MOVF   31,W
1310:  XORLW  80
1312:  MOVWF  39
1314:  MOVFF  32,3A
1318:  MOVFF  33,3B
131C:  MOVFF  33,3F
1320:  MOVFF  32,3E
1324:  MOVWF  3D
1326:  MOVFF  30,3C
132A:  CALL   064C
132E:  MOVFF  03,3B
1332:  MOVFF  02,3A
1336:  MOVFF  01,39
133A:  MOVFF  00,38
133E:  MOVFF  03,5F
1342:  MOVFF  02,5E
1346:  MOVFF  01,5D
134A:  MOVFF  00,5C
134E:  MOVFF  37,63
1352:  MOVFF  36,62
1356:  MOVFF  35,61
135A:  MOVFF  34,60
135E:  CALL   00D8
1362:  MOVFF  03,3B
1366:  MOVFF  02,3A
136A:  MOVFF  01,39
136E:  MOVFF  00,38
1372:  MOVFF  03,3F
1376:  MOVFF  02,3E
137A:  MOVFF  01,3D
137E:  MOVFF  00,3C
1382:  RCALL  0E82
1384:  BRA    1526
....................       } else { 
1386:  BRA    1408
....................          return (-exp(log(-x) * y)); 
1388:  MOVFF  30,38
138C:  MOVF   31,W
138E:  XORLW  80
1390:  MOVWF  39
1392:  MOVFF  32,3A
1396:  MOVFF  33,3B
139A:  MOVFF  33,3F
139E:  MOVFF  32,3E
13A2:  MOVWF  3D
13A4:  MOVFF  30,3C
13A8:  CALL   064C
13AC:  MOVFF  03,3B
13B0:  MOVFF  02,3A
13B4:  MOVFF  01,39
13B8:  MOVFF  00,38
13BC:  MOVFF  03,5F
13C0:  MOVFF  02,5E
13C4:  MOVFF  01,5D
13C8:  MOVFF  00,5C
13CC:  MOVFF  37,63
13D0:  MOVFF  36,62
13D4:  MOVFF  35,61
13D8:  MOVFF  34,60
13DC:  CALL   00D8
13E0:  MOVFF  03,3B
13E4:  MOVFF  02,3A
13E8:  MOVFF  01,39
13EC:  MOVFF  00,38
13F0:  MOVFF  03,3F
13F4:  MOVFF  02,3E
13F8:  MOVFF  01,3D
13FC:  MOVFF  00,3C
1400:  RCALL  0E82
1402:  MOVLW  80
1404:  XORWF  01,F
1406:  BRA    1526
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
1408:  BRA    1526
140A:  MOVFF  33,5F
140E:  MOVFF  32,5E
1412:  MOVFF  31,5D
1416:  MOVFF  30,5C
141A:  CLRF   x63
141C:  CLRF   x62
141E:  CLRF   x61
1420:  CLRF   x60
1422:  CALL   058E
1426:  BNC   147E
1428:  MOVFF  37,3B
142C:  MOVFF  36,3A
1430:  MOVFF  35,39
1434:  MOVFF  34,38
1438:  CLRF   3F
143A:  CLRF   3E
143C:  CLRF   3D
143E:  MOVLW  7F
1440:  MOVWF  3C
1442:  RCALL  0D26
1444:  MOVFF  03,3B
1448:  MOVFF  02,3A
144C:  MOVFF  01,39
1450:  MOVFF  00,38
1454:  MOVFF  03,5F
1458:  MOVFF  02,5E
145C:  MOVFF  01,5D
1460:  MOVFF  00,5C
1464:  CLRF   x63
1466:  CLRF   x62
1468:  CLRF   x61
146A:  CLRF   x60
146C:  CALL   058E
1470:  BZ    147E
....................       return 0; 
1472:  CLRF   00
1474:  CLRF   01
1476:  CLRF   02
1478:  CLRF   03
147A:  BRA    1526
....................    } else { 
147C:  BRA    1526
....................       if(x != 0 || 0 >= y) { 
147E:  MOVFF  33,5F
1482:  MOVFF  32,5E
1486:  MOVFF  31,5D
148A:  MOVFF  30,5C
148E:  CLRF   x63
1490:  CLRF   x62
1492:  CLRF   x61
1494:  CLRF   x60
1496:  CALL   058E
149A:  BNZ   14BC
149C:  MOVFF  37,5F
14A0:  MOVFF  36,5E
14A4:  MOVFF  35,5D
14A8:  MOVFF  34,5C
14AC:  CLRF   x63
14AE:  CLRF   x62
14B0:  CLRF   x61
14B2:  CLRF   x60
14B4:  CALL   058E
14B8:  BC    14BC
14BA:  BNZ   1526
....................          return (exp(log(x) * y)); 
14BC:  MOVFF  33,3F
14C0:  MOVFF  32,3E
14C4:  MOVFF  31,3D
14C8:  MOVFF  30,3C
14CC:  CALL   064C
14D0:  MOVFF  03,3B
14D4:  MOVFF  02,3A
14D8:  MOVFF  01,39
14DC:  MOVFF  00,38
14E0:  MOVFF  03,5F
14E4:  MOVFF  02,5E
14E8:  MOVFF  01,5D
14EC:  MOVFF  00,5C
14F0:  MOVFF  37,63
14F4:  MOVFF  36,62
14F8:  MOVFF  35,61
14FC:  MOVFF  34,60
1500:  CALL   00D8
1504:  MOVFF  03,3B
1508:  MOVFF  02,3A
150C:  MOVFF  01,39
1510:  MOVFF  00,38
1514:  MOVFF  03,3F
1518:  MOVFF  02,3E
151C:  MOVFF  01,3D
1520:  MOVFF  00,3C
1524:  RCALL  0E82
....................       } 
....................    } 
1526:  GOTO   16C0 (RETURN)
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #fuses XT,NOWDT,PUT,NOBROWNOUT,NOLVP    // bits de configurao 
.................... #use   delay(clock=20000000)// definir isso direito  
.................... #priority timer0, timer1 // define a prioridade dos timer 
.................... //modo rpido de inicializao das portas 
.................... #use   fast_io(a) 
.................... #use   fast_io(b) 
.................... #use   fast_io(d) 
.................... #use   fast_io(e) 
.................... #byte   porta = 0xf80 // atribui o nome "porta" ao registrador do port 0xf80 
.................... #byte   portb = 0xf81  
.................... #byte   portd = 0xf83 
.................... #byte   porte = 0xf84 
.................... // pinos de entrada 
.................... #bit NTC = porta.0 
.................... #bit DHT11 = porta.1 
.................... #bit POT_SET_TEMP = porta.2 
.................... #bit POT_SET_UMI = porta.3 
.................... #bit BOT_BLK_LTH = portb.0 
.................... #bit BOT_MORE_INF = portb.1 
.................... // pinos de saida 
.................... #bit RELE_LAMP = portb.2 
.................... #bit PIN_IN1_MOTPAS = portb.3 
.................... #bit PIN_IN2_MOTPAS = portb.4 
.................... #bit PIN_IN3_MOTPAS = portb.5 
.................... #bit PIN_IN4_MOTPAS = portb.6 
.................... #bit PIN_COOLER = portb.7 
.................... float ntc_val = 0; 
.................... float rntc = 0; 
.................... float b1=0; 
.................... float c1=0; 
.................... float temp=0; 
.................... const float a = 0.0011303; 
.................... const float b = 0.0002339; 
.................... const double c = 0.00000008863; 
....................  
.................... #int_timer0 
....................  
.................... void interrupcao_ntc (){ 
.................... set_adc_channel(0); //  escolhe o pino analogico para ler  
152A:  MOVLW  00
152C:  MOVWF  01
152E:  MOVF   FC2,W
1530:  ANDLW  C3
1532:  IORWF  01,W
1534:  MOVWF  FC2
.................... delay_us(10); // delay para comear a converso  
1536:  MOVLW  10
1538:  MOVWF  00
153A:  DECFSZ 00,F
153C:  BRA    153A
153E:  NOP   
.................... ntc_val = read_adc(); // le o valor na porta analogica 
1540:  BSF    FC2.1
1542:  BTFSC  FC2.1
1544:  BRA    1542
1546:  MOVF   FC4,W
1548:  CLRF   x61
154A:  MOVWF  x60
154C:  CALL   00A2
1550:  MOVFF  03,1F
1554:  MOVFF  02,1E
1558:  MOVFF  01,1D
155C:  MOVFF  00,1C
.................... ntc_val *=5; //  
1560:  MOVFF  1F,5F
1564:  MOVFF  1E,5E
1568:  MOVFF  1D,5D
156C:  MOVFF  1C,5C
1570:  CLRF   x63
1572:  CLRF   x62
1574:  MOVLW  20
1576:  MOVWF  x61
1578:  MOVLW  81
157A:  MOVWF  x60
157C:  CALL   00D8
1580:  MOVFF  03,1F
1584:  MOVFF  02,1E
1588:  MOVFF  01,1D
158C:  MOVFF  00,1C
.................... ntc_val/=1023; 
1590:  MOVFF  1F,58
1594:  MOVFF  1E,57
1598:  MOVFF  1D,56
159C:  MOVFF  1C,55
15A0:  CLRF   5C
15A2:  MOVLW  C0
15A4:  MOVWF  5B
15A6:  MOVLW  7F
15A8:  MOVWF  5A
15AA:  MOVLW  88
15AC:  MOVWF  59
15AE:  CALL   01CA
15B2:  MOVFF  03,1F
15B6:  MOVFF  02,1E
15BA:  MOVFF  01,1D
15BE:  MOVFF  00,1C
.................... rntc=33000/ntc_val;     
15C2:  CLRF   58
15C4:  MOVLW  E8
15C6:  MOVWF  57
15C8:  CLRF   56
15CA:  MOVLW  8E
15CC:  MOVWF  55
15CE:  MOVFF  1F,5C
15D2:  MOVFF  1E,5B
15D6:  MOVFF  1D,5A
15DA:  MOVFF  1C,59
15DE:  CALL   01CA
15E2:  MOVFF  03,23
15E6:  MOVFF  02,22
15EA:  MOVFF  01,21
15EE:  MOVFF  00,20
....................        rntc=rntc-10000;       
15F2:  BSF    FD8.1
15F4:  MOVFF  23,63
15F8:  MOVFF  22,62
15FC:  MOVFF  21,61
1600:  MOVFF  20,60
1604:  CLRF   x67
1606:  MOVLW  40
1608:  MOVWF  x66
160A:  MOVLW  1C
160C:  MOVWF  x65
160E:  MOVLW  8C
1610:  MOVWF  x64
1612:  CALL   0324
1616:  MOVFF  03,23
161A:  MOVFF  02,22
161E:  MOVFF  01,21
1622:  MOVFF  00,20
....................        b1=log(rntc);           
1626:  MOVFF  23,3F
162A:  MOVFF  22,3E
162E:  MOVFF  21,3D
1632:  MOVFF  20,3C
1636:  CALL   064C
163A:  MOVFF  03,27
163E:  MOVFF  02,26
1642:  MOVFF  01,25
1646:  MOVFF  00,24
....................        b1=b1*b;                
164A:  MOVFF  27,5F
164E:  MOVFF  26,5E
1652:  MOVFF  25,5D
1656:  MOVFF  24,5C
165A:  MOVLW  0E
165C:  MOVWF  x63
165E:  MOVLW  43
1660:  MOVWF  x62
1662:  MOVLW  75
1664:  MOVWF  x61
1666:  MOVLW  72
1668:  MOVWF  x60
166A:  CALL   00D8
166E:  MOVFF  03,27
1672:  MOVFF  02,26
1676:  MOVFF  01,25
167A:  MOVFF  00,24
....................        c1=log(rntc);           
167E:  MOVFF  23,3F
1682:  MOVFF  22,3E
1686:  MOVFF  21,3D
168A:  MOVFF  20,3C
168E:  CALL   064C
1692:  MOVFF  03,2B
1696:  MOVFF  02,2A
169A:  MOVFF  01,29
169E:  MOVFF  00,28
....................        c1=pow(c1,3);           
16A2:  MOVFF  2B,33
16A6:  MOVFF  2A,32
16AA:  MOVFF  29,31
16AE:  MOVFF  28,30
16B2:  CLRF   37
16B4:  CLRF   36
16B6:  MOVLW  40
16B8:  MOVWF  35
16BA:  MOVLW  80
16BC:  MOVWF  34
16BE:  BRA    1254
16C0:  MOVFF  03,2B
16C4:  MOVFF  02,2A
16C8:  MOVFF  01,29
16CC:  MOVFF  00,28
....................        c1=c1*c;                
16D0:  MOVFF  2B,5F
16D4:  MOVFF  2A,5E
16D8:  MOVFF  29,5D
16DC:  MOVFF  28,5C
16E0:  MOVLW  DC
16E2:  MOVWF  x63
16E4:  MOVLW  54
16E6:  MOVWF  x62
16E8:  MOVLW  3E
16EA:  MOVWF  x61
16EC:  MOVLW  67
16EE:  MOVWF  x60
16F0:  CALL   00D8
16F4:  MOVFF  03,2B
16F8:  MOVFF  02,2A
16FC:  MOVFF  01,29
1700:  MOVFF  00,28
....................        temp=a+b1+c1;           
1704:  BCF    FD8.1
1706:  MOVLW  93
1708:  MOVWF  x63
170A:  MOVLW  26
170C:  MOVWF  x62
170E:  MOVLW  14
1710:  MOVWF  x61
1712:  MOVLW  75
1714:  MOVWF  x60
1716:  MOVFF  27,67
171A:  MOVFF  26,66
171E:  MOVFF  25,65
1722:  MOVFF  24,64
1726:  CALL   0324
172A:  MOVFF  03,33
172E:  MOVFF  02,32
1732:  MOVFF  01,31
1736:  MOVFF  00,30
173A:  BCF    FD8.1
173C:  MOVFF  03,63
1740:  MOVFF  02,62
1744:  MOVFF  01,61
1748:  MOVFF  00,60
174C:  MOVFF  2B,67
1750:  MOVFF  2A,66
1754:  MOVFF  29,65
1758:  MOVFF  28,64
175C:  CALL   0324
1760:  MOVFF  03,2F
1764:  MOVFF  02,2E
1768:  MOVFF  01,2D
176C:  MOVFF  00,2C
....................        temp=1/temp;            
1770:  CLRF   58
1772:  CLRF   57
1774:  CLRF   56
1776:  MOVLW  7F
1778:  MOVWF  55
177A:  MOVFF  2F,5C
177E:  MOVFF  2E,5B
1782:  MOVFF  2D,5A
1786:  MOVFF  2C,59
178A:  CALL   01CA
178E:  MOVFF  03,2F
1792:  MOVFF  02,2E
1796:  MOVFF  01,2D
179A:  MOVFF  00,2C
....................        temp=temp-273.15; 
179E:  BSF    FD8.1
17A0:  MOVFF  2F,63
17A4:  MOVFF  2E,62
17A8:  MOVFF  2D,61
17AC:  MOVFF  2C,60
17B0:  MOVLW  33
17B2:  MOVWF  x67
17B4:  MOVLW  93
17B6:  MOVWF  x66
17B8:  MOVLW  08
17BA:  MOVWF  x65
17BC:  MOVLW  87
17BE:  MOVWF  x64
17C0:  CALL   0324
17C4:  MOVFF  03,2F
17C8:  MOVFF  02,2E
17CC:  MOVFF  01,2D
17D0:  MOVFF  00,2C
....................  
.................... // colocar aqui o codigo para obter o valor da temperatura 
.................... /// temos que amostrar a temperatura de tempos em tempos 
.................... // calculo do do estouro do timer 2 
.................... // verificar a temp a cada 30 segundos 
....................  
.................... } 
17D4:  BCF    FF2.2
17D6:  GOTO   0060
.................... #int_timer1 
.................... void interrupcao_dht11 (){ 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... // colcoar aqui o codigo para obter o valor da umidade 
.................... // amostrar a umidade a cada 30 min 
.................... // calculo do estouro do timer 1 
....................  
....................  
17DA:  BCF    F9E.0
17DC:  GOTO   0060
.................... } 
....................  
....................  
....................  
.................... void main (void){ 
17E0:  CLRF   FF8
17E2:  BCF    FD0.7
17E4:  BSF    07.7
17E6:  CLRF   1F
17E8:  CLRF   1E
17EA:  CLRF   1D
17EC:  CLRF   1C
17EE:  CLRF   23
17F0:  CLRF   22
17F2:  CLRF   21
17F4:  CLRF   20
17F6:  CLRF   27
17F8:  CLRF   26
17FA:  CLRF   25
17FC:  CLRF   24
17FE:  CLRF   2B
1800:  CLRF   2A
1802:  CLRF   29
1804:  CLRF   28
1806:  CLRF   2F
1808:  CLRF   2E
180A:  CLRF   2D
180C:  CLRF   2C
180E:  MOVF   FC1,W
1810:  ANDLW  C0
1812:  IORLW  0F
1814:  MOVWF  FC1
1816:  MOVLW  07
1818:  MOVWF  FB4
181A:  CLRF   16
181C:  CLRF   17
.................... setup_adc(  ADC_CLOCK_INTERNAL  ); //  configura o clock utilizado para o conversor ad 
181E:  MOVF   FC0,W
1820:  ANDLW  C0
1822:  IORLW  07
1824:  MOVWF  FC0
1826:  BCF    FC0.7
1828:  BSF    FC2.0
.................... setup_adc_ports( AN0_TO_AN3 ); 
182A:  MOVF   FC1,W
182C:  ANDLW  C0
182E:  IORLW  0B
1830:  MOVWF  FC1
.................... //set_tris_a(0b00001111); // verificar se pinos analogicos necessitam de definio de tris 
.................... set_tris_b(0b11000000);  // define os pinos RB0 E RB1 como entrada e os demais como saida 
1832:  MOVLW  C0
1834:  MOVWF  F93
.................... set_tris_b(0b11000000); 
1836:  MOVWF  F93
.................... set_tris_d(0b00000000); 
1838:  MOVLW  00
183A:  MOVWF  F95
.................... set_tris_e(0b00000100); 
183C:  MOVLW  04
183E:  MOVWF  F96
....................  // CONFIGURAO DO TIMER 0 E TIMER 1 P/ INTERRUPO 
....................    /* setup_timer_0 (RTCC_INTERNAL | RTCC_8_BIT | RTCC_DIV_64);   ISSO  SO UM ESCOPO CONFIGURAR ISSO DA FORMA ADEQUADA  
....................     setup_timer_1 (T1_EXTERNAL | T1_DIV_BY_2); 
....................     enable_interrupts(GLOBAL);//chave principal das interrupes 
....................     enable_interrupts(int_timer0); // interrupo do TIMER 0*/ 
....................  
....................  
....................   while(true){ 
1840:  BRA    1840
....................    
....................    
....................    
....................    
....................    
....................   // take the loop here 
....................    
....................    
....................    
....................    
....................    
....................    
....................    
....................    
....................    
....................   } 
....................    
....................    
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... } 
1842:  SLEEP 

Configuration Fuses:
   Word  1: C03F   PLL12 CPUDIV4 USBDIV XT FCMEN IESO
   Word  2: 1E38   PUT NOBROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
