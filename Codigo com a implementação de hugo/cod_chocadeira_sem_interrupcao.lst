CCS PCH C Compiler, Version 5.015, 5967               28-jun-17 19:55

               Filename:   C:\Users\henri\Documents\GitHub\Projeto-chocadeira\Codigo com a implementação de hugo\cod_chocadeira_sem_interrupcao.lst

               ROM used:   9056 bytes (28%)
                           Largest free fragment is 23712
               RAM used:   84 (4%) at main() level
                           148 (7%) worst case
               Stack used: 6 locations
               Stack size: 31

*
0000:  GOTO   21D6
....................  
.................... #INCLUDE<18F4550.h>//   Inclui a biblioteca resposável por estabelecer os parametros do pic utilizado no projeto 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
0004:  DATA 43,4F
0006:  DATA 4E,46
0008:  DATA 49,47
000A:  DATA 55,52
000C:  DATA 41,43
000E:  DATA 41,4F
0010:  DATA 00,00
0012:  DATA 49,4E
0014:  DATA 43,55
0016:  DATA 42,41
0018:  DATA 44,4F
001A:  DATA 52,41
001C:  DATA 00,00
001E:  DATA 43,4F
0020:  DATA 4E,46
0022:  DATA 49,47
0024:  DATA 55,52
0026:  DATA 41,43
0028:  DATA 41,4F
002A:  DATA 00,00
002C:  DATA 53,45
002E:  DATA 54,20
0030:  DATA 54,45
0032:  DATA 4D,50
0034:  DATA 3A,20
0036:  DATA 25,2E
0038:  DATA 31,66
003A:  DATA 20,20
003C:  DATA 20,20
003E:  DATA 20,20
0040:  DATA 20,00
0042:  DATA 43,4F
0044:  DATA 4E,46
0046:  DATA 49,47
0048:  DATA 55,52
004A:  DATA 41,43
004C:  DATA 41,4F
004E:  DATA 00,00
0050:  DATA 53,45
0052:  DATA 54,20
0054:  DATA 55,4D
0056:  DATA 49,3A
0058:  DATA 20,25
005A:  DATA 2E,31
005C:  DATA 66,20
005E:  DATA 20,20
0060:  DATA 20,20
0062:  DATA 20,00
0064:  DATA 53,45
0066:  DATA 54,20
0068:  DATA 54,45
006A:  DATA 4D,50
006C:  DATA 3A,20
006E:  DATA 20,25
0070:  DATA 2E,31
0072:  DATA 66,20
0074:  DATA 20,20
0076:  DATA 20,20
0078:  DATA 20,20
007A:  DATA 20,00
007C:  DATA 53,45
007E:  DATA 54,20
0080:  DATA 55,4D
0082:  DATA 49,3A
0084:  DATA 20,20
0086:  DATA 20,25
0088:  DATA 2E,31
008A:  DATA 66,20
008C:  DATA 20,20
008E:  DATA 20,20
0090:  DATA 20,20
0092:  DATA 00,00
0094:  DATA 46,49
0096:  DATA 4D,20
0098:  DATA 44,41
009A:  DATA 00,00
009C:  DATA 43,4F
009E:  DATA 4E,46
00A0:  DATA 49,47
00A2:  DATA 55,52
00A4:  DATA 41,43
00A6:  DATA 41,4F
00A8:  DATA 00,00
00AA:  DATA 41,70
00AC:  DATA 65,72
00AE:  DATA 74,65
00B0:  DATA 20,6F
00B2:  DATA 20,62
00B4:  DATA 6F,74
00B6:  DATA 61,6F
00B8:  DATA 00,00
00BA:  DATA 49,4E
00BC:  DATA 49,43
00BE:  DATA 49,41
00C0:  DATA 52,00
00C2:  DATA 4D,45
00C4:  DATA 58,45
00C6:  DATA 4E,44
00C8:  DATA 4F,00
*
0154:  MOVLW  8E
0156:  MOVWF  00
0158:  MOVFF  85,01
015C:  MOVFF  84,02
0160:  CLRF   03
0162:  MOVF   01,F
0164:  BNZ   0178
0166:  MOVFF  02,01
016A:  CLRF   02
016C:  MOVLW  08
016E:  SUBWF  00,F
0170:  MOVF   01,F
0172:  BNZ   0178
0174:  CLRF   00
0176:  BRA    0188
0178:  BCF    FD8.0
017A:  BTFSC  01.7
017C:  BRA    0186
017E:  RLCF   02,F
0180:  RLCF   01,F
0182:  DECF   00,F
0184:  BRA    0178
0186:  BCF    01.7
0188:  RETURN 0
018A:  MOVF   x80,W
018C:  BTFSC  FD8.2
018E:  BRA    0272
0190:  MOVWF  00
0192:  MOVF   x84,W
0194:  BTFSC  FD8.2
0196:  BRA    0272
0198:  ADDWF  00,F
019A:  BNC   01A4
019C:  MOVLW  81
019E:  ADDWF  00,F
01A0:  BC    0272
01A2:  BRA    01AC
01A4:  MOVLW  7F
01A6:  SUBWF  00,F
01A8:  BNC   0272
01AA:  BZ    0272
01AC:  MOVFF  81,88
01B0:  MOVF   x85,W
01B2:  XORWF  x88,F
01B4:  BSF    x81.7
01B6:  BSF    x85.7
01B8:  MOVF   x83,W
01BA:  MULWF  x87
01BC:  MOVFF  FF4,8A
01C0:  MOVF   x82,W
01C2:  MULWF  x86
01C4:  MOVFF  FF4,03
01C8:  MOVFF  FF3,89
01CC:  MULWF  x87
01CE:  MOVF   FF3,W
01D0:  ADDWF  x8A,F
01D2:  MOVF   FF4,W
01D4:  ADDWFC x89,F
01D6:  MOVLW  00
01D8:  ADDWFC 03,F
01DA:  MOVF   x83,W
01DC:  MULWF  x86
01DE:  MOVF   FF3,W
01E0:  ADDWF  x8A,F
01E2:  MOVF   FF4,W
01E4:  ADDWFC x89,F
01E6:  MOVLW  00
01E8:  CLRF   02
01EA:  ADDWFC 03,F
01EC:  ADDWFC 02,F
01EE:  MOVF   x81,W
01F0:  MULWF  x87
01F2:  MOVF   FF3,W
01F4:  ADDWF  x89,F
01F6:  MOVF   FF4,W
01F8:  ADDWFC 03,F
01FA:  MOVLW  00
01FC:  ADDWFC 02,F
01FE:  MOVF   x81,W
0200:  MULWF  x86
0202:  MOVF   FF3,W
0204:  ADDWF  03,F
0206:  MOVF   FF4,W
0208:  ADDWFC 02,F
020A:  MOVLW  00
020C:  CLRF   01
020E:  ADDWFC 01,F
0210:  MOVF   x83,W
0212:  MULWF  x85
0214:  MOVF   FF3,W
0216:  ADDWF  x89,F
0218:  MOVF   FF4,W
021A:  ADDWFC 03,F
021C:  MOVLW  00
021E:  ADDWFC 02,F
0220:  ADDWFC 01,F
0222:  MOVF   x82,W
0224:  MULWF  x85
0226:  MOVF   FF3,W
0228:  ADDWF  03,F
022A:  MOVF   FF4,W
022C:  ADDWFC 02,F
022E:  MOVLW  00
0230:  ADDWFC 01,F
0232:  MOVF   x81,W
0234:  MULWF  x85
0236:  MOVF   FF3,W
0238:  ADDWF  02,F
023A:  MOVF   FF4,W
023C:  ADDWFC 01,F
023E:  INCF   00,F
0240:  BTFSC  01.7
0242:  BRA    024E
0244:  RLCF   x89,F
0246:  RLCF   03,F
0248:  RLCF   02,F
024A:  RLCF   01,F
024C:  DECF   00,F
024E:  MOVLW  00
0250:  BTFSS  x89.7
0252:  BRA    0268
0254:  INCF   03,F
0256:  ADDWFC 02,F
0258:  ADDWFC 01,F
025A:  MOVF   01,W
025C:  BNZ   0268
025E:  MOVF   02,W
0260:  BNZ   0268
0262:  MOVF   03,W
0264:  BNZ   0268
0266:  INCF   00,F
0268:  BTFSC  x88.7
026A:  BSF    01.7
026C:  BTFSS  x88.7
026E:  BCF    01.7
0270:  BRA    027A
0272:  CLRF   00
0274:  CLRF   01
0276:  CLRF   02
0278:  CLRF   03
027A:  RETURN 0
027C:  MOVF   x79,W
027E:  BTFSC  FD8.2
0280:  BRA    03CC
0282:  MOVWF  x85
0284:  MOVF   x7D,W
0286:  BTFSC  FD8.2
0288:  BRA    03CC
028A:  SUBWF  x85,F
028C:  BNC   0298
028E:  MOVLW  7F
0290:  ADDWF  x85,F
0292:  BTFSC  FD8.0
0294:  BRA    03CC
0296:  BRA    02A4
0298:  MOVLW  81
029A:  SUBWF  x85,F
029C:  BTFSS  FD8.0
029E:  BRA    03CC
02A0:  BTFSC  FD8.2
02A2:  BRA    03CC
02A4:  MOVFF  85,00
02A8:  CLRF   01
02AA:  CLRF   02
02AC:  CLRF   03
02AE:  CLRF   x84
02B0:  MOVFF  7A,83
02B4:  BSF    x83.7
02B6:  MOVFF  7B,82
02BA:  MOVFF  7C,81
02BE:  MOVLW  19
02C0:  MOVWF  x85
02C2:  MOVF   x80,W
02C4:  SUBWF  x81,F
02C6:  BC    02E2
02C8:  MOVLW  01
02CA:  SUBWF  x82,F
02CC:  BC    02E2
02CE:  SUBWF  x83,F
02D0:  BC    02E2
02D2:  SUBWF  x84,F
02D4:  BC    02E2
02D6:  INCF   x84,F
02D8:  INCF   x83,F
02DA:  INCF   x82,F
02DC:  MOVF   x80,W
02DE:  ADDWF  x81,F
02E0:  BRA    0332
02E2:  MOVF   x7F,W
02E4:  SUBWF  x82,F
02E6:  BC    030C
02E8:  MOVLW  01
02EA:  SUBWF  x83,F
02EC:  BC    030C
02EE:  SUBWF  x84,F
02F0:  BC    030C
02F2:  INCF   x84,F
02F4:  INCF   x83,F
02F6:  MOVF   x7F,W
02F8:  ADDWF  x82,F
02FA:  MOVF   x80,W
02FC:  ADDWF  x81,F
02FE:  BNC   0332
0300:  INCF   x82,F
0302:  BNZ   0332
0304:  INCF   x83,F
0306:  BNZ   0332
0308:  INCF   x84,F
030A:  BRA    0332
030C:  MOVF   x7E,W
030E:  IORLW  80
0310:  SUBWF  x83,F
0312:  BC    0330
0314:  MOVLW  01
0316:  SUBWF  x84,F
0318:  BC    0330
031A:  INCF   x84,F
031C:  MOVF   x7E,W
031E:  IORLW  80
0320:  ADDWF  x83,F
0322:  MOVF   x7F,W
0324:  ADDWF  x82,F
0326:  BNC   02FA
0328:  INCF   x83,F
032A:  BNZ   02FA
032C:  INCF   x84,F
032E:  BRA    02FA
0330:  BSF    03.0
0332:  DECFSZ x85,F
0334:  BRA    0338
0336:  BRA    034E
0338:  BCF    FD8.0
033A:  RLCF   x81,F
033C:  RLCF   x82,F
033E:  RLCF   x83,F
0340:  RLCF   x84,F
0342:  BCF    FD8.0
0344:  RLCF   03,F
0346:  RLCF   02,F
0348:  RLCF   01,F
034A:  RLCF   x86,F
034C:  BRA    02C2
034E:  BTFSS  x86.0
0350:  BRA    035E
0352:  BCF    FD8.0
0354:  RRCF   01,F
0356:  RRCF   02,F
0358:  RRCF   03,F
035A:  RRCF   x86,F
035C:  BRA    0362
035E:  DECF   00,F
0360:  BZ    03CC
0362:  BTFSC  x86.7
0364:  BRA    03A2
0366:  BCF    FD8.0
0368:  RLCF   x81,F
036A:  RLCF   x82,F
036C:  RLCF   x83,F
036E:  RLCF   x84,F
0370:  MOVF   x80,W
0372:  SUBWF  x81,F
0374:  BC    0384
0376:  MOVLW  01
0378:  SUBWF  x82,F
037A:  BC    0384
037C:  SUBWF  x83,F
037E:  BC    0384
0380:  SUBWF  x84,F
0382:  BNC   03B8
0384:  MOVF   x7F,W
0386:  SUBWF  x82,F
0388:  BC    0394
038A:  MOVLW  01
038C:  SUBWF  x83,F
038E:  BC    0394
0390:  SUBWF  x84,F
0392:  BNC   03B8
0394:  MOVF   x7E,W
0396:  IORLW  80
0398:  SUBWF  x83,F
039A:  BC    03A2
039C:  MOVLW  01
039E:  SUBWF  x84,F
03A0:  BNC   03B8
03A2:  INCF   03,F
03A4:  BNZ   03B8
03A6:  INCF   02,F
03A8:  BNZ   03B8
03AA:  INCF   01,F
03AC:  BNZ   03B8
03AE:  INCF   00,F
03B0:  BZ    03CC
03B2:  RRCF   01,F
03B4:  RRCF   02,F
03B6:  RRCF   03,F
03B8:  MOVFF  7A,85
03BC:  MOVF   x7E,W
03BE:  XORWF  x85,F
03C0:  BTFSS  x85.7
03C2:  BRA    03C8
03C4:  BSF    01.7
03C6:  BRA    03D4
03C8:  BCF    01.7
03CA:  BRA    03D4
03CC:  CLRF   00
03CE:  CLRF   01
03D0:  CLRF   02
03D2:  CLRF   03
03D4:  RETURN 0
03D6:  MOVLW  80
03D8:  BTFSC  FD8.1
03DA:  XORWF  x89,F
03DC:  CLRF   x8E
03DE:  CLRF   x8F
03E0:  MOVFF  85,8D
03E4:  MOVF   x89,W
03E6:  XORWF  x8D,F
03E8:  MOVF   x84,W
03EA:  BTFSC  FD8.2
03EC:  BRA    05A6
03EE:  MOVWF  x8C
03F0:  MOVWF  00
03F2:  MOVF   x88,W
03F4:  BTFSC  FD8.2
03F6:  BRA    05B8
03F8:  SUBWF  x8C,F
03FA:  BTFSC  FD8.2
03FC:  BRA    0500
03FE:  BNC   047A
0400:  MOVFF  89,92
0404:  BSF    x92.7
0406:  MOVFF  8A,91
040A:  MOVFF  8B,90
040E:  CLRF   x8F
0410:  BCF    FD8.0
0412:  RRCF   x92,F
0414:  RRCF   x91,F
0416:  RRCF   x90,F
0418:  RRCF   x8F,F
041A:  DECFSZ x8C,F
041C:  BRA    040E
041E:  BTFSS  x8D.7
0420:  BRA    0428
0422:  BSF    x8E.0
0424:  BRA    05E0
0426:  BCF    x8E.0
0428:  BCF    x8C.0
042A:  BSF    x8E.4
042C:  CLRF   FEA
042E:  MOVLW  87
0430:  MOVWF  FE9
0432:  BRA    0606
0434:  BCF    x8E.4
0436:  BTFSC  x8D.7
0438:  BRA    044E
043A:  BTFSS  x8C.0
043C:  BRA    0464
043E:  RRCF   x92,F
0440:  RRCF   x91,F
0442:  RRCF   x90,F
0444:  RRCF   x8F,F
0446:  INCF   00,F
0448:  BTFSC  FD8.2
044A:  BRA    05D6
044C:  BRA    0464
044E:  BTFSC  x92.7
0450:  BRA    046A
0452:  BCF    FD8.0
0454:  RLCF   x8F,F
0456:  RLCF   x90,F
0458:  RLCF   x91,F
045A:  RLCF   x92,F
045C:  DECF   00,F
045E:  BTFSC  FD8.2
0460:  BRA    05D6
0462:  BRA    044E
0464:  BSF    x8E.6
0466:  BRA    053E
0468:  BCF    x8E.6
046A:  MOVFF  85,8D
046E:  BTFSS  x85.7
0470:  BRA    0476
0472:  BSF    x92.7
0474:  BRA    05C8
0476:  BCF    x92.7
0478:  BRA    05C8
047A:  MOVFF  88,8C
047E:  MOVFF  88,00
0482:  MOVF   x84,W
0484:  SUBWF  x8C,F
0486:  MOVFF  85,92
048A:  BSF    x92.7
048C:  MOVFF  86,91
0490:  MOVFF  87,90
0494:  CLRF   x8F
0496:  BCF    FD8.0
0498:  RRCF   x92,F
049A:  RRCF   x91,F
049C:  RRCF   x90,F
049E:  RRCF   x8F,F
04A0:  DECFSZ x8C,F
04A2:  BRA    0494
04A4:  BTFSS  x8D.7
04A6:  BRA    04AE
04A8:  BSF    x8E.1
04AA:  BRA    05E0
04AC:  BCF    x8E.1
04AE:  BCF    x8C.0
04B0:  BSF    x8E.5
04B2:  CLRF   FEA
04B4:  MOVLW  8B
04B6:  MOVWF  FE9
04B8:  BRA    0606
04BA:  BCF    x8E.5
04BC:  BTFSC  x8D.7
04BE:  BRA    04D4
04C0:  BTFSS  x8C.0
04C2:  BRA    04EA
04C4:  RRCF   x92,F
04C6:  RRCF   x91,F
04C8:  RRCF   x90,F
04CA:  RRCF   x8F,F
04CC:  INCF   00,F
04CE:  BTFSC  FD8.2
04D0:  BRA    05D6
04D2:  BRA    04EA
04D4:  BTFSC  x92.7
04D6:  BRA    04F0
04D8:  BCF    FD8.0
04DA:  RLCF   x8F,F
04DC:  RLCF   x90,F
04DE:  RLCF   x91,F
04E0:  RLCF   x92,F
04E2:  DECF   00,F
04E4:  BTFSC  FD8.2
04E6:  BRA    05D6
04E8:  BRA    04D4
04EA:  BSF    x8E.7
04EC:  BRA    053E
04EE:  BCF    x8E.7
04F0:  MOVFF  89,8D
04F4:  BTFSS  x89.7
04F6:  BRA    04FC
04F8:  BSF    x92.7
04FA:  BRA    05C8
04FC:  BCF    x92.7
04FE:  BRA    05C8
0500:  MOVFF  89,92
0504:  BSF    x92.7
0506:  MOVFF  8A,91
050A:  MOVFF  8B,90
050E:  BTFSS  x8D.7
0510:  BRA    051A
0512:  BCF    x92.7
0514:  BSF    x8E.2
0516:  BRA    05E0
0518:  BCF    x8E.2
051A:  CLRF   x8F
051C:  BCF    x8C.0
051E:  CLRF   FEA
0520:  MOVLW  87
0522:  MOVWF  FE9
0524:  BRA    0606
0526:  BTFSC  x8D.7
0528:  BRA    0562
052A:  MOVFF  85,8D
052E:  BTFSS  x8C.0
0530:  BRA    053E
0532:  RRCF   x92,F
0534:  RRCF   x91,F
0536:  RRCF   x90,F
0538:  RRCF   x8F,F
053A:  INCF   00,F
053C:  BZ    05D6
053E:  BTFSS  x8F.7
0540:  BRA    0558
0542:  INCF   x90,F
0544:  BNZ   0558
0546:  INCF   x91,F
0548:  BNZ   0558
054A:  INCF   x92,F
054C:  BNZ   0558
054E:  RRCF   x92,F
0550:  RRCF   x91,F
0552:  RRCF   x90,F
0554:  INCF   00,F
0556:  BZ    05D6
0558:  BTFSC  x8E.6
055A:  BRA    0468
055C:  BTFSC  x8E.7
055E:  BRA    04EE
0560:  BRA    059A
0562:  MOVLW  80
0564:  XORWF  x92,F
0566:  BTFSS  x92.7
0568:  BRA    0572
056A:  BRA    05E0
056C:  MOVFF  89,8D
0570:  BRA    0586
0572:  MOVFF  85,8D
0576:  MOVF   x92,F
0578:  BNZ   0586
057A:  MOVF   x91,F
057C:  BNZ   0586
057E:  MOVF   x90,F
0580:  BNZ   0586
0582:  CLRF   00
0584:  BRA    05C8
0586:  BTFSC  x92.7
0588:  BRA    059A
058A:  BCF    FD8.0
058C:  RLCF   x8F,F
058E:  RLCF   x90,F
0590:  RLCF   x91,F
0592:  RLCF   x92,F
0594:  DECFSZ 00,F
0596:  BRA    0586
0598:  BRA    05D6
059A:  BTFSS  x8D.7
059C:  BRA    05A2
059E:  BSF    x92.7
05A0:  BRA    05C8
05A2:  BCF    x92.7
05A4:  BRA    05C8
05A6:  MOVFF  88,00
05AA:  MOVFF  89,92
05AE:  MOVFF  8A,91
05B2:  MOVFF  8B,90
05B6:  BRA    05C8
05B8:  MOVFF  84,00
05BC:  MOVFF  85,92
05C0:  MOVFF  86,91
05C4:  MOVFF  87,90
05C8:  MOVFF  92,01
05CC:  MOVFF  91,02
05D0:  MOVFF  90,03
05D4:  BRA    063E
05D6:  CLRF   00
05D8:  CLRF   01
05DA:  CLRF   02
05DC:  CLRF   03
05DE:  BRA    063E
05E0:  CLRF   x8F
05E2:  COMF   x90,F
05E4:  COMF   x91,F
05E6:  COMF   x92,F
05E8:  COMF   x8F,F
05EA:  INCF   x8F,F
05EC:  BNZ   05F8
05EE:  INCF   x90,F
05F0:  BNZ   05F8
05F2:  INCF   x91,F
05F4:  BNZ   05F8
05F6:  INCF   x92,F
05F8:  BTFSC  x8E.0
05FA:  BRA    0426
05FC:  BTFSC  x8E.1
05FE:  BRA    04AC
0600:  BTFSC  x8E.2
0602:  BRA    0518
0604:  BRA    056C
0606:  MOVF   FEF,W
0608:  ADDWF  x90,F
060A:  BNC   0616
060C:  INCF   x91,F
060E:  BNZ   0616
0610:  INCF   x92,F
0612:  BTFSC  FD8.2
0614:  BSF    x8C.0
0616:  MOVF   FED,F
0618:  MOVF   FEF,W
061A:  ADDWF  x91,F
061C:  BNC   0624
061E:  INCF   x92,F
0620:  BTFSC  FD8.2
0622:  BSF    x8C.0
0624:  MOVF   FED,F
0626:  MOVF   FEF,W
0628:  BTFSC  FEF.7
062A:  BRA    062E
062C:  XORLW  80
062E:  ADDWF  x92,F
0630:  BTFSC  FD8.0
0632:  BSF    x8C.0
0634:  BTFSC  x8E.4
0636:  BRA    0434
0638:  BTFSC  x8E.5
063A:  BRA    04BA
063C:  BRA    0526
063E:  RETURN 0
0640:  MOVFF  81,88
0644:  MOVF   x85,W
0646:  XORWF  x88,F
0648:  BTFSS  x88.7
064A:  BRA    0656
064C:  BCF    FD8.2
064E:  BCF    FD8.0
0650:  BTFSC  x81.7
0652:  BSF    FD8.0
0654:  BRA    06B4
0656:  MOVFF  81,88
065A:  MOVFF  84,89
065E:  MOVF   x80,W
0660:  SUBWF  x89,F
0662:  BZ    0670
0664:  BTFSS  x88.7
0666:  BRA    06B4
0668:  MOVF   FD8,W
066A:  XORLW  01
066C:  MOVWF  FD8
066E:  BRA    06B4
0670:  MOVFF  85,89
0674:  MOVF   x81,W
0676:  SUBWF  x89,F
0678:  BZ    0686
067A:  BTFSS  x88.7
067C:  BRA    06B4
067E:  MOVF   FD8,W
0680:  XORLW  01
0682:  MOVWF  FD8
0684:  BRA    06B4
0686:  MOVFF  86,89
068A:  MOVF   x82,W
068C:  SUBWF  x89,F
068E:  BZ    069C
0690:  BTFSS  x88.7
0692:  BRA    06B4
0694:  MOVF   FD8,W
0696:  XORLW  01
0698:  MOVWF  FD8
069A:  BRA    06B4
069C:  MOVFF  87,89
06A0:  MOVF   x83,W
06A2:  SUBWF  x89,F
06A4:  BZ    06B2
06A6:  BTFSS  x88.7
06A8:  BRA    06B4
06AA:  MOVF   FD8,W
06AC:  XORLW  01
06AE:  MOVWF  FD8
06B0:  BRA    06B4
06B2:  BCF    FD8.0
06B4:  RETURN 0
06B6:  MOVLW  8E
06B8:  MOVWF  00
06BA:  MOVFF  77,01
06BE:  MOVFF  76,02
06C2:  CLRF   03
06C4:  BTFSS  x77.7
06C6:  BRA    06D2
06C8:  COMF   01,F
06CA:  COMF   02,F
06CC:  INCF   02,F
06CE:  BNZ   06D2
06D0:  INCF   01,F
06D2:  MOVF   01,F
06D4:  BNZ   06E8
06D6:  MOVFF  02,01
06DA:  CLRF   02
06DC:  MOVLW  08
06DE:  SUBWF  00,F
06E0:  MOVF   01,F
06E2:  BNZ   06E8
06E4:  CLRF   00
06E6:  BRA    06FC
06E8:  BCF    FD8.0
06EA:  BTFSC  01.7
06EC:  BRA    06F6
06EE:  RLCF   02,F
06F0:  RLCF   01,F
06F2:  DECF   00,F
06F4:  BRA    06E8
06F6:  BTFSC  x77.7
06F8:  BRA    06FC
06FA:  BCF    01.7
06FC:  RETURN 0
*
0A3E:  MOVLW  8E
0A40:  MOVWF  00
0A42:  MOVF   x80,W
0A44:  SUBWF  00,F
0A46:  MOVFF  81,02
0A4A:  MOVFF  82,01
0A4E:  BSF    02.7
0A50:  MOVF   00,F
0A52:  BZ    0A66
0A54:  BCF    FD8.0
0A56:  MOVF   02,F
0A58:  BNZ   0A5E
0A5A:  MOVF   01,F
0A5C:  BZ    0A66
0A5E:  RRCF   02,F
0A60:  RRCF   01,F
0A62:  DECFSZ 00,F
0A64:  BRA    0A54
0A66:  BTFSS  x81.7
0A68:  BRA    0A74
0A6A:  COMF   01,F
0A6C:  COMF   02,F
0A6E:  INCF   01,F
0A70:  BTFSC  FD8.2
0A72:  INCF   02,F
0A74:  RETURN 0
*
1990:  MOVF   55,W
1992:  CLRF   01
1994:  SUBWF  54,W
1996:  BC    199E
1998:  MOVFF  54,00
199C:  BRA    19B6
199E:  CLRF   00
19A0:  MOVLW  08
19A2:  MOVWF  56
19A4:  RLCF   54,F
19A6:  RLCF   00,F
19A8:  MOVF   55,W
19AA:  SUBWF  00,W
19AC:  BTFSC  FD8.0
19AE:  MOVWF  00
19B0:  RLCF   01,F
19B2:  DECFSZ 56,F
19B4:  BRA    19A4
19B6:  RETURN 0
*
1A44:  TBLRD*+
1A46:  MOVF   FF5,F
1A48:  BZ    1A62
1A4A:  MOVFF  FF6,54
1A4E:  MOVFF  FF7,55
1A52:  MOVFF  FF5,61
1A56:  RCALL  1A28
1A58:  MOVFF  54,FF6
1A5C:  MOVFF  55,FF7
1A60:  BRA    1A44
1A62:  RETURN 0
*
1BBE:  TBLRD*+
1BC0:  MOVFF  FF6,55
1BC4:  MOVFF  FF7,56
1BC8:  MOVFF  FF5,61
1BCC:  RCALL  1A28
1BCE:  MOVFF  55,FF6
1BD2:  MOVFF  56,FF7
1BD6:  DECFSZ 54,F
1BD8:  BRA    1BBE
1BDA:  RETURN 0
1BDC:  MOVF   x61,W
1BDE:  SUBLW  B6
1BE0:  MOVWF  x61
1BE2:  CLRF   03
1BE4:  MOVFF  62,65
1BE8:  BSF    x62.7
1BEA:  BCF    FD8.0
1BEC:  RRCF   x62,F
1BEE:  RRCF   x63,F
1BF0:  RRCF   x64,F
1BF2:  RRCF   03,F
1BF4:  RRCF   02,F
1BF6:  RRCF   01,F
1BF8:  RRCF   00,F
1BFA:  DECFSZ x61,F
1BFC:  BRA    1BEA
1BFE:  BTFSS  x65.7
1C00:  BRA    1C18
1C02:  COMF   00,F
1C04:  COMF   01,F
1C06:  COMF   02,F
1C08:  COMF   03,F
1C0A:  INCF   00,F
1C0C:  BTFSC  FD8.2
1C0E:  INCF   01,F
1C10:  BTFSC  FD8.2
1C12:  INCF   02,F
1C14:  BTFSC  FD8.2
1C16:  INCF   03,F
1C18:  GOTO   1CFA (RETURN)
1C1C:  BTFSC  FD8.1
1C1E:  BRA    1C26
1C20:  CLRF   FEA
1C22:  MOVLW  69
1C24:  MOVWF  FE9
1C26:  CLRF   00
1C28:  CLRF   01
1C2A:  CLRF   02
1C2C:  CLRF   03
1C2E:  CLRF   x69
1C30:  CLRF   x6A
1C32:  CLRF   x6B
1C34:  CLRF   x6C
1C36:  MOVF   x68,W
1C38:  IORWF  x67,W
1C3A:  IORWF  x66,W
1C3C:  IORWF  x65,W
1C3E:  BZ    1C98
1C40:  MOVLW  20
1C42:  MOVWF  x6D
1C44:  BCF    FD8.0
1C46:  RLCF   x61,F
1C48:  RLCF   x62,F
1C4A:  RLCF   x63,F
1C4C:  RLCF   x64,F
1C4E:  RLCF   x69,F
1C50:  RLCF   x6A,F
1C52:  RLCF   x6B,F
1C54:  RLCF   x6C,F
1C56:  MOVF   x68,W
1C58:  SUBWF  x6C,W
1C5A:  BNZ   1C6C
1C5C:  MOVF   x67,W
1C5E:  SUBWF  x6B,W
1C60:  BNZ   1C6C
1C62:  MOVF   x66,W
1C64:  SUBWF  x6A,W
1C66:  BNZ   1C6C
1C68:  MOVF   x65,W
1C6A:  SUBWF  x69,W
1C6C:  BNC   1C8C
1C6E:  MOVF   x65,W
1C70:  SUBWF  x69,F
1C72:  MOVF   x66,W
1C74:  BTFSS  FD8.0
1C76:  INCFSZ x66,W
1C78:  SUBWF  x6A,F
1C7A:  MOVF   x67,W
1C7C:  BTFSS  FD8.0
1C7E:  INCFSZ x67,W
1C80:  SUBWF  x6B,F
1C82:  MOVF   x68,W
1C84:  BTFSS  FD8.0
1C86:  INCFSZ x68,W
1C88:  SUBWF  x6C,F
1C8A:  BSF    FD8.0
1C8C:  RLCF   00,F
1C8E:  RLCF   01,F
1C90:  RLCF   02,F
1C92:  RLCF   03,F
1C94:  DECFSZ x6D,F
1C96:  BRA    1C44
1C98:  MOVFF  69,FEF
1C9C:  MOVFF  6A,FEC
1CA0:  MOVFF  6B,FEC
1CA4:  MOVFF  6C,FEC
1CA8:  RETURN 0
1CAA:  MOVF   FE9,W
1CAC:  MOVWF  59
1CAE:  MOVF   58,W
1CB0:  MOVWF  5B
1CB2:  BZ    1CE8
1CB4:  MOVFF  57,83
1CB8:  MOVFF  56,82
1CBC:  MOVFF  55,81
1CC0:  MOVFF  54,80
1CC4:  CLRF   x87
1CC6:  CLRF   x86
1CC8:  MOVLW  20
1CCA:  MOVWF  x85
1CCC:  MOVLW  82
1CCE:  MOVWF  x84
1CD0:  CALL   018A
1CD4:  MOVFF  03,57
1CD8:  MOVFF  02,56
1CDC:  MOVFF  01,55
1CE0:  MOVFF  00,54
1CE4:  DECFSZ 5B,F
1CE6:  BRA    1CB4
1CE8:  MOVFF  57,64
1CEC:  MOVFF  56,63
1CF0:  MOVFF  55,62
1CF4:  MOVFF  54,61
1CF8:  BRA    1BDC
1CFA:  MOVFF  03,57
1CFE:  MOVFF  02,56
1D02:  MOVFF  01,55
1D06:  MOVFF  00,54
1D0A:  BTFSS  57.7
1D0C:  BRA    1D28
1D0E:  DECF   59,F
1D10:  BSF    59.5
1D12:  COMF   54,F
1D14:  COMF   55,F
1D16:  COMF   56,F
1D18:  COMF   57,F
1D1A:  INCF   54,F
1D1C:  BTFSC  FD8.2
1D1E:  INCF   55,F
1D20:  BTFSC  FD8.2
1D22:  INCF   56,F
1D24:  BTFSC  FD8.2
1D26:  INCF   57,F
1D28:  MOVLW  3B
1D2A:  MOVWF  x60
1D2C:  MOVLW  9A
1D2E:  MOVWF  5F
1D30:  MOVLW  CA
1D32:  MOVWF  5E
1D34:  CLRF   5D
1D36:  MOVLW  0A
1D38:  MOVWF  5B
1D3A:  MOVF   58,W
1D3C:  BTFSC  FD8.2
1D3E:  INCF   59,F
1D40:  BSF    FD8.1
1D42:  CLRF   FEA
1D44:  MOVLW  54
1D46:  MOVWF  FE9
1D48:  MOVFF  57,64
1D4C:  MOVFF  56,63
1D50:  MOVFF  55,62
1D54:  MOVFF  54,61
1D58:  MOVFF  60,68
1D5C:  MOVFF  5F,67
1D60:  MOVFF  5E,66
1D64:  MOVFF  5D,65
1D68:  RCALL  1C1C
1D6A:  MOVF   01,W
1D6C:  MOVF   00,F
1D6E:  BNZ   1D8E
1D70:  INCF   58,W
1D72:  SUBWF  5B,W
1D74:  BZ    1D8E
1D76:  MOVF   59,W
1D78:  BZ    1D92
1D7A:  ANDLW  0F
1D7C:  SUBWF  5B,W
1D7E:  BZ    1D82
1D80:  BC    1DF0
1D82:  BTFSC  59.7
1D84:  BRA    1DF0
1D86:  BTFSC  59.6
1D88:  BRA    1D92
1D8A:  MOVLW  20
1D8C:  BRA    1DE8
1D8E:  MOVLW  20
1D90:  ANDWF  59,F
1D92:  BTFSS  59.5
1D94:  BRA    1DAE
1D96:  BCF    59.5
1D98:  MOVF   58,W
1D9A:  BTFSS  FD8.2
1D9C:  DECF   59,F
1D9E:  MOVF   00,W
1DA0:  MOVWF  59
1DA2:  MOVLW  2D
1DA4:  MOVWF  x61
1DA6:  RCALL  1A28
1DA8:  MOVF   59,W
1DAA:  MOVWF  00
1DAC:  CLRF   59
1DAE:  MOVF   58,W
1DB0:  SUBWF  5B,W
1DB2:  BNZ   1DC8
1DB4:  MOVF   00,W
1DB6:  MOVWF  59
1DB8:  MOVLW  2E
1DBA:  MOVWF  x61
1DBC:  RCALL  1A28
1DBE:  MOVF   59,W
1DC0:  MOVWF  00
1DC2:  MOVLW  20
1DC4:  ANDWF  59,F
1DC6:  MOVLW  00
1DC8:  MOVLW  30
1DCA:  BTFSS  59.5
1DCC:  BRA    1DE8
1DCE:  BCF    59.5
1DD0:  MOVF   58,W
1DD2:  BTFSS  FD8.2
1DD4:  DECF   59,F
1DD6:  MOVF   00,W
1DD8:  MOVWF  59
1DDA:  MOVLW  2D
1DDC:  MOVWF  x61
1DDE:  RCALL  1A28
1DE0:  MOVF   59,W
1DE2:  MOVWF  00
1DE4:  CLRF   59
1DE6:  MOVLW  30
1DE8:  ADDWF  00,F
1DEA:  MOVFF  00,61
1DEE:  RCALL  1A28
1DF0:  BCF    FD8.1
1DF2:  MOVFF  60,64
1DF6:  MOVFF  5F,63
1DFA:  MOVFF  5E,62
1DFE:  MOVFF  5D,61
1E02:  CLRF   x68
1E04:  CLRF   x67
1E06:  CLRF   x66
1E08:  MOVLW  0A
1E0A:  MOVWF  x65
1E0C:  RCALL  1C1C
1E0E:  MOVFF  03,60
1E12:  MOVFF  02,5F
1E16:  MOVFF  01,5E
1E1A:  MOVFF  00,5D
1E1E:  DECFSZ 5B,F
1E20:  BRA    1D40
1E22:  RETURN 0
....................  
.................... #list 
....................  
.................... #DEVICE ADC =10  // seleciona o conversor a/d com 10 bits 
.................... #INCLUDE <stdlib.h>   
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <math.h> //  Inclui a biblioteca responsavel por fornecer funções de calculos matematicos  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
0A76:  BCF    x7F.0
....................    y = x; 
0A78:  MOVFF  73,78
0A7C:  MOVFF  72,77
0A80:  MOVFF  71,76
0A84:  MOVFF  70,75
....................  
....................    if (x < 0) 
0A88:  MOVFF  73,83
0A8C:  MOVFF  72,82
0A90:  MOVFF  71,81
0A94:  MOVFF  70,80
0A98:  CLRF   x87
0A9A:  CLRF   x86
0A9C:  CLRF   x85
0A9E:  CLRF   x84
0AA0:  RCALL  0640
0AA2:  BNC   0AAC
....................    { 
....................       s = 1; 
0AA4:  BSF    x7F.0
....................       y = -y; 
0AA6:  MOVF   x76,W
0AA8:  XORLW  80
0AAA:  MOVWF  x76
....................    } 
....................  
....................    if (y <= 32768.0) 
0AAC:  MOVFF  78,83
0AB0:  MOVFF  77,82
0AB4:  MOVFF  76,81
0AB8:  MOVFF  75,80
0ABC:  CLRF   x87
0ABE:  CLRF   x86
0AC0:  CLRF   x85
0AC2:  MOVLW  8E
0AC4:  MOVWF  x84
0AC6:  RCALL  0640
0AC8:  BC    0ACC
0ACA:  BNZ   0AFC
....................       res = (float32)(unsigned int16)y; 
0ACC:  MOVFF  78,83
0AD0:  MOVFF  77,82
0AD4:  MOVFF  76,81
0AD8:  MOVFF  75,80
0ADC:  RCALL  0A3E
0ADE:  MOVFF  02,85
0AE2:  MOVFF  01,84
0AE6:  CALL   0154
0AEA:  MOVFF  03,7C
0AEE:  MOVFF  02,7B
0AF2:  MOVFF  01,7A
0AF6:  MOVFF  00,79
0AFA:  BRA    0C86
....................  
....................  else if (y < 10000000.0) 
0AFC:  MOVFF  78,83
0B00:  MOVFF  77,82
0B04:  MOVFF  76,81
0B08:  MOVFF  75,80
0B0C:  MOVLW  80
0B0E:  MOVWF  x87
0B10:  MOVLW  96
0B12:  MOVWF  x86
0B14:  MOVLW  18
0B16:  MOVWF  x85
0B18:  MOVLW  96
0B1A:  MOVWF  x84
0B1C:  RCALL  0640
0B1E:  BTFSS  FD8.0
0B20:  BRA    0C76
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
0B22:  MOVFF  78,83
0B26:  MOVFF  77,82
0B2A:  MOVFF  76,81
0B2E:  MOVFF  75,80
0B32:  CLRF   x87
0B34:  CLRF   x86
0B36:  CLRF   x85
0B38:  MOVLW  70
0B3A:  MOVWF  x84
0B3C:  CALL   018A
0B40:  MOVFF  03,83
0B44:  MOVFF  02,82
0B48:  MOVFF  01,81
0B4C:  MOVFF  00,80
0B50:  RCALL  0A3E
0B52:  MOVFF  02,7E
0B56:  MOVFF  01,7D
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
0B5A:  MOVFF  78,83
0B5E:  MOVFF  77,82
0B62:  MOVFF  76,81
0B66:  MOVFF  75,80
0B6A:  CLRF   x87
0B6C:  CLRF   x86
0B6E:  CLRF   x85
0B70:  MOVLW  70
0B72:  MOVWF  x84
0B74:  CALL   018A
0B78:  MOVFF  03,83
0B7C:  MOVFF  02,82
0B80:  MOVFF  01,81
0B84:  MOVFF  00,80
0B88:  MOVFF  7E,85
0B8C:  MOVFF  7D,84
0B90:  CALL   0154
0B94:  BSF    FD8.1
0B96:  MOVFF  83,87
0B9A:  MOVFF  82,86
0B9E:  MOVFF  81,85
0BA2:  MOVFF  80,84
0BA6:  MOVFF  03,8B
0BAA:  MOVFF  02,8A
0BAE:  MOVFF  01,89
0BB2:  MOVFF  00,88
0BB6:  RCALL  03D6
0BB8:  CLRF   x83
0BBA:  CLRF   x82
0BBC:  CLRF   x81
0BBE:  MOVLW  8E
0BC0:  MOVWF  x80
0BC2:  MOVFF  03,87
0BC6:  MOVFF  02,86
0BCA:  MOVFF  01,85
0BCE:  MOVFF  00,84
0BD2:  CALL   018A
0BD6:  MOVFF  03,78
0BDA:  MOVFF  02,77
0BDE:  MOVFF  01,76
0BE2:  MOVFF  00,75
....................       res = 32768.0*(float32)l; 
0BE6:  MOVFF  7E,85
0BEA:  MOVFF  7D,84
0BEE:  CALL   0154
0BF2:  CLRF   x83
0BF4:  CLRF   x82
0BF6:  CLRF   x81
0BF8:  MOVLW  8E
0BFA:  MOVWF  x80
0BFC:  MOVFF  03,87
0C00:  MOVFF  02,86
0C04:  MOVFF  01,85
0C08:  MOVFF  00,84
0C0C:  CALL   018A
0C10:  MOVFF  03,7C
0C14:  MOVFF  02,7B
0C18:  MOVFF  01,7A
0C1C:  MOVFF  00,79
....................       res += (float32)(unsigned int16)y; 
0C20:  MOVFF  78,83
0C24:  MOVFF  77,82
0C28:  MOVFF  76,81
0C2C:  MOVFF  75,80
0C30:  RCALL  0A3E
0C32:  MOVFF  02,85
0C36:  MOVFF  01,84
0C3A:  CALL   0154
0C3E:  BCF    FD8.1
0C40:  MOVFF  7C,87
0C44:  MOVFF  7B,86
0C48:  MOVFF  7A,85
0C4C:  MOVFF  79,84
0C50:  MOVFF  03,8B
0C54:  MOVFF  02,8A
0C58:  MOVFF  01,89
0C5C:  MOVFF  00,88
0C60:  CALL   03D6
0C64:  MOVFF  03,7C
0C68:  MOVFF  02,7B
0C6C:  MOVFF  01,7A
0C70:  MOVFF  00,79
....................    } 
0C74:  BRA    0C86
....................  
....................  else 
....................   res = y; 
0C76:  MOVFF  78,7C
0C7A:  MOVFF  77,7B
0C7E:  MOVFF  76,7A
0C82:  MOVFF  75,79
....................  
....................  y = y - (float32)(unsigned int16)y; 
0C86:  MOVFF  78,83
0C8A:  MOVFF  77,82
0C8E:  MOVFF  76,81
0C92:  MOVFF  75,80
0C96:  RCALL  0A3E
0C98:  MOVFF  02,85
0C9C:  MOVFF  01,84
0CA0:  CALL   0154
0CA4:  BSF    FD8.1
0CA6:  MOVFF  78,87
0CAA:  MOVFF  77,86
0CAE:  MOVFF  76,85
0CB2:  MOVFF  75,84
0CB6:  MOVFF  03,8B
0CBA:  MOVFF  02,8A
0CBE:  MOVFF  01,89
0CC2:  MOVFF  00,88
0CC6:  CALL   03D6
0CCA:  MOVFF  03,78
0CCE:  MOVFF  02,77
0CD2:  MOVFF  01,76
0CD6:  MOVFF  00,75
....................  
....................  if (s) 
0CDA:  BTFSS  x7F.0
0CDC:  BRA    0CE4
....................   res = -res; 
0CDE:  MOVF   x7A,W
0CE0:  XORLW  80
0CE2:  MOVWF  x7A
....................  
....................  if (y != 0) 
0CE4:  MOVFF  78,83
0CE8:  MOVFF  77,82
0CEC:  MOVFF  76,81
0CF0:  MOVFF  75,80
0CF4:  CLRF   x87
0CF6:  CLRF   x86
0CF8:  CLRF   x85
0CFA:  CLRF   x84
0CFC:  RCALL  0640
0CFE:  BZ    0D70
....................  { 
....................   if (s == 1 && n == 0) 
0D00:  BTFSS  x7F.0
0D02:  BRA    0D38
0D04:  MOVF   x74,F
0D06:  BNZ   0D38
....................    res -= 1.0; 
0D08:  BSF    FD8.1
0D0A:  MOVFF  7C,87
0D0E:  MOVFF  7B,86
0D12:  MOVFF  7A,85
0D16:  MOVFF  79,84
0D1A:  CLRF   x8B
0D1C:  CLRF   x8A
0D1E:  CLRF   x89
0D20:  MOVLW  7F
0D22:  MOVWF  x88
0D24:  CALL   03D6
0D28:  MOVFF  03,7C
0D2C:  MOVFF  02,7B
0D30:  MOVFF  01,7A
0D34:  MOVFF  00,79
....................  
....................   if (s == 0 && n == 1) 
0D38:  BTFSC  x7F.0
0D3A:  BRA    0D70
0D3C:  DECFSZ x74,W
0D3E:  BRA    0D70
....................    res += 1.0; 
0D40:  BCF    FD8.1
0D42:  MOVFF  7C,87
0D46:  MOVFF  7B,86
0D4A:  MOVFF  7A,85
0D4E:  MOVFF  79,84
0D52:  CLRF   x8B
0D54:  CLRF   x8A
0D56:  CLRF   x89
0D58:  MOVLW  7F
0D5A:  MOVWF  x88
0D5C:  CALL   03D6
0D60:  MOVFF  03,7C
0D64:  MOVFF  02,7B
0D68:  MOVFF  01,7A
0D6C:  MOVFF  00,79
....................  } 
....................  if (x == 0) 
0D70:  MOVFF  73,83
0D74:  MOVFF  72,82
0D78:  MOVFF  71,81
0D7C:  MOVFF  70,80
0D80:  CLRF   x87
0D82:  CLRF   x86
0D84:  CLRF   x85
0D86:  CLRF   x84
0D88:  RCALL  0640
0D8A:  BNZ   0D94
....................     res = 0; 
0D8C:  CLRF   x7C
0D8E:  CLRF   x7B
0D90:  CLRF   x7A
0D92:  CLRF   x79
....................  
....................  return (res); 
0D94:  MOVFF  79,00
0D98:  MOVFF  7A,01
0D9C:  MOVFF  7B,02
0DA0:  MOVFF  7C,03
0DA4:  RETURN 0
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
*
0DC0:  MOVFF  6F,73
0DC4:  MOVFF  6E,72
0DC8:  MOVFF  6D,71
0DCC:  MOVFF  6C,70
0DD0:  CLRF   x74
0DD2:  RCALL  0A76
0DD4:  GOTO   0ED6 (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
0DA6:  MOVFF  6F,73
0DAA:  MOVFF  6E,72
0DAE:  MOVFF  6D,71
0DB2:  MOVFF  6C,70
0DB6:  MOVLW  01
0DB8:  MOVWF  x74
0DBA:  RCALL  0A76
0DBC:  GOTO   0E8E (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
*
0DD8:  MOVFF  63,83
0DDC:  MOVFF  62,82
0DE0:  MOVFF  61,81
0DE4:  MOVFF  60,80
0DE8:  CLRF   x87
0DEA:  CLRF   x86
0DEC:  CLRF   x85
0DEE:  CLRF   x84
0DF0:  RCALL  0640
0DF2:  BTFSC  FD8.2
0DF4:  BRA    0F32
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
0DF6:  MOVFF  5F,7C
0DFA:  MOVFF  5E,7B
0DFE:  MOVFF  5D,7A
0E02:  MOVFF  5C,79
0E06:  MOVFF  63,80
0E0A:  MOVFF  62,7F
0E0E:  MOVFF  61,7E
0E12:  MOVFF  60,7D
0E16:  CALL   027C
0E1A:  MOVFF  03,6B
0E1E:  MOVFF  02,6A
0E22:  MOVFF  01,69
0E26:  MOVFF  00,68
0E2A:  MOVFF  03,83
0E2E:  MOVFF  02,82
0E32:  MOVFF  01,81
0E36:  MOVFF  00,80
0E3A:  CLRF   x87
0E3C:  CLRF   x86
0E3E:  CLRF   x85
0E40:  CLRF   x84
0E42:  CALL   0640
0E46:  BNC   0E90
0E48:  MOVFF  5F,7C
0E4C:  MOVFF  5E,7B
0E50:  MOVFF  5D,7A
0E54:  MOVFF  5C,79
0E58:  MOVFF  63,80
0E5C:  MOVFF  62,7F
0E60:  MOVFF  61,7E
0E64:  MOVFF  60,7D
0E68:  CALL   027C
0E6C:  MOVFF  03,6B
0E70:  MOVFF  02,6A
0E74:  MOVFF  01,69
0E78:  MOVFF  00,68
0E7C:  MOVFF  03,6F
0E80:  MOVFF  02,6E
0E84:  MOVFF  01,6D
0E88:  MOVFF  00,6C
0E8C:  BRA    0DA6
0E8E:  BRA    0ED6
0E90:  MOVFF  5F,7C
0E94:  MOVFF  5E,7B
0E98:  MOVFF  5D,7A
0E9C:  MOVFF  5C,79
0EA0:  MOVFF  63,80
0EA4:  MOVFF  62,7F
0EA8:  MOVFF  61,7E
0EAC:  MOVFF  60,7D
0EB0:  CALL   027C
0EB4:  MOVFF  03,6B
0EB8:  MOVFF  02,6A
0EBC:  MOVFF  01,69
0EC0:  MOVFF  00,68
0EC4:  MOVFF  03,6F
0EC8:  MOVFF  02,6E
0ECC:  MOVFF  01,6D
0ED0:  MOVFF  00,6C
0ED4:  BRA    0DC0
0ED6:  MOVFF  03,67
0EDA:  MOVFF  02,66
0EDE:  MOVFF  01,65
0EE2:  MOVFF  00,64
....................       return(x-(i*y)); 
0EE6:  MOVFF  67,83
0EEA:  MOVFF  66,82
0EEE:  MOVFF  65,81
0EF2:  MOVFF  64,80
0EF6:  MOVFF  63,87
0EFA:  MOVFF  62,86
0EFE:  MOVFF  61,85
0F02:  MOVFF  60,84
0F06:  CALL   018A
0F0A:  BSF    FD8.1
0F0C:  MOVFF  5F,87
0F10:  MOVFF  5E,86
0F14:  MOVFF  5D,85
0F18:  MOVFF  5C,84
0F1C:  MOVFF  03,8B
0F20:  MOVFF  02,8A
0F24:  MOVFF  01,89
0F28:  MOVFF  00,88
0F2C:  CALL   03D6
0F30:  BRA    0F32
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
0F32:  RETURN 0
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
0F34:  MOVFF  63,83
0F38:  MOVFF  62,82
0F3C:  MOVFF  61,81
0F40:  MOVFF  60,80
0F44:  MOVLW  3B
0F46:  MOVWF  x87
0F48:  MOVLW  AA
0F4A:  MOVWF  x86
0F4C:  MOVLW  38
0F4E:  MOVWF  x85
0F50:  MOVLW  7F
0F52:  MOVWF  x84
0F54:  CALL   018A
0F58:  MOVFF  03,83
0F5C:  MOVFF  02,82
0F60:  MOVFF  01,81
0F64:  MOVFF  00,80
0F68:  RCALL  0A3E
0F6A:  MOVFF  01,70
....................    s = 0; 
0F6E:  BCF    x71.0
....................    y = x; 
0F70:  MOVFF  63,67
0F74:  MOVFF  62,66
0F78:  MOVFF  61,65
0F7C:  MOVFF  60,64
....................  
....................    if (x < 0) 
0F80:  MOVFF  63,83
0F84:  MOVFF  62,82
0F88:  MOVFF  61,81
0F8C:  MOVFF  60,80
0F90:  CLRF   x87
0F92:  CLRF   x86
0F94:  CLRF   x85
0F96:  CLRF   x84
0F98:  CALL   0640
0F9C:  BNC   0FA8
....................    { 
....................       s = 1; 
0F9E:  BSF    x71.0
....................       n = -n; 
0FA0:  NEGF   x70
....................       y = -y; 
0FA2:  MOVF   x65,W
0FA4:  XORLW  80
0FA6:  MOVWF  x65
....................    } 
....................  
....................    res = 0.0; 
0FA8:  CLRF   x6B
0FAA:  CLRF   x6A
0FAC:  CLRF   x69
0FAE:  CLRF   x68
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
0FB0:  CLRF   x73
0FB2:  MOVLW  68
0FB4:  MOVWF  FE9
0FB6:  MOVFF  73,FEA
0FBA:  MOVLW  7F
0FBC:  ADDWF  x70,W
0FBE:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
0FC0:  MOVFF  67,83
0FC4:  MOVFF  66,82
0FC8:  MOVFF  65,81
0FCC:  MOVFF  64,80
0FD0:  MOVLW  3B
0FD2:  MOVWF  x87
0FD4:  MOVLW  AA
0FD6:  MOVWF  x86
0FD8:  MOVLW  38
0FDA:  MOVWF  x85
0FDC:  MOVLW  7F
0FDE:  MOVWF  x84
0FE0:  CALL   018A
0FE4:  MOVFF  03,75
0FE8:  MOVFF  02,74
0FEC:  MOVFF  01,73
0FF0:  MOVFF  00,72
0FF4:  CLRF   x77
0FF6:  MOVFF  70,76
0FFA:  BTFSC  x76.7
0FFC:  DECF   x77,F
0FFE:  CALL   06B6
1002:  BSF    FD8.1
1004:  MOVFF  75,87
1008:  MOVFF  74,86
100C:  MOVFF  73,85
1010:  MOVFF  72,84
1014:  MOVFF  03,8B
1018:  MOVFF  02,8A
101C:  MOVFF  01,89
1020:  MOVFF  00,88
1024:  CALL   03D6
1028:  MOVFF  03,67
102C:  MOVFF  02,66
1030:  MOVFF  01,65
1034:  MOVFF  00,64
....................  
....................    r = pe[0]*y + pe[1]; 
1038:  MOVLW  7C
103A:  MOVWF  x83
103C:  MOVLW  88
103E:  MOVWF  x82
1040:  MOVLW  59
1042:  MOVWF  x81
1044:  MOVLW  72
1046:  MOVWF  x80
1048:  MOVFF  67,87
104C:  MOVFF  66,86
1050:  MOVFF  65,85
1054:  MOVFF  64,84
1058:  CALL   018A
105C:  MOVFF  03,75
1060:  MOVFF  02,74
1064:  MOVFF  01,73
1068:  MOVFF  00,72
106C:  BCF    FD8.1
106E:  MOVFF  03,87
1072:  MOVFF  02,86
1076:  MOVFF  01,85
107A:  MOVFF  00,84
107E:  MOVLW  E0
1080:  MOVWF  x8B
1082:  MOVLW  97
1084:  MOVWF  x8A
1086:  MOVLW  26
1088:  MOVWF  x89
108A:  MOVLW  75
108C:  MOVWF  x88
108E:  CALL   03D6
1092:  MOVFF  03,6F
1096:  MOVFF  02,6E
109A:  MOVFF  01,6D
109E:  MOVFF  00,6C
....................    r = r*y + pe[2]; 
10A2:  MOVFF  6F,83
10A6:  MOVFF  6E,82
10AA:  MOVFF  6D,81
10AE:  MOVFF  6C,80
10B2:  MOVFF  67,87
10B6:  MOVFF  66,86
10BA:  MOVFF  65,85
10BE:  MOVFF  64,84
10C2:  CALL   018A
10C6:  MOVFF  03,75
10CA:  MOVFF  02,74
10CE:  MOVFF  01,73
10D2:  MOVFF  00,72
10D6:  BCF    FD8.1
10D8:  MOVFF  03,87
10DC:  MOVFF  02,86
10E0:  MOVFF  01,85
10E4:  MOVFF  00,84
10E8:  MOVLW  C4
10EA:  MOVWF  x8B
10EC:  MOVLW  1D
10EE:  MOVWF  x8A
10F0:  MOVLW  1E
10F2:  MOVWF  x89
10F4:  MOVLW  78
10F6:  MOVWF  x88
10F8:  CALL   03D6
10FC:  MOVFF  03,6F
1100:  MOVFF  02,6E
1104:  MOVFF  01,6D
1108:  MOVFF  00,6C
....................    r = r*y + pe[3]; 
110C:  MOVFF  6F,83
1110:  MOVFF  6E,82
1114:  MOVFF  6D,81
1118:  MOVFF  6C,80
111C:  MOVFF  67,87
1120:  MOVFF  66,86
1124:  MOVFF  65,85
1128:  MOVFF  64,84
112C:  CALL   018A
1130:  MOVFF  03,75
1134:  MOVFF  02,74
1138:  MOVFF  01,73
113C:  MOVFF  00,72
1140:  BCF    FD8.1
1142:  MOVFF  03,87
1146:  MOVFF  02,86
114A:  MOVFF  01,85
114E:  MOVFF  00,84
1152:  MOVLW  5E
1154:  MOVWF  x8B
1156:  MOVLW  50
1158:  MOVWF  x8A
115A:  MOVLW  63
115C:  MOVWF  x89
115E:  MOVLW  7A
1160:  MOVWF  x88
1162:  CALL   03D6
1166:  MOVFF  03,6F
116A:  MOVFF  02,6E
116E:  MOVFF  01,6D
1172:  MOVFF  00,6C
....................    r = r*y + pe[4]; 
1176:  MOVFF  6F,83
117A:  MOVFF  6E,82
117E:  MOVFF  6D,81
1182:  MOVFF  6C,80
1186:  MOVFF  67,87
118A:  MOVFF  66,86
118E:  MOVFF  65,85
1192:  MOVFF  64,84
1196:  CALL   018A
119A:  MOVFF  03,75
119E:  MOVFF  02,74
11A2:  MOVFF  01,73
11A6:  MOVFF  00,72
11AA:  BCF    FD8.1
11AC:  MOVFF  03,87
11B0:  MOVFF  02,86
11B4:  MOVFF  01,85
11B8:  MOVFF  00,84
11BC:  MOVLW  1A
11BE:  MOVWF  x8B
11C0:  MOVLW  FE
11C2:  MOVWF  x8A
11C4:  MOVLW  75
11C6:  MOVWF  x89
11C8:  MOVLW  7C
11CA:  MOVWF  x88
11CC:  CALL   03D6
11D0:  MOVFF  03,6F
11D4:  MOVFF  02,6E
11D8:  MOVFF  01,6D
11DC:  MOVFF  00,6C
....................    r = r*y + pe[5]; 
11E0:  MOVFF  6F,83
11E4:  MOVFF  6E,82
11E8:  MOVFF  6D,81
11EC:  MOVFF  6C,80
11F0:  MOVFF  67,87
11F4:  MOVFF  66,86
11F8:  MOVFF  65,85
11FC:  MOVFF  64,84
1200:  CALL   018A
1204:  MOVFF  03,75
1208:  MOVFF  02,74
120C:  MOVFF  01,73
1210:  MOVFF  00,72
1214:  BCF    FD8.1
1216:  MOVFF  03,87
121A:  MOVFF  02,86
121E:  MOVFF  01,85
1222:  MOVFF  00,84
1226:  MOVLW  18
1228:  MOVWF  x8B
122A:  MOVLW  72
122C:  MOVWF  x8A
122E:  MOVLW  31
1230:  MOVWF  x89
1232:  MOVLW  7E
1234:  MOVWF  x88
1236:  CALL   03D6
123A:  MOVFF  03,6F
123E:  MOVFF  02,6E
1242:  MOVFF  01,6D
1246:  MOVFF  00,6C
....................  
....................    res = res*(1.0 + y*r); 
124A:  MOVFF  67,83
124E:  MOVFF  66,82
1252:  MOVFF  65,81
1256:  MOVFF  64,80
125A:  MOVFF  6F,87
125E:  MOVFF  6E,86
1262:  MOVFF  6D,85
1266:  MOVFF  6C,84
126A:  CALL   018A
126E:  BCF    FD8.1
1270:  CLRF   x87
1272:  CLRF   x86
1274:  CLRF   x85
1276:  MOVLW  7F
1278:  MOVWF  x84
127A:  MOVFF  03,8B
127E:  MOVFF  02,8A
1282:  MOVFF  01,89
1286:  MOVFF  00,88
128A:  CALL   03D6
128E:  MOVFF  6B,83
1292:  MOVFF  6A,82
1296:  MOVFF  69,81
129A:  MOVFF  68,80
129E:  MOVFF  03,87
12A2:  MOVFF  02,86
12A6:  MOVFF  01,85
12AA:  MOVFF  00,84
12AE:  CALL   018A
12B2:  MOVFF  03,6B
12B6:  MOVFF  02,6A
12BA:  MOVFF  01,69
12BE:  MOVFF  00,68
....................  
....................    if (s) 
12C2:  BTFSS  x71.0
12C4:  BRA    12F4
....................       res = 1.0/res; 
12C6:  CLRF   x7C
12C8:  CLRF   x7B
12CA:  CLRF   x7A
12CC:  MOVLW  7F
12CE:  MOVWF  x79
12D0:  MOVFF  6B,80
12D4:  MOVFF  6A,7F
12D8:  MOVFF  69,7E
12DC:  MOVFF  68,7D
12E0:  CALL   027C
12E4:  MOVFF  03,6B
12E8:  MOVFF  02,6A
12EC:  MOVFF  01,69
12F0:  MOVFF  00,68
....................    return(res); 
12F4:  MOVFF  68,00
12F8:  MOVFF  69,01
12FC:  MOVFF  6A,02
1300:  MOVFF  6B,03
1304:  RETURN 0
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
*
06FE:  MOVFF  63,67
0702:  MOVFF  62,66
0706:  MOVFF  61,65
070A:  MOVFF  60,64
....................  
....................    if (y != 1.0) 
070E:  MOVFF  67,83
0712:  MOVFF  66,82
0716:  MOVFF  65,81
071A:  MOVFF  64,80
071E:  CLRF   x87
0720:  CLRF   x86
0722:  CLRF   x85
0724:  MOVLW  7F
0726:  MOVWF  x84
0728:  RCALL  0640
072A:  BTFSC  FD8.2
072C:  BRA    0A24
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
072E:  CLRF   x76
0730:  MOVLW  64
0732:  MOVWF  FE9
0734:  MOVFF  76,FEA
0738:  MOVLW  7E
073A:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
073C:  BSF    FD8.1
073E:  MOVFF  67,87
0742:  MOVFF  66,86
0746:  MOVFF  65,85
074A:  MOVFF  64,84
074E:  CLRF   x8B
0750:  CLRF   x8A
0752:  CLRF   x89
0754:  MOVLW  7F
0756:  MOVWF  x88
0758:  RCALL  03D6
075A:  MOVFF  03,78
075E:  MOVFF  02,77
0762:  MOVFF  01,76
0766:  MOVFF  00,75
076A:  BCF    FD8.1
076C:  MOVFF  67,87
0770:  MOVFF  66,86
0774:  MOVFF  65,85
0778:  MOVFF  64,84
077C:  CLRF   x8B
077E:  CLRF   x8A
0780:  CLRF   x89
0782:  MOVLW  7F
0784:  MOVWF  x88
0786:  RCALL  03D6
0788:  MOVFF  78,7C
078C:  MOVFF  77,7B
0790:  MOVFF  76,7A
0794:  MOVFF  75,79
0798:  MOVFF  03,80
079C:  MOVFF  02,7F
07A0:  MOVFF  01,7E
07A4:  MOVFF  00,7D
07A8:  RCALL  027C
07AA:  MOVFF  03,67
07AE:  MOVFF  02,66
07B2:  MOVFF  01,65
07B6:  MOVFF  00,64
....................  
....................       y2=y*y; 
07BA:  MOVFF  67,83
07BE:  MOVFF  66,82
07C2:  MOVFF  65,81
07C6:  MOVFF  64,80
07CA:  MOVFF  67,87
07CE:  MOVFF  66,86
07D2:  MOVFF  65,85
07D6:  MOVFF  64,84
07DA:  RCALL  018A
07DC:  MOVFF  03,73
07E0:  MOVFF  02,72
07E4:  MOVFF  01,71
07E8:  MOVFF  00,70
....................  
....................       res = pl[0]*y2 + pl[1]; 
07EC:  MOVLW  99
07EE:  MOVWF  x83
07F0:  MOVLW  47
07F2:  MOVWF  x82
07F4:  MOVLW  8A
07F6:  MOVWF  x81
07F8:  MOVLW  7F
07FA:  MOVWF  x80
07FC:  MOVFF  73,87
0800:  MOVFF  72,86
0804:  MOVFF  71,85
0808:  MOVFF  70,84
080C:  RCALL  018A
080E:  MOVFF  03,78
0812:  MOVFF  02,77
0816:  MOVFF  01,76
081A:  MOVFF  00,75
081E:  BCF    FD8.1
0820:  MOVFF  03,87
0824:  MOVFF  02,86
0828:  MOVFF  01,85
082C:  MOVFF  00,84
0830:  CLRF   x8B
0832:  CLRF   x8A
0834:  CLRF   x89
0836:  MOVLW  80
0838:  MOVWF  x88
083A:  RCALL  03D6
083C:  MOVFF  03,6B
0840:  MOVFF  02,6A
0844:  MOVFF  01,69
0848:  MOVFF  00,68
....................  
....................       r = ql[0]*y2 + ql[1]; 
084C:  MOVLW  4C
084E:  MOVWF  x83
0850:  MOVLW  F3
0852:  MOVWF  x82
0854:  MOVLW  3A
0856:  MOVWF  x81
0858:  MOVLW  7B
085A:  MOVWF  x80
085C:  MOVFF  73,87
0860:  MOVFF  72,86
0864:  MOVFF  71,85
0868:  MOVFF  70,84
086C:  RCALL  018A
086E:  MOVFF  03,78
0872:  MOVFF  02,77
0876:  MOVFF  01,76
087A:  MOVFF  00,75
087E:  BCF    FD8.1
0880:  MOVFF  03,87
0884:  MOVFF  02,86
0888:  MOVFF  01,85
088C:  MOVFF  00,84
0890:  MOVLW  2B
0892:  MOVWF  x8B
0894:  MOVLW  9D
0896:  MOVWF  x8A
0898:  MOVLW  DF
089A:  MOVWF  x89
089C:  MOVLW  7E
089E:  MOVWF  x88
08A0:  RCALL  03D6
08A2:  MOVFF  03,6F
08A6:  MOVFF  02,6E
08AA:  MOVFF  01,6D
08AE:  MOVFF  00,6C
....................       r = r*y2 + 1.0; 
08B2:  MOVFF  6F,83
08B6:  MOVFF  6E,82
08BA:  MOVFF  6D,81
08BE:  MOVFF  6C,80
08C2:  MOVFF  73,87
08C6:  MOVFF  72,86
08CA:  MOVFF  71,85
08CE:  MOVFF  70,84
08D2:  RCALL  018A
08D4:  MOVFF  03,78
08D8:  MOVFF  02,77
08DC:  MOVFF  01,76
08E0:  MOVFF  00,75
08E4:  BCF    FD8.1
08E6:  MOVFF  03,87
08EA:  MOVFF  02,86
08EE:  MOVFF  01,85
08F2:  MOVFF  00,84
08F6:  CLRF   x8B
08F8:  CLRF   x8A
08FA:  CLRF   x89
08FC:  MOVLW  7F
08FE:  MOVWF  x88
0900:  RCALL  03D6
0902:  MOVFF  03,6F
0906:  MOVFF  02,6E
090A:  MOVFF  01,6D
090E:  MOVFF  00,6C
....................  
....................       res = y*res/r; 
0912:  MOVFF  67,83
0916:  MOVFF  66,82
091A:  MOVFF  65,81
091E:  MOVFF  64,80
0922:  MOVFF  6B,87
0926:  MOVFF  6A,86
092A:  MOVFF  69,85
092E:  MOVFF  68,84
0932:  RCALL  018A
0934:  MOVFF  03,78
0938:  MOVFF  02,77
093C:  MOVFF  01,76
0940:  MOVFF  00,75
0944:  MOVFF  03,7C
0948:  MOVFF  02,7B
094C:  MOVFF  01,7A
0950:  MOVFF  00,79
0954:  MOVFF  6F,80
0958:  MOVFF  6E,7F
095C:  MOVFF  6D,7E
0960:  MOVFF  6C,7D
0964:  RCALL  027C
0966:  MOVFF  03,6B
096A:  MOVFF  02,6A
096E:  MOVFF  01,69
0972:  MOVFF  00,68
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
0976:  CLRF   x76
0978:  MOVLW  60
097A:  MOVWF  FE9
097C:  MOVFF  76,FEA
0980:  MOVLW  7E
0982:  SUBWF  FEF,W
0984:  MOVWF  x74
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
0986:  BTFSS  x74.7
0988:  BRA    09AE
....................          r = -(float32)-n; 
098A:  MOVLW  00
098C:  BSF    FD8.0
098E:  SUBFWB x74,W
0990:  CLRF   x77
0992:  MOVWF  x76
0994:  BTFSC  x76.7
0996:  DECF   x77,F
0998:  RCALL  06B6
099A:  MOVFF  00,6C
099E:  MOVF   01,W
09A0:  XORLW  80
09A2:  MOVWF  x6D
09A4:  MOVFF  02,6E
09A8:  MOVFF  03,6F
09AC:  BRA    09CA
....................       else 
....................          r = (float32)n; 
09AE:  CLRF   x77
09B0:  MOVFF  74,76
09B4:  BTFSC  x76.7
09B6:  DECF   x77,F
09B8:  RCALL  06B6
09BA:  MOVFF  03,6F
09BE:  MOVFF  02,6E
09C2:  MOVFF  01,6D
09C6:  MOVFF  00,6C
....................  
....................       res += r*LN2; 
09CA:  MOVFF  6F,83
09CE:  MOVFF  6E,82
09D2:  MOVFF  6D,81
09D6:  MOVFF  6C,80
09DA:  MOVLW  18
09DC:  MOVWF  x87
09DE:  MOVLW  72
09E0:  MOVWF  x86
09E2:  MOVLW  31
09E4:  MOVWF  x85
09E6:  MOVLW  7E
09E8:  MOVWF  x84
09EA:  CALL   018A
09EE:  BCF    FD8.1
09F0:  MOVFF  6B,87
09F4:  MOVFF  6A,86
09F8:  MOVFF  69,85
09FC:  MOVFF  68,84
0A00:  MOVFF  03,8B
0A04:  MOVFF  02,8A
0A08:  MOVFF  01,89
0A0C:  MOVFF  00,88
0A10:  RCALL  03D6
0A12:  MOVFF  03,6B
0A16:  MOVFF  02,6A
0A1A:  MOVFF  01,69
0A1E:  MOVFF  00,68
....................    } 
0A22:  BRA    0A2C
....................  
....................    else 
....................       res = 0.0; 
0A24:  CLRF   x6B
0A26:  CLRF   x6A
0A28:  CLRF   x69
0A2A:  CLRF   x68
....................  
....................    return(res); 
0A2C:  MOVFF  68,00
0A30:  MOVFF  69,01
0A34:  MOVFF  6A,02
0A38:  MOVFF  6B,03
0A3C:  RETURN 0
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
*
1306:  MOVFF  57,83
130A:  MOVFF  56,82
130E:  MOVFF  55,81
1312:  MOVFF  54,80
1316:  CLRF   x87
1318:  CLRF   x86
131A:  CLRF   x85
131C:  CLRF   x84
131E:  CALL   0640
1322:  BTFSS  FD8.0
1324:  BRA    14BC
1326:  MOVFF  5B,5F
132A:  MOVFF  5A,5E
132E:  MOVFF  59,5D
1332:  MOVFF  58,5C
1336:  CLRF   x63
1338:  CLRF   x62
133A:  CLRF   x61
133C:  MOVLW  7F
133E:  MOVWF  x60
1340:  RCALL  0DD8
1342:  MOVFF  03,5F
1346:  MOVFF  02,5E
134A:  MOVFF  01,5D
134E:  MOVFF  00,5C
1352:  MOVFF  03,83
1356:  MOVFF  02,82
135A:  MOVFF  01,81
135E:  MOVFF  00,80
1362:  CLRF   x87
1364:  CLRF   x86
1366:  CLRF   x85
1368:  CLRF   x84
136A:  CALL   0640
136E:  BTFSS  FD8.2
1370:  BRA    14BC
....................       if(fmod(y, 2) == 0) { 
1372:  MOVFF  5B,5F
1376:  MOVFF  5A,5E
137A:  MOVFF  59,5D
137E:  MOVFF  58,5C
1382:  CLRF   x63
1384:  CLRF   x62
1386:  CLRF   x61
1388:  MOVLW  80
138A:  MOVWF  x60
138C:  RCALL  0DD8
138E:  MOVFF  03,5F
1392:  MOVFF  02,5E
1396:  MOVFF  01,5D
139A:  MOVFF  00,5C
139E:  MOVFF  03,83
13A2:  MOVFF  02,82
13A6:  MOVFF  01,81
13AA:  MOVFF  00,80
13AE:  CLRF   x87
13B0:  CLRF   x86
13B2:  CLRF   x85
13B4:  CLRF   x84
13B6:  CALL   0640
13BA:  BNZ   143A
....................          return (exp(log(-x) * y)); 
13BC:  MOVFF  54,5C
13C0:  MOVF   55,W
13C2:  XORLW  80
13C4:  MOVWF  5D
13C6:  MOVFF  56,5E
13CA:  MOVFF  57,5F
13CE:  MOVFF  57,63
13D2:  MOVFF  56,62
13D6:  MOVWF  x61
13D8:  MOVFF  54,60
13DC:  CALL   06FE
13E0:  MOVFF  03,5F
13E4:  MOVFF  02,5E
13E8:  MOVFF  01,5D
13EC:  MOVFF  00,5C
13F0:  MOVFF  03,83
13F4:  MOVFF  02,82
13F8:  MOVFF  01,81
13FC:  MOVFF  00,80
1400:  MOVFF  5B,87
1404:  MOVFF  5A,86
1408:  MOVFF  59,85
140C:  MOVFF  58,84
1410:  CALL   018A
1414:  MOVFF  03,5F
1418:  MOVFF  02,5E
141C:  MOVFF  01,5D
1420:  MOVFF  00,5C
1424:  MOVFF  03,63
1428:  MOVFF  02,62
142C:  MOVFF  01,61
1430:  MOVFF  00,60
1434:  RCALL  0F34
1436:  BRA    15D8
....................       } else { 
1438:  BRA    14BA
....................          return (-exp(log(-x) * y)); 
143A:  MOVFF  54,5C
143E:  MOVF   55,W
1440:  XORLW  80
1442:  MOVWF  5D
1444:  MOVFF  56,5E
1448:  MOVFF  57,5F
144C:  MOVFF  57,63
1450:  MOVFF  56,62
1454:  MOVWF  x61
1456:  MOVFF  54,60
145A:  CALL   06FE
145E:  MOVFF  03,5F
1462:  MOVFF  02,5E
1466:  MOVFF  01,5D
146A:  MOVFF  00,5C
146E:  MOVFF  03,83
1472:  MOVFF  02,82
1476:  MOVFF  01,81
147A:  MOVFF  00,80
147E:  MOVFF  5B,87
1482:  MOVFF  5A,86
1486:  MOVFF  59,85
148A:  MOVFF  58,84
148E:  CALL   018A
1492:  MOVFF  03,5F
1496:  MOVFF  02,5E
149A:  MOVFF  01,5D
149E:  MOVFF  00,5C
14A2:  MOVFF  03,63
14A6:  MOVFF  02,62
14AA:  MOVFF  01,61
14AE:  MOVFF  00,60
14B2:  RCALL  0F34
14B4:  MOVLW  80
14B6:  XORWF  01,F
14B8:  BRA    15D8
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
14BA:  BRA    15D8
14BC:  MOVFF  57,83
14C0:  MOVFF  56,82
14C4:  MOVFF  55,81
14C8:  MOVFF  54,80
14CC:  CLRF   x87
14CE:  CLRF   x86
14D0:  CLRF   x85
14D2:  CLRF   x84
14D4:  CALL   0640
14D8:  BNC   1530
14DA:  MOVFF  5B,5F
14DE:  MOVFF  5A,5E
14E2:  MOVFF  59,5D
14E6:  MOVFF  58,5C
14EA:  CLRF   x63
14EC:  CLRF   x62
14EE:  CLRF   x61
14F0:  MOVLW  7F
14F2:  MOVWF  x60
14F4:  RCALL  0DD8
14F6:  MOVFF  03,5F
14FA:  MOVFF  02,5E
14FE:  MOVFF  01,5D
1502:  MOVFF  00,5C
1506:  MOVFF  03,83
150A:  MOVFF  02,82
150E:  MOVFF  01,81
1512:  MOVFF  00,80
1516:  CLRF   x87
1518:  CLRF   x86
151A:  CLRF   x85
151C:  CLRF   x84
151E:  CALL   0640
1522:  BZ    1530
....................       return 0; 
1524:  CLRF   00
1526:  CLRF   01
1528:  CLRF   02
152A:  CLRF   03
152C:  BRA    15D8
....................    } else { 
152E:  BRA    15D8
....................       if(x != 0 || 0 >= y) { 
1530:  MOVFF  57,83
1534:  MOVFF  56,82
1538:  MOVFF  55,81
153C:  MOVFF  54,80
1540:  CLRF   x87
1542:  CLRF   x86
1544:  CLRF   x85
1546:  CLRF   x84
1548:  CALL   0640
154C:  BNZ   156E
154E:  MOVFF  5B,83
1552:  MOVFF  5A,82
1556:  MOVFF  59,81
155A:  MOVFF  58,80
155E:  CLRF   x87
1560:  CLRF   x86
1562:  CLRF   x85
1564:  CLRF   x84
1566:  CALL   0640
156A:  BC    156E
156C:  BNZ   15D8
....................          return (exp(log(x) * y)); 
156E:  MOVFF  57,63
1572:  MOVFF  56,62
1576:  MOVFF  55,61
157A:  MOVFF  54,60
157E:  CALL   06FE
1582:  MOVFF  03,5F
1586:  MOVFF  02,5E
158A:  MOVFF  01,5D
158E:  MOVFF  00,5C
1592:  MOVFF  03,83
1596:  MOVFF  02,82
159A:  MOVFF  01,81
159E:  MOVFF  00,80
15A2:  MOVFF  5B,87
15A6:  MOVFF  5A,86
15AA:  MOVFF  59,85
15AE:  MOVFF  58,84
15B2:  CALL   018A
15B6:  MOVFF  03,5F
15BA:  MOVFF  02,5E
15BE:  MOVFF  01,5D
15C2:  MOVFF  00,5C
15C6:  MOVFF  03,63
15CA:  MOVFF  02,62
15CE:  MOVFF  01,61
15D2:  MOVFF  00,60
15D6:  RCALL  0F34
....................       } 
....................    } 
15D8:  GOTO   1780 (RETURN)
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #define  t_filtro 400  
.................... #fuses HS,NOWDT,PUT,NOBROWNOUT,NOLVP   // configuração dos fuses do pic  
.................... #use   delay(clock=20000000)// Informa a função delay, o clock utilizado 
*
00E6:  CLRF   FEA
00E8:  MOVLW  55
00EA:  MOVWF  FE9
00EC:  MOVF   FEF,W
00EE:  BZ    010A
00F0:  MOVLW  06
00F2:  MOVWF  01
00F4:  CLRF   00
00F6:  DECFSZ 00,F
00F8:  BRA    00F6
00FA:  DECFSZ 01,F
00FC:  BRA    00F4
00FE:  MOVLW  7B
0100:  MOVWF  00
0102:  DECFSZ 00,F
0104:  BRA    0102
0106:  DECFSZ FEF,F
0108:  BRA    00F0
010A:  RETURN 0
.................... #BIT Data_Pin = 0x06.7                       // Pin mapped to PORTB.7 
.................... #BIT Data_Pin_Direction = 0x86.7             // Pin direction mapped to TRISB.7 
.................... #use   fast_io(a)//modo rápido de inicialização das portas 
.................... #use   fast_io(b)//modo rápido de inicialização das portas 
.................... #use   fast_io(c) 
.................... #use   fast_io(d)//modo rápido de inicialização das portas 
.................... #use   fast_io(e)//modo rápido de inicialização das portas 
....................  
.................... #byte   porta = 0xf80 // atribui o nome "porta" ao registrador do port 0xf80 
.................... #byte   portb = 0xf81  
.................... #byte   portd = 0xf83 
.................... #byte   porte = 0xf84 
.................... #byte   portc = 0xf82 
.................... // pinos de entrada e saida  
.................... #bit NTC = porta.0    //  Pino de leitura do NTC  
.................... #bit PIN_COOLER = portc.0  //  Pino de leitura do DHT11 
.................... #bit POT_SET_TEMP = porta.1 //Pino de leitura do potenciometro de set da temperatura  
.................... #bit POT_SET_UMI = porta.2 //Pino de leitura do potenciometro de set da umidade  
.................... #bit BOT_BLK_LTH = portb.0 // Pino do botao paraligar a luz do lcd 
.................... #bit BOT_MORE_INF = portb.1 // botao para mais informaçoes no lcd 
.................... #bit    config_Bot  = portb.4 // botao para navegação no lcd; auxilia na configuraçao dos parametros 
.................... // pinos de saida 
.................... #bit PIN_SERV = portb.3 
.................... #bit RELE_LAMP = portb.2  //  pino que acionamento do relé da lampada/aquecedor 
.................... #bit DHT11 = portb.7 // Pino de acionamento do cooler via transistor  
.................... #bit rs =porte.0 //  via do lcd que sinaliza recepção de dados ou comando  
.................... #bit enable = porte.1 // habilita o lcd 
.................... #byte DISPLAY = portd //  seleciona o port no qual o lcd esta ligado ( o mesmo valor que esta no arquivo.h) 
.................... #INCLUDE <lcd.h> // inclui a biblioteca do modulo lcd 
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *      Rotina que envia um COMANDO para o LCD                 * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void comando_lcd(int caracter) 
.................... { 
....................    rs = 0;               // seleciona o envio de um caracter 
*
00CA:  BCF    F84.0
....................    portd = caracter;         // carrega o portc com o caracter 
00CC:  MOVFF  54,F83
....................    enable = 1 ;            // gera pulso no enable 
00D0:  BSF    F84.1
....................    delay_us(1);            // espera 1 microsegundos 
00D2:  BRA    00D4
00D4:  BRA    00D6
00D6:  NOP   
....................    enable = 0;            // desce o pino de enable 
00D8:  BCF    F84.1
....................  
....................    delay_us(40);            // espera mínimo 40 microsegundos 
00DA:  MOVLW  42
00DC:  MOVWF  00
00DE:  DECFSZ 00,F
00E0:  BRA    00DE
00E2:  NOP   
....................     
....................    return;               // retorna 
00E4:  RETURN 0
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *      Rotina que envia um DADO a ser escrito no LCD              * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void escreve_lcd(int caracter) 
.................... { 
....................    rs = 1;               // seleciona o envio de um comando 
*
1A28:  BSF    F84.0
....................    portd = caracter;         // carrega o portc com o valor do comando 
1A2A:  MOVFF  61,F83
....................    enable = 1;            // gera pulso no enable 
1A2E:  BSF    F84.1
....................    delay_us(1);            // espera 3 microsegundos 
1A30:  BRA    1A32
1A32:  BRA    1A34
1A34:  NOP   
....................    enable = 0;            // desce o pino de enable 
1A36:  BCF    F84.1
....................  
....................    delay_us(40);            // espera mínimo 40 microsegundos 
1A38:  MOVLW  42
1A3A:  MOVWF  00
1A3C:  DECFSZ 00,F
1A3E:  BRA    1A3C
1A40:  NOP   
....................     
....................    return;               // retorna 
1A42:  RETURN 0
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *              Função para limpar o LCD                 * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void limpa_lcd() 
.................... { 
....................    comando_lcd(0x01);         // limpa lcd    
*
010C:  MOVLW  01
010E:  MOVWF  54
0110:  RCALL  00CA
....................    delay_ms (2); 
0112:  MOVLW  02
0114:  MOVWF  55
0116:  RCALL  00E6
....................    return; 
0118:  RETURN 0
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *           Inicialização do Display de LCD                 * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void inicializa_lcd() 
.................... { 
....................    comando_lcd(0x30);         // envia comando para inicializar display 
011A:  MOVLW  30
011C:  MOVWF  54
011E:  RCALL  00CA
....................    delay_ms(4);            // espera 4 milisengundos 
0120:  MOVLW  04
0122:  MOVWF  55
0124:  RCALL  00E6
....................  
....................    comando_lcd(0x30);         // envia comando para inicializar display 
0126:  MOVLW  30
0128:  MOVWF  54
012A:  RCALL  00CA
....................    delay_us(100);            // espera 100 microsengundos 
012C:  MOVLW  A6
012E:  MOVWF  00
0130:  DECFSZ 00,F
0132:  BRA    0130
0134:  NOP   
....................  
....................    comando_lcd(0x30);         // envia comando para inicializar display 
0136:  MOVLW  30
0138:  MOVWF  54
013A:  RCALL  00CA
....................  
....................    comando_lcd(0x38);         // liga o display, sem cursor e sem blink 
013C:  MOVLW  38
013E:  MOVWF  54
0140:  RCALL  00CA
....................  
....................    limpa_lcd();            // limpa lcd 
0142:  RCALL  010C
....................  
....................    comando_lcd(0x0c);         // display sem cursor 
0144:  MOVLW  0C
0146:  MOVWF  54
0148:  RCALL  00CA
....................  
....................    comando_lcd(0x06);         // desloca cursor para a direita 
014A:  MOVLW  06
014C:  MOVWF  54
014E:  RCALL  00CA
....................  
....................    return;               // retorna 
0150:  GOTO   22C2 (RETURN)
.................... }    
....................  
....................  
....................  
.................... char message2[] = "RH   = 00.0 %"; //  vetor de mensagem para a umidade  
.................... short Time_out; //  variavel para as funçoes referentes ao sensor de umidade dht11 
.................... unsigned  int8 RH_byte1, RH_byte2, CheckSum; //  variaveis para as funçoes do dht11 
....................  
.................... float ntc_val = 0; // variavel responsavel por receber o valor digital do ntc 
.................... float rntc = 0; //  valor da resistencia do divisor de tensao do ntc  
.................... float b1=0;  //  variavel auxiliar para função do ntc 
.................... float c1=0;//  variavel auxiliar para função do ntc 
.................... float temp=0;//  variavel auxiliar para função do ntc 
.................... float temperatura=0;//  variavel auxiliar para função do ntc 
.................... char umidade;//  variavel auxiliar para função do ntc 
....................  double a = 0.0011303; //  constantes fisicas do sensor ntc 10k 
....................  double b = 0.0002339; //  constantes fisicas do sensor ntc 10k 
....................  double c = 0.00000008863; //  constantes fisicas do sensor ntc 10k 
....................  int cont=0; 
....................  long valor_AD; // recebe o valor da conversao AD 
....................  long INT filtro_b1  = t_filtro; 
....................  int flags=0;            // utilizada para no deboccing para sinalizar 
.................... int cont_config=0;            // variavel q sinaliza quando o botao configuraçao é pressionado por mais de 500ms 
.................... float value1;         // auxilia na conversão do valor OBTIDO APOS ADC para TEMPERATURA E UMIDADE 
.................... float set_temp =0;   // valor de refeencia pra temperatura maxima 
.................... float set_umi =0; // valor de referencia para a umidade 
.................... #bit  BTN_B1 = flags.0  
....................  
....................  
.................... // FUNÇÃO POR INICIAR A DHT11 
....................  
.................... void start_signal(){ 
....................   Data_Pin_Direction = 0;              // Configure connection pin as output 
*
18A8:  BCF    x86.7
....................   Data_Pin = 0;                        // Connection pin output low 
18AA:  BCF    06.7
....................   delay_ms(25); 
18AC:  MOVLW  19
18AE:  MOVWF  55
18B0:  CALL   00E6
....................   Data_Pin = 1;                        // Connection pin output high 
18B4:  BSF    06.7
....................   delay_us(30); 
18B6:  MOVLW  31
18B8:  MOVWF  00
18BA:  DECFSZ 00,F
18BC:  BRA    18BA
18BE:  BRA    18C0
....................   Data_Pin_Direction = 1;              // Configure connection pin as input 
18C0:  BSF    x86.7
18C2:  GOTO   19CC (RETURN)
.................... } 
....................  
.................... // FUNÇAÕ POR VERIFICAR SE O SENSOR ESTA RESPONDENDO  
....................  
....................   short check_response(){ 
....................   delay_us(40); 
18C6:  MOVLW  42
18C8:  MOVWF  00
18CA:  DECFSZ 00,F
18CC:  BRA    18CA
18CE:  NOP   
....................   if(!Data_Pin){                     // Read and test if connection pin is low 
18D0:  BTFSC  06.7
18D2:  BRA    18F4
....................     delay_us(80); 
18D4:  MOVLW  84
18D6:  MOVWF  00
18D8:  DECFSZ 00,F
18DA:  BRA    18D8
18DC:  BRA    18DE
18DE:  NOP   
....................     if(Data_Pin){                    // Read and test if connection pin is high 
18E0:  BTFSS  06.7
18E2:  BRA    18F4
....................       delay_us(50); 
18E4:  MOVLW  52
18E6:  MOVWF  00
18E8:  DECFSZ 00,F
18EA:  BRA    18E8
18EC:  BRA    18EE
18EE:  NOP   
....................       return 1;} 
18F0:  MOVLW  01
18F2:  MOVWF  01
....................     } 
18F4:  GOTO   19CE (RETURN)
.................... } 
....................  
....................  
.................... // FUNÇÃO PARA A OBTENÇÃO DO VALOR DE HUMIDADE 
.................... unsigned int8 Read_Data(){ 
18F8:  CLRF   56
....................   unsigned int8 i, k, _data = 0;     // k is used to count 1 bit reading duration 
....................   if(Time_out) 
18FA:  BTFSS  18.0
18FC:  BRA    18FE
....................     break; 
....................   for(i = 0; i < 8; i++){ 
18FE:  CLRF   54
1900:  MOVF   54,W
1902:  SUBLW  07
1904:  BNC   198A
....................     k = 0; 
1906:  CLRF   55
....................     while(!Data_Pin){                          // Wait until pin goes high 
1908:  BTFSC  06.7
190A:  BRA    1920
....................       k++; 
190C:  INCF   55,F
....................       if (k > 100) {Time_out = 1; break;} 
190E:  MOVF   55,W
1910:  SUBLW  64
1912:  BC    1918
1914:  BSF    18.0
1916:  BRA    1920
....................       delay_us(1);} 
1918:  BRA    191A
191A:  BRA    191C
191C:  NOP   
191E:  BRA    1908
....................     delay_us(30); 
1920:  MOVLW  31
1922:  MOVWF  00
1924:  DECFSZ 00,F
1926:  BRA    1924
1928:  BRA    192A
....................     if(!Data_Pin) 
192A:  BTFSC  06.7
192C:  BRA    1950
....................       bit_clear(_data, (7 - i));               // Clear bit (7 - i) 
192E:  MOVLW  07
1930:  BSF    FD8.0
1932:  SUBFWB 54,W
1934:  MOVWF  57
1936:  MOVLW  01
1938:  MOVWF  00
193A:  MOVF   57,W
193C:  MOVWF  01
193E:  BZ    1948
1940:  BCF    FD8.0
1942:  RLCF   00,F
1944:  DECFSZ 01,F
1946:  BRA    1940
1948:  MOVF   00,W
194A:  XORLW  FF
194C:  ANDWF  56,F
194E:  BRA    1986
....................     else{ 
....................       bit_set(_data, (7 - i));                 // Set bit (7 - i) 
1950:  MOVLW  07
1952:  BSF    FD8.0
1954:  SUBFWB 54,W
1956:  MOVWF  57
1958:  MOVLW  01
195A:  MOVWF  00
195C:  MOVF   57,W
195E:  MOVWF  01
1960:  BZ    196A
1962:  BCF    FD8.0
1964:  RLCF   00,F
1966:  DECFSZ 01,F
1968:  BRA    1962
196A:  MOVF   00,W
196C:  IORWF  56,F
....................       while(Data_Pin){                         // Wait until pin goes low 
196E:  BTFSS  06.7
1970:  BRA    1986
....................       k++; 
1972:  INCF   55,F
....................       if (k > 100) {Time_out = 1; break;} 
1974:  MOVF   55,W
1976:  SUBLW  64
1978:  BC    197E
197A:  BSF    18.0
197C:  BRA    1986
....................       delay_us(1);} 
197E:  BRA    1980
1980:  BRA    1982
1982:  NOP   
1984:  BRA    196E
....................     } 
1986:  INCF   54,F
1988:  BRA    1900
....................   } 
....................   return _data; 
198A:  MOVFF  56,01
198E:  RETURN 0
.................... } 
....................  
.................... // FUNÇÃO PRINCIPAL QUE RETORNARA A UMIDADE  
....................  
.................... char dht11(){ 
....................    delay_ms(1000); 
*
19B8:  MOVLW  04
19BA:  MOVWF  54
19BC:  MOVLW  FA
19BE:  MOVWF  55
19C0:  CALL   00E6
19C4:  DECFSZ 54,F
19C6:  BRA    19BC
....................    Time_out = 0; 
19C8:  BCF    18.0
....................    Start_signal(); 
19CA:  BRA    18A8
....................    if(check_response()){// If there is response from sensor 
19CC:  BRA    18C6
19CE:  MOVF   01,F
19D0:  BZ    1A1C
....................    RH_byte1=Read_Data();// read RH byte1 
19D2:  RCALL  18F8
19D4:  MOVFF  01,19
....................    RH_byte2=Read_Data();// read RH byte2 
19D8:  RCALL  18F8
19DA:  MOVFF  01,1A
....................    Checksum=Read_Data();// read checksum                    
19DE:  RCALL  18F8
19E0:  MOVFF  01,1B
....................       if(CheckSum==((RH_Byte1+RH_Byte2)& 0xFF)){ 
19E4:  MOVF   1A,W
19E6:  ADDWF  19,W
19E8:  SUBWF  1B,W
19EA:  BNZ   1A1C
....................       message2[7]=RH_Byte1/10+48; 
19EC:  MOVFF  19,54
19F0:  MOVLW  0A
19F2:  MOVWF  55
19F4:  RCALL  1990
19F6:  MOVLW  30
19F8:  ADDWF  01,W
19FA:  MOVWF  11
....................              message2[8]= RH_Byte1%10+48; 
19FC:  MOVFF  19,54
1A00:  MOVLW  0A
1A02:  MOVWF  55
1A04:  RCALL  1990
1A06:  MOVLW  30
1A08:  ADDWF  00,W
1A0A:  MOVWF  12
....................              message2[10] = RH_Byte2/10+48;                             
1A0C:  MOVFF  1A,54
1A10:  MOVLW  0A
1A12:  MOVWF  55
1A14:  RCALL  1990
1A16:  MOVLW  30
1A18:  ADDWF  01,W
1A1A:  MOVWF  14
....................        } 
....................    }  
....................    return message2; 
1A1C:  MOVLW  0A
1A1E:  MOVWF  01
1A20:  MOVLW  00
1A22:  MOVWF  02
1A24:  GOTO   22DA (RETURN)
.................... } 
....................  
....................  
....................  
.................... // Função Para conversao do valor obtido na ADC, para o fundo de escala trabalhando para a temperatura 0->50  
.................... void conversao_temp (){   
....................  
....................       set_adc_channel(2); // seleciona o canal 2 do pic, para a ADC 
*
1A64:  MOVLW  08
1A66:  MOVWF  01
1A68:  MOVF   FC2,W
1A6A:  ANDLW  C3
1A6C:  IORWF  01,W
1A6E:  MOVWF  FC2
....................       delay_us(10); 
1A70:  MOVLW  10
1A72:  MOVWF  00
1A74:  DECFSZ 00,F
1A76:  BRA    1A74
1A78:  NOP   
....................       while(!adc_done()); // espera o fim enquanto a ADC  
1A7A:  BTFSC  FC2.1
1A7C:  BRA    1A7A
....................       valor_AD = read_adc(); // lendo o valor da ADC 
1A7E:  BSF    FC2.1
1A80:  BTFSC  FC2.1
1A82:  BRA    1A80
1A84:  MOVFF  FC3,42
1A88:  MOVFF  FC4,43
....................       value1= (float)valor_AD; // passa o valor de 0 a 1023 para float; atribiu este a variavel auxiliar value1 
1A8C:  MOVFF  43,85
1A90:  MOVFF  42,84
1A94:  CALL   0154
1A98:  MOVFF  03,4B
1A9C:  MOVFF  02,4A
1AA0:  MOVFF  01,49
1AA4:  MOVFF  00,48
....................       value1=value1*0.5/10.23; // Faz o ajuste de escala 0°->0 e 50°->1023; o valor 0.5 é o resoluçao 
1AA8:  MOVFF  4B,83
1AAC:  MOVFF  4A,82
1AB0:  MOVFF  49,81
1AB4:  MOVFF  48,80
1AB8:  CLRF   x87
1ABA:  CLRF   x86
1ABC:  CLRF   x85
1ABE:  MOVLW  7E
1AC0:  MOVWF  x84
1AC2:  CALL   018A
1AC6:  MOVFF  03,57
1ACA:  MOVFF  02,56
1ACE:  MOVFF  01,55
1AD2:  MOVFF  00,54
1AD6:  MOVFF  03,7C
1ADA:  MOVFF  02,7B
1ADE:  MOVFF  01,7A
1AE2:  MOVFF  00,79
1AE6:  MOVLW  14
1AE8:  MOVWF  x80
1AEA:  MOVLW  AE
1AEC:  MOVWF  x7F
1AEE:  MOVLW  23
1AF0:  MOVWF  x7E
1AF2:  MOVLW  82
1AF4:  MOVWF  x7D
1AF6:  CALL   027C
1AFA:  MOVFF  03,4B
1AFE:  MOVFF  02,4A
1B02:  MOVFF  01,49
1B06:  MOVFF  00,48
....................        
....................       value1 = (float)((int)((value1 + 0.4f) * 2.0f)) * 0.5f; 
1B0A:  BCF    FD8.1
1B0C:  MOVFF  4B,87
1B10:  MOVFF  4A,86
1B14:  MOVFF  49,85
1B18:  MOVFF  48,84
1B1C:  MOVLW  CD
1B1E:  MOVWF  x8B
1B20:  MOVLW  CC
1B22:  MOVWF  x8A
1B24:  MOVLW  4C
1B26:  MOVWF  x89
1B28:  MOVLW  7D
1B2A:  MOVWF  x88
1B2C:  CALL   03D6
1B30:  MOVFF  03,57
1B34:  MOVFF  02,56
1B38:  MOVFF  01,55
1B3C:  MOVFF  00,54
1B40:  MOVFF  03,83
1B44:  MOVFF  02,82
1B48:  MOVFF  01,81
1B4C:  MOVFF  00,80
1B50:  CLRF   x87
1B52:  CLRF   x86
1B54:  CLRF   x85
1B56:  MOVLW  80
1B58:  MOVWF  x84
1B5A:  CALL   018A
1B5E:  MOVFF  03,83
1B62:  MOVFF  02,82
1B66:  MOVFF  01,81
1B6A:  MOVFF  00,80
1B6E:  CALL   0A3E
1B72:  CLRF   x85
1B74:  MOVFF  01,84
1B78:  CALL   0154
1B7C:  MOVFF  03,57
1B80:  MOVFF  02,56
1B84:  MOVFF  01,55
1B88:  MOVFF  00,54
1B8C:  MOVFF  03,83
1B90:  MOVFF  02,82
1B94:  MOVFF  01,81
1B98:  MOVFF  00,80
1B9C:  CLRF   x87
1B9E:  CLRF   x86
1BA0:  CLRF   x85
1BA2:  MOVLW  7E
1BA4:  MOVWF  x84
1BA6:  CALL   018A
1BAA:  MOVFF  03,4B
1BAE:  MOVFF  02,4A
1BB2:  MOVFF  01,49
1BB6:  MOVFF  00,48
1BBA:  GOTO   1FC4 (RETURN)
.................... } 
....................  
.................... // Função Para conversao do valor obtido na ADC, para o fundo de escala trabalhando para a umidade 0->100  
.................... void conversao_umi (){ 
....................  
....................      set_adc_channel(2);// seleciona o canal 2 do pic, para a ADC 
*
1E24:  MOVLW  08
1E26:  MOVWF  01
1E28:  MOVF   FC2,W
1E2A:  ANDLW  C3
1E2C:  IORWF  01,W
1E2E:  MOVWF  FC2
....................       delay_us(10); 
1E30:  MOVLW  10
1E32:  MOVWF  00
1E34:  DECFSZ 00,F
1E36:  BRA    1E34
1E38:  NOP   
....................       while(!adc_done());// espera o fim enquanto a ADC  
1E3A:  BTFSC  FC2.1
1E3C:  BRA    1E3A
....................       valor_AD = read_adc();// lendo o valor da ADC 
1E3E:  BSF    FC2.1
1E40:  BTFSC  FC2.1
1E42:  BRA    1E40
1E44:  MOVFF  FC3,42
1E48:  MOVFF  FC4,43
....................       value1= (float)valor_AD; // passa o valor de 0 a 1023 para float; atribiu este a variavel auxiliar value1 
1E4C:  MOVFF  43,85
1E50:  MOVFF  42,84
1E54:  CALL   0154
1E58:  MOVFF  03,4B
1E5C:  MOVFF  02,4A
1E60:  MOVFF  01,49
1E64:  MOVFF  00,48
....................       value1= value1*10/102.3;// Faz o ajuste de escala 0->0 e 100->1023; o valor 10 é o resoluçao 
1E68:  MOVFF  4B,83
1E6C:  MOVFF  4A,82
1E70:  MOVFF  49,81
1E74:  MOVFF  48,80
1E78:  CLRF   x87
1E7A:  CLRF   x86
1E7C:  MOVLW  20
1E7E:  MOVWF  x85
1E80:  MOVLW  82
1E82:  MOVWF  x84
1E84:  CALL   018A
1E88:  MOVFF  03,57
1E8C:  MOVFF  02,56
1E90:  MOVFF  01,55
1E94:  MOVFF  00,54
1E98:  MOVFF  03,7C
1E9C:  MOVFF  02,7B
1EA0:  MOVFF  01,7A
1EA4:  MOVFF  00,79
1EA8:  MOVLW  9A
1EAA:  MOVWF  x80
1EAC:  MOVLW  99
1EAE:  MOVWF  x7F
1EB0:  MOVLW  4C
1EB2:  MOVWF  x7E
1EB4:  MOVLW  85
1EB6:  MOVWF  x7D
1EB8:  CALL   027C
1EBC:  MOVFF  03,4B
1EC0:  MOVFF  02,4A
1EC4:  MOVFF  01,49
1EC8:  MOVFF  00,48
....................       value1 = (float)((int)((value1 + 0.4f) * 2.0f)) * 0.5f; 
1ECC:  BCF    FD8.1
1ECE:  MOVFF  4B,87
1ED2:  MOVFF  4A,86
1ED6:  MOVFF  49,85
1EDA:  MOVFF  48,84
1EDE:  MOVLW  CD
1EE0:  MOVWF  x8B
1EE2:  MOVLW  CC
1EE4:  MOVWF  x8A
1EE6:  MOVLW  4C
1EE8:  MOVWF  x89
1EEA:  MOVLW  7D
1EEC:  MOVWF  x88
1EEE:  CALL   03D6
1EF2:  MOVFF  03,57
1EF6:  MOVFF  02,56
1EFA:  MOVFF  01,55
1EFE:  MOVFF  00,54
1F02:  MOVFF  03,83
1F06:  MOVFF  02,82
1F0A:  MOVFF  01,81
1F0E:  MOVFF  00,80
1F12:  CLRF   x87
1F14:  CLRF   x86
1F16:  CLRF   x85
1F18:  MOVLW  80
1F1A:  MOVWF  x84
1F1C:  CALL   018A
1F20:  MOVFF  03,83
1F24:  MOVFF  02,82
1F28:  MOVFF  01,81
1F2C:  MOVFF  00,80
1F30:  CALL   0A3E
1F34:  CLRF   x85
1F36:  MOVFF  01,84
1F3A:  CALL   0154
1F3E:  MOVFF  03,57
1F42:  MOVFF  02,56
1F46:  MOVFF  01,55
1F4A:  MOVFF  00,54
1F4E:  MOVFF  03,83
1F52:  MOVFF  02,82
1F56:  MOVFF  01,81
1F5A:  MOVFF  00,80
1F5E:  CLRF   x87
1F60:  CLRF   x86
1F62:  CLRF   x85
1F64:  MOVLW  7E
1F66:  MOVWF  x84
1F68:  CALL   018A
1F6C:  MOVFF  03,4B
1F70:  MOVFF  02,4A
1F74:  MOVFF  01,49
1F78:  MOVFF  00,48
1F7C:  GOTO   2042 (RETURN)
.................... } 
....................  
....................  
.................... // Funçao para a configuraçao dos parametros de temperatura e umidade da incubadora 
.................... void configuracao () { 
....................  
....................                       cont_config++;// toda vez que o botao é pressionado o contador é incrementado 
1F80:  INCF   47,F
....................                       limpa_lcd (); // limpa o lcd 
1F82:  CALL   010C
....................                     if(cont_config==5){ 
1F86:  MOVF   47,W
1F88:  SUBLW  05
1F8A:  BNZ   1F8E
....................                        cont_config=0; 
1F8C:  CLRF   47
....................                     } 
....................                     if(cont_config==1){ 
1F8E:  DECFSZ 47,W
1F90:  BRA    1FBE
....................                         printf(escreve_lcd, "CONFIGURACAO"); 
1F92:  MOVLW  04
1F94:  MOVWF  FF6
1F96:  MOVLW  00
1F98:  MOVWF  FF7
1F9A:  RCALL  1A44
....................                         comando_lcd(0xC0); 
1F9C:  MOVLW  C0
1F9E:  MOVWF  54
1FA0:  CALL   00CA
....................                         printf(escreve_lcd, "INCUBADORA"); 
1FA4:  MOVLW  12
1FA6:  MOVWF  FF6
1FA8:  MOVLW  00
1FAA:  MOVWF  FF7
1FAC:  RCALL  1A44
....................                         
....................                         delay_ms (1000); 
1FAE:  MOVLW  04
1FB0:  MOVWF  54
1FB2:  MOVLW  FA
1FB4:  MOVWF  55
1FB6:  CALL   00E6
1FBA:  DECFSZ 54,F
1FBC:  BRA    1FB2
....................                      
....................                     } 
....................                    while(cont_config==1){ // neste primeiro laço a temperatura max. deverá ser definida por meio do poteciometro 
1FBE:  DECFSZ 47,W
1FC0:  BRA    203A
....................                         conversao_temp ();// chama a funçao para a conversao  
1FC2:  BRA    1A64
....................                         printf(escreve_lcd, "CONFIGURACAO"); 
1FC4:  MOVLW  1E
1FC6:  MOVWF  FF6
1FC8:  MOVLW  00
1FCA:  MOVWF  FF7
1FCC:  RCALL  1A44
....................                         comando_lcd(0xC0);// posiciona o cursor no endereço 83h 
1FCE:  MOVLW  C0
1FD0:  MOVWF  54
1FD2:  CALL   00CA
....................                   
....................                         printf(escreve_lcd, "SET TEMP: %.1f       ", value1);  // escrever no lcd os valores de temperatura correpontedes a variaçao do potenciometro 
1FD6:  MOVLW  2C
1FD8:  MOVWF  FF6
1FDA:  MOVLW  00
1FDC:  MOVWF  FF7
1FDE:  MOVLW  0A
1FE0:  MOVWF  54
1FE2:  RCALL  1BBE
1FE4:  MOVLW  89
1FE6:  MOVWF  FE9
1FE8:  MOVFF  4B,57
1FEC:  MOVFF  4A,56
1FF0:  MOVFF  49,55
1FF4:  MOVFF  48,54
1FF8:  MOVLW  01
1FFA:  MOVWF  58
1FFC:  RCALL  1CAA
1FFE:  MOVLW  3A
2000:  MOVWF  FF6
2002:  MOVLW  00
2004:  MOVWF  FF7
2006:  MOVLW  07
2008:  MOVWF  54
200A:  RCALL  1BBE
....................                         delay_ms (400); //  delay necessario para que o estado da porta onde o botao está ligado volte ao estado incial apos o aperto. 
200C:  MOVLW  02
200E:  MOVWF  54
2010:  MOVLW  C8
2012:  MOVWF  55
2014:  CALL   00E6
2018:  DECFSZ 54,F
201A:  BRA    2010
....................                       
....................                        
....................                          
....................                         if(config_Bot==0){ // ao pressionar o botão por um tempo superior a 500ms Ffinaliza o primeiro laço e entra no segundo laço. 
201C:  BTFSC  F81.4
201E:  BRA    2038
....................                             limpa_lcd (); 
2020:  CALL   010C
....................                             set_temp = value1; // ATUALIZAÇAO DO VALOR DA VARIAVEL DE REFERENCIA APOS A ESCOLHA DO VALOR ATRAVÉS DO POTENCIOMETRO 
2024:  MOVFF  4B,4F
2028:  MOVFF  4A,4E
202C:  MOVFF  49,4D
2030:  MOVFF  48,4C
....................                              cont_config=2; 
2034:  MOVLW  02
2036:  MOVWF  47
....................                         } 
2038:  BRA    1FBE
....................                    } // fim do 1 laço 
....................                         while(cont_config==2){ // Neste segundo laço será defenido o valor da temperatura min. e imprimmi no lcd 
203A:  MOVF   47,W
203C:  SUBLW  02
203E:  BNZ   20B8
....................                            conversao_umi ();  
2040:  BRA    1E24
....................                           printf(escreve_lcd, "CONFIGURACAO"); 
2042:  MOVLW  42
2044:  MOVWF  FF6
2046:  MOVLW  00
2048:  MOVWF  FF7
204A:  RCALL  1A44
....................                            comando_lcd(0xC0); 
204C:  MOVLW  C0
204E:  MOVWF  54
2050:  CALL   00CA
....................                            printf(escreve_lcd, "SET UMI: %.1f      ", value1); 
2054:  MOVLW  50
2056:  MOVWF  FF6
2058:  MOVLW  00
205A:  MOVWF  FF7
205C:  MOVLW  09
205E:  MOVWF  54
2060:  RCALL  1BBE
2062:  MOVLW  89
2064:  MOVWF  FE9
2066:  MOVFF  4B,57
206A:  MOVFF  4A,56
206E:  MOVFF  49,55
2072:  MOVFF  48,54
2076:  MOVLW  01
2078:  MOVWF  58
207A:  RCALL  1CAA
207C:  MOVLW  5D
207E:  MOVWF  FF6
2080:  MOVLW  00
2082:  MOVWF  FF7
2084:  MOVLW  06
2086:  MOVWF  54
2088:  RCALL  1BBE
....................                            delay_ms (400); 
208A:  MOVLW  02
208C:  MOVWF  54
208E:  MOVLW  C8
2090:  MOVWF  55
2092:  CALL   00E6
2096:  DECFSZ 54,F
2098:  BRA    208E
....................                              
....................                             
....................                        
....................                            if(config_Bot==0){ 
209A:  BTFSC  F81.4
209C:  BRA    20B6
....................                                limpa_lcd (); 
209E:  CALL   010C
....................                                set_umi = value1; // ATUALIZAÇAO DO VALOR DA VARIAVEL DE REFERENCIA APOS A ESCOLHA DO VALOR ATRAVÉS DO POTENCIOMETRO 
20A2:  MOVFF  4B,53
20A6:  MOVFF  4A,52
20AA:  MOVFF  49,51
20AE:  MOVFF  48,50
....................                                cont_config=4; 
20B2:  MOVLW  04
20B4:  MOVWF  47
....................                            } 
20B6:  BRA    203A
....................                         }//fim do 2 laço 
....................                              
....................                               while(cont_config==4){ // fim da configuração  
20B8:  MOVF   47,W
20BA:  SUBLW  04
20BC:  BTFSS  FD8.2
20BE:  BRA    21D2
....................                                
....................                               comando_lcd(0x80); 
20C0:  MOVLW  80
20C2:  MOVWF  54
20C4:  CALL   00CA
....................                               printf(escreve_lcd, "SET TEMP:  %.1f        ", set_temp); 
20C8:  MOVLW  64
20CA:  MOVWF  FF6
20CC:  MOVLW  00
20CE:  MOVWF  FF7
20D0:  MOVLW  0B
20D2:  MOVWF  54
20D4:  RCALL  1BBE
20D6:  MOVLW  89
20D8:  MOVWF  FE9
20DA:  MOVFF  4F,57
20DE:  MOVFF  4E,56
20E2:  MOVFF  4D,55
20E6:  MOVFF  4C,54
20EA:  MOVLW  01
20EC:  MOVWF  58
20EE:  RCALL  1CAA
20F0:  MOVLW  73
20F2:  MOVWF  FF6
20F4:  MOVLW  00
20F6:  MOVWF  FF7
20F8:  MOVLW  08
20FA:  MOVWF  54
20FC:  RCALL  1BBE
....................                               delay_ms (2000); 
20FE:  MOVLW  08
2100:  MOVWF  54
2102:  MOVLW  FA
2104:  MOVWF  55
2106:  CALL   00E6
210A:  DECFSZ 54,F
210C:  BRA    2102
....................                               
....................                               comando_lcd(0xC0); 
210E:  MOVLW  C0
2110:  MOVWF  54
2112:  CALL   00CA
....................                               printf(escreve_lcd, "SET UMI:   %.1f       ", set_umi); 
2116:  MOVLW  7C
2118:  MOVWF  FF6
211A:  MOVLW  00
211C:  MOVWF  FF7
211E:  MOVLW  0B
2120:  MOVWF  54
2122:  RCALL  1BBE
2124:  MOVLW  89
2126:  MOVWF  FE9
2128:  MOVFF  53,57
212C:  MOVFF  52,56
2130:  MOVFF  51,55
2134:  MOVFF  50,54
2138:  MOVLW  01
213A:  MOVWF  58
213C:  RCALL  1CAA
213E:  MOVLW  8B
2140:  MOVWF  FF6
2142:  MOVLW  00
2144:  MOVWF  FF7
2146:  MOVLW  07
2148:  MOVWF  54
214A:  RCALL  1BBE
....................                               delay_ms (2000); 
214C:  MOVLW  08
214E:  MOVWF  54
2150:  MOVLW  FA
2152:  MOVWF  55
2154:  CALL   00E6
2158:  DECFSZ 54,F
215A:  BRA    2150
....................                                
....................                               cont_config=5; 
215C:  MOVLW  05
215E:  MOVWF  47
....................                                
....................                                
....................                               limpa_lcd(); 
2160:  CALL   010C
....................                               comando_lcd(0x80); 
2164:  MOVLW  80
2166:  MOVWF  54
2168:  CALL   00CA
....................                               printf(escreve_lcd, "FIM DA"); 
216C:  MOVLW  94
216E:  MOVWF  FF6
2170:  MOVLW  00
2172:  MOVWF  FF7
2174:  RCALL  1A44
....................                               comando_lcd(0xC0); 
2176:  MOVLW  C0
2178:  MOVWF  54
217A:  CALL   00CA
....................                               printf(escreve_lcd, "CONFIGURACAO"); 
217E:  MOVLW  9C
2180:  MOVWF  FF6
2182:  MOVLW  00
2184:  MOVWF  FF7
2186:  RCALL  1A44
....................                               delay_ms (1000); 
2188:  MOVLW  04
218A:  MOVWF  54
218C:  MOVLW  FA
218E:  MOVWF  55
2190:  CALL   00E6
2194:  DECFSZ 54,F
2196:  BRA    218C
....................                               limpa_lcd(); 
2198:  CALL   010C
....................                                
....................                               comando_lcd(0x80); 
219C:  MOVLW  80
219E:  MOVWF  54
21A0:  CALL   00CA
....................                               printf(escreve_lcd, "Aperte o botao"); 
21A4:  MOVLW  AA
21A6:  MOVWF  FF6
21A8:  MOVLW  00
21AA:  MOVWF  FF7
21AC:  RCALL  1A44
....................                               comando_lcd(0xC0); 
21AE:  MOVLW  C0
21B0:  MOVWF  54
21B2:  CALL   00CA
....................                               printf(escreve_lcd, "INICIAR"); 
21B6:  MOVLW  BA
21B8:  MOVWF  FF6
21BA:  MOVLW  00
21BC:  MOVWF  FF7
21BE:  RCALL  1A44
....................                               delay_ms (1000); 
21C0:  MOVLW  04
21C2:  MOVWF  54
21C4:  MOVLW  FA
21C6:  MOVWF  55
21C8:  CALL   00E6
21CC:  DECFSZ 54,F
21CE:  BRA    21C4
21D0:  BRA    20B8
....................                               /*  
....................                               #### AQUI TERMINA A CONFIGURAÇÃO DOS PARÂMETROS DA INCUBADORA 
....................                                   AO PRESSIONAR O BOTAO DE CONFIGURAÇÃO  2 VEZES VOLTA-SE PARA CONFIGURAR NOVAMENTE OS 
....................                                   PARÂMETROS. 
....................                                
....................                                
....................                               */ 
....................                              } 
21D2:  GOTO   22FA (RETURN)
....................                            
....................  
....................  
....................  
.................... } // FIM DA FUNÇÃO CONFIGURAÇAO 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... float ntc(){ 
.................... set_adc_channel(0); //  escolhe o pino analogico para ler   
*
15DC:  MOVLW  00
15DE:  MOVWF  01
15E0:  MOVF   FC2,W
15E2:  ANDLW  C3
15E4:  IORWF  01,W
15E6:  MOVWF  FC2
.................... delay_us(10); // delay para começar a conversão 
15E8:  MOVLW  10
15EA:  MOVWF  00
15EC:  DECFSZ 00,F
15EE:  BRA    15EC
15F0:  NOP   
.................... read_adc(ADC_START_ONLY ); 
15F2:  BSF    FC2.1
.................... while(!adc_done()){ 
15F4:  BTFSS  FC2.1
15F6:  BRA    15FA
15F8:  BRA    15F4
.................... } 
.................... ntc_val = read_adc(ADC_READ_ONLY ); // le o valor na porta analogica 
15FA:  BTFSC  FC2.1
15FC:  BRA    15FA
15FE:  MOVFF  FC4,03
1602:  MOVFF  FC3,84
1606:  MOVFF  FC4,85
160A:  CALL   0154
160E:  MOVFF  03,1F
1612:  MOVFF  02,1E
1616:  MOVFF  01,1D
161A:  MOVFF  00,1C
.................... ntc_val *=5; // multiplica o valor digitalizado pelo valor de tensão de alimentação 
161E:  MOVFF  1F,83
1622:  MOVFF  1E,82
1626:  MOVFF  1D,81
162A:  MOVFF  1C,80
162E:  CLRF   x87
1630:  CLRF   x86
1632:  MOVLW  20
1634:  MOVWF  x85
1636:  MOVLW  81
1638:  MOVWF  x84
163A:  CALL   018A
163E:  MOVFF  03,1F
1642:  MOVFF  02,1E
1646:  MOVFF  01,1D
164A:  MOVFF  00,1C
.................... ntc_val/=1023;  // divide  o valor acima por 1023 
164E:  MOVFF  1F,7C
1652:  MOVFF  1E,7B
1656:  MOVFF  1D,7A
165A:  MOVFF  1C,79
165E:  CLRF   x80
1660:  MOVLW  C0
1662:  MOVWF  x7F
1664:  MOVLW  7F
1666:  MOVWF  x7E
1668:  MOVLW  88
166A:  MOVWF  x7D
166C:  CALL   027C
1670:  MOVFF  03,1F
1674:  MOVFF  02,1E
1678:  MOVFF  01,1D
167C:  MOVFF  00,1C
.................... // Inicio calculo de equação de  Steinhart & Hart  
.................... rntc=50000/ntc_val;      
1680:  CLRF   x7C
1682:  MOVLW  50
1684:  MOVWF  x7B
1686:  MOVLW  43
1688:  MOVWF  x7A
168A:  MOVLW  8E
168C:  MOVWF  x79
168E:  MOVFF  1F,80
1692:  MOVFF  1E,7F
1696:  MOVFF  1D,7E
169A:  MOVFF  1C,7D
169E:  CALL   027C
16A2:  MOVFF  03,23
16A6:  MOVFF  02,22
16AA:  MOVFF  01,21
16AE:  MOVFF  00,20
....................        rntc=rntc-10000;       
16B2:  BSF    FD8.1
16B4:  MOVFF  23,87
16B8:  MOVFF  22,86
16BC:  MOVFF  21,85
16C0:  MOVFF  20,84
16C4:  CLRF   x8B
16C6:  MOVLW  40
16C8:  MOVWF  x8A
16CA:  MOVLW  1C
16CC:  MOVWF  x89
16CE:  MOVLW  8C
16D0:  MOVWF  x88
16D2:  CALL   03D6
16D6:  MOVFF  03,23
16DA:  MOVFF  02,22
16DE:  MOVFF  01,21
16E2:  MOVFF  00,20
....................        b1=log(rntc);           
16E6:  MOVFF  23,63
16EA:  MOVFF  22,62
16EE:  MOVFF  21,61
16F2:  MOVFF  20,60
16F6:  CALL   06FE
16FA:  MOVFF  03,27
16FE:  MOVFF  02,26
1702:  MOVFF  01,25
1706:  MOVFF  00,24
....................        b1=b1*b;                
170A:  MOVFF  27,83
170E:  MOVFF  26,82
1712:  MOVFF  25,81
1716:  MOVFF  24,80
171A:  MOVFF  3C,87
171E:  MOVFF  3B,86
1722:  MOVFF  3A,85
1726:  MOVFF  39,84
172A:  CALL   018A
172E:  MOVFF  03,27
1732:  MOVFF  02,26
1736:  MOVFF  01,25
173A:  MOVFF  00,24
....................        c1=log(rntc);           
173E:  MOVFF  23,63
1742:  MOVFF  22,62
1746:  MOVFF  21,61
174A:  MOVFF  20,60
174E:  CALL   06FE
1752:  MOVFF  03,2B
1756:  MOVFF  02,2A
175A:  MOVFF  01,29
175E:  MOVFF  00,28
....................        c1=pow(c1,3);           
1762:  MOVFF  2B,57
1766:  MOVFF  2A,56
176A:  MOVFF  29,55
176E:  MOVFF  28,54
1772:  CLRF   5B
1774:  CLRF   5A
1776:  MOVLW  40
1778:  MOVWF  59
177A:  MOVLW  80
177C:  MOVWF  58
177E:  BRA    1306
1780:  MOVFF  03,2B
1784:  MOVFF  02,2A
1788:  MOVFF  01,29
178C:  MOVFF  00,28
....................        c1=c1*c;                
1790:  MOVFF  2B,83
1794:  MOVFF  2A,82
1798:  MOVFF  29,81
179C:  MOVFF  28,80
17A0:  MOVFF  40,87
17A4:  MOVFF  3F,86
17A8:  MOVFF  3E,85
17AC:  MOVFF  3D,84
17B0:  CALL   018A
17B4:  MOVFF  03,2B
17B8:  MOVFF  02,2A
17BC:  MOVFF  01,29
17C0:  MOVFF  00,28
....................        temp=a+b1+c1;           
17C4:  BCF    FD8.1
17C6:  MOVFF  38,87
17CA:  MOVFF  37,86
17CE:  MOVFF  36,85
17D2:  MOVFF  35,84
17D6:  MOVFF  27,8B
17DA:  MOVFF  26,8A
17DE:  MOVFF  25,89
17E2:  MOVFF  24,88
17E6:  CALL   03D6
17EA:  MOVFF  03,57
17EE:  MOVFF  02,56
17F2:  MOVFF  01,55
17F6:  MOVFF  00,54
17FA:  BCF    FD8.1
17FC:  MOVFF  03,87
1800:  MOVFF  02,86
1804:  MOVFF  01,85
1808:  MOVFF  00,84
180C:  MOVFF  2B,8B
1810:  MOVFF  2A,8A
1814:  MOVFF  29,89
1818:  MOVFF  28,88
181C:  CALL   03D6
1820:  MOVFF  03,2F
1824:  MOVFF  02,2E
1828:  MOVFF  01,2D
182C:  MOVFF  00,2C
....................        temp=1/temp;            
1830:  CLRF   x7C
1832:  CLRF   x7B
1834:  CLRF   x7A
1836:  MOVLW  7F
1838:  MOVWF  x79
183A:  MOVFF  2F,80
183E:  MOVFF  2E,7F
1842:  MOVFF  2D,7E
1846:  MOVFF  2C,7D
184A:  CALL   027C
184E:  MOVFF  03,2F
1852:  MOVFF  02,2E
1856:  MOVFF  01,2D
185A:  MOVFF  00,2C
....................        temp=temp-273.15; 
185E:  BSF    FD8.1
1860:  MOVFF  2F,87
1864:  MOVFF  2E,86
1868:  MOVFF  2D,85
186C:  MOVFF  2C,84
1870:  MOVLW  33
1872:  MOVWF  x8B
1874:  MOVLW  93
1876:  MOVWF  x8A
1878:  MOVLW  08
187A:  MOVWF  x89
187C:  MOVLW  87
187E:  MOVWF  x88
1880:  CALL   03D6
1884:  MOVFF  03,2F
1888:  MOVFF  02,2E
188C:  MOVFF  01,2D
1890:  MOVFF  00,2C
....................        return temp; 
1894:  MOVFF  2C,00
1898:  MOVFF  2D,01
189C:  MOVFF  2E,02
18A0:  MOVFF  2F,03
18A4:  GOTO   22C6 (RETURN)
.................... // Fim do calculo de equação de  Steinhart & Hart 
.................... } 
....................  
....................  
....................  
....................  
.................... void mexeovos () { 
.................... // Essa função é responsável por controlar o servo motor que mexe os ovos 
.................... for( int j=0; j<=10; j++){  // j=50 é cerca de 5 min  
....................  // para garantir que a temperatura varie pouco enquanto o ovosestão mexendo faça   
....................    limpa_lcd(); 
....................    comando_lcd(0x83); //  posiciona o cursor no endereço 0x83 
....................    printf(escreve_lcd,"MEXENDO" ); 
....................    if(j%2==0){ 
....................    RELE_LAMP = 1; 
....................    PIN_COOLER = 0; 
....................    } 
....................      if(j%2!=0){ 
....................      RELE_LAMP = 0; 
....................      PIN_COOLER =1; 
....................      } 
.................... // termina aqui esse arficio  
....................       for(int i=0;  i<50; i++){                       
....................       PIN_SERV=1; 
....................       delay_us(800); 
....................       PIN_SERV=0; 
....................       delay_us(19200); 
....................       } 
....................       delay_ms(2000); 
....................       for(i=0;  i<50; i++){ 
....................       PIN_SERV=1; 
....................       delay_us(1500); 
....................       PIN_SERV=0; 
....................       delay_us(18500); 
....................       } 
....................       delay_ms(2000); 
....................  } 
....................     
.................... } 
....................  
.................... void main (void){ 
*
21D6:  CLRF   FF8
21D8:  BCF    FD0.7
21DA:  CLRF   1F
21DC:  CLRF   1E
21DE:  CLRF   1D
21E0:  CLRF   1C
21E2:  CLRF   23
21E4:  CLRF   22
21E6:  CLRF   21
21E8:  CLRF   20
21EA:  CLRF   27
21EC:  CLRF   26
21EE:  CLRF   25
21F0:  CLRF   24
21F2:  CLRF   2B
21F4:  CLRF   2A
21F6:  CLRF   29
21F8:  CLRF   28
21FA:  CLRF   2F
21FC:  CLRF   2E
21FE:  CLRF   2D
2200:  CLRF   2C
2202:  CLRF   33
2204:  CLRF   32
2206:  CLRF   31
2208:  CLRF   30
220A:  MOVLW  93
220C:  MOVWF  38
220E:  MOVLW  26
2210:  MOVWF  37
2212:  MOVLW  14
2214:  MOVWF  36
2216:  MOVLW  75
2218:  MOVWF  35
221A:  MOVLW  0E
221C:  MOVWF  3C
221E:  MOVLW  43
2220:  MOVWF  3B
2222:  MOVLW  75
2224:  MOVWF  3A
2226:  MOVLW  72
2228:  MOVWF  39
222A:  MOVLW  DC
222C:  MOVWF  40
222E:  MOVLW  54
2230:  MOVWF  3F
2232:  MOVLW  3E
2234:  MOVWF  3E
2236:  MOVLW  67
2238:  MOVWF  3D
223A:  CLRF   41
223C:  MOVLW  01
223E:  MOVWF  45
2240:  MOVLW  90
2242:  MOVWF  44
2244:  CLRF   46
2246:  CLRF   47
2248:  CLRF   4F
224A:  CLRF   4E
224C:  CLRF   4D
224E:  CLRF   4C
2250:  CLRF   53
2252:  CLRF   52
2254:  CLRF   51
2256:  CLRF   50
2258:  MOVF   FC1,W
225A:  ANDLW  C0
225C:  IORLW  0F
225E:  MOVWF  FC1
2260:  MOVLW  07
2262:  MOVWF  FB4
2264:  CLRF   04
2266:  CLRF   05
2268:  MOVLW  52
226A:  MOVWF  0A
226C:  MOVLW  48
226E:  MOVWF  0B
2270:  MOVLW  A0
2272:  MOVWF  0C
2274:  MOVWF  0D
2276:  MOVWF  0E
2278:  MOVLW  3D
227A:  MOVWF  0F
227C:  MOVLW  A0
227E:  MOVWF  10
2280:  MOVLW  30
2282:  MOVWF  11
2284:  MOVWF  12
2286:  MOVLW  2E
2288:  MOVWF  13
228A:  MOVLW  30
228C:  MOVWF  14
228E:  MOVLW  A0
2290:  MOVWF  15
2292:  MOVLW  25
2294:  MOVWF  16
2296:  CLRF   17
.................... setup_adc(ADC_CLOCK_DIV_32); //  configura o clock utilizado para o conversor ad e o pior clock ele usa a malha RC é lenta  
2298:  MOVF   FC0,W
229A:  ANDLW  C0
229C:  IORLW  02
229E:  MOVWF  FC0
22A0:  BSF    FC0.7
22A2:  BSF    FC2.0
.................... setup_adc_ports( AN0_TO_AN2 ); // selecionaos pinos A0 a A2 como pinos de sinais analogicos  
22A4:  MOVF   FC1,W
22A6:  ANDLW  C0
22A8:  IORLW  0C
22AA:  MOVWF  FC1
.................... set_tris_a(0b00001111); // verificar se pinos analogicos necessitam de definição de tris 
22AC:  MOVLW  0F
22AE:  MOVWF  F92
.................... set_tris_b(0b11010000);   
22B0:  MOVLW  D0
22B2:  MOVWF  F93
.................... set_tris_c(0b00000000);// define os pinos RB0 E RB1 como entrada e os demais como saida 
22B4:  MOVLW  00
22B6:  MOVWF  F94
.................... set_tris_d(0b00000000);  //  Idem como supracitado acima  
22B8:  MOVWF  F95
.................... set_tris_e(0b00000100); 
22BA:  MOVLW  04
22BC:  MOVWF  F96
.................... inicializa_lcd(); // função responsavel por inicializar o modulo lcd 
22BE:  GOTO   011A
....................  
....................   while(true){ 
....................   temperatura = ntc(); //  le o valor  de temperatura em graus celsius que a função do ntc retorna  
22C2:  GOTO   15DC
22C6:  MOVFF  03,33
22CA:  MOVFF  02,32
22CE:  MOVFF  01,31
22D2:  MOVFF  00,30
....................   umidade = dht11(); 
22D6:  GOTO   19B8
22DA:  MOVFF  01,34
....................  
....................  
.................... if (!config_Bot){   // o botao do motor 1 foi pressionado? 
22DE:  BTFSC  F81.4
22E0:  BRA    22FC
....................             if (! (BTN_B1)){ // O botão UP já foi tratato ? 
22E2:  BTFSC  46.0
22E4:  BRA    22FA
....................              
....................                // não. 
....................                if (filtro_b1 != 0) // Fim do filtro do botão UP ? 
22E6:  MOVF   44,F
22E8:  BNZ   22EE
22EA:  MOVF   45,F
22EC:  BZ    22F8
....................                   filtro_b1--; // Não, então decrementa o filtro 
22EE:  MOVF   44,W
22F0:  BTFSC  FD8.2
22F2:  DECF   45,F
22F4:  DECF   44,F
22F6:  BRA    22FA
....................                   else {  
....................                       configuracao (); // ao clicar no botão de configuraçao chama a função de configuração, onde serão passados os parametros de temperatura e umidade 
22F8:  BRA    1F80
....................                   } 
....................             }         
....................          }  
22FA:  BRA    2306
....................           else{ 
....................               filtro_b1 = t_filtro; 
22FC:  MOVLW  01
22FE:  MOVWF  45
2300:  MOVLW  90
2302:  MOVWF  44
....................               BTN_B1 = 0;  
2304:  BCF    46.0
....................       }  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................     // implementação da rotina de controle de  temperatura  
....................    if(temperatura<=set_temp){   //  verifica se da temperatura de menor que 38 graus e faz  a rotina  
2306:  MOVFF  33,83
230A:  MOVFF  32,82
230E:  MOVFF  31,81
2312:  MOVFF  30,80
2316:  MOVFF  4F,87
231A:  MOVFF  4E,86
231E:  MOVFF  4D,85
2322:  MOVFF  4C,84
2326:  CALL   0640
232A:  BC    232E
232C:  BNZ   2332
....................      PIN_COOLER =0 ; 
232E:  BCF    F82.0
....................      RELE_LAMP = 1 ; 
2330:  BSF    F81.2
....................     } 
....................     if(temperatura>set_temp){ 
2332:  MOVFF  4F,83
2336:  MOVFF  4E,82
233A:  MOVFF  4D,81
233E:  MOVFF  4C,80
2342:  MOVFF  33,87
2346:  MOVFF  32,86
234A:  MOVFF  31,85
234E:  MOVFF  30,84
2352:  CALL   0640
2356:  BNC   235C
....................     PIN_COOLER =1 ; 
2358:  BSF    F82.0
....................     RELE_LAMP = 0 ;  
235A:  BCF    F81.2
....................     } 
235C:  BRA    22C2
....................     //delay_ms(2000);    
....................   } 
....................    
....................    
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... } 
235E:  SLEEP 

Configuration Fuses:
   Word  1: CC3F   PLL12 CPUDIV4 USBDIV HS FCMEN IESO
   Word  2: 1E38   PUT NOBROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
