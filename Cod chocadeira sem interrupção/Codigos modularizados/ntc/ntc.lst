CCS PCH C Compiler, Version 5.015, 5967               21-jun-17 19:52

               Filename:   C:\Users\henri\Documents\GitHub\Projeto-chocadeira\Cod chocadeira sem interrupção\Codigos modularizados\ntc\ntc.lst

               ROM used:   6500 bytes (20%)
                           Largest free fragment is 26268
               RAM used:   35 (2%) at main() level
                           98 (5%) worst case
               Stack used: 6 locations
               Stack size: 31

*
0000:  GOTO   1848
.................... #include<18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
0004:  DATA 6F,6C
0006:  DATA 61,00
*
00B8:  MOVLW  8E
00BA:  MOVWF  00
00BC:  MOVFF  53,01
00C0:  MOVFF  52,02
00C4:  CLRF   03
00C6:  MOVF   01,F
00C8:  BNZ   00DC
00CA:  MOVFF  02,01
00CE:  CLRF   02
00D0:  MOVLW  08
00D2:  SUBWF  00,F
00D4:  MOVF   01,F
00D6:  BNZ   00DC
00D8:  CLRF   00
00DA:  BRA    00EC
00DC:  BCF    FD8.0
00DE:  BTFSC  01.7
00E0:  BRA    00EA
00E2:  RLCF   02,F
00E4:  RLCF   01,F
00E6:  DECF   00,F
00E8:  BRA    00DC
00EA:  BCF    01.7
00EC:  RETURN 0
00EE:  MOVF   4E,W
00F0:  BTFSC  FD8.2
00F2:  BRA    01D6
00F4:  MOVWF  00
00F6:  MOVF   52,W
00F8:  BTFSC  FD8.2
00FA:  BRA    01D6
00FC:  ADDWF  00,F
00FE:  BNC   0108
0100:  MOVLW  81
0102:  ADDWF  00,F
0104:  BC    01D6
0106:  BRA    0110
0108:  MOVLW  7F
010A:  SUBWF  00,F
010C:  BNC   01D6
010E:  BZ    01D6
0110:  MOVFF  4F,56
0114:  MOVF   53,W
0116:  XORWF  56,F
0118:  BSF    4F.7
011A:  BSF    53.7
011C:  MOVF   51,W
011E:  MULWF  55
0120:  MOVFF  FF4,58
0124:  MOVF   50,W
0126:  MULWF  54
0128:  MOVFF  FF4,03
012C:  MOVFF  FF3,57
0130:  MULWF  55
0132:  MOVF   FF3,W
0134:  ADDWF  58,F
0136:  MOVF   FF4,W
0138:  ADDWFC 57,F
013A:  MOVLW  00
013C:  ADDWFC 03,F
013E:  MOVF   51,W
0140:  MULWF  54
0142:  MOVF   FF3,W
0144:  ADDWF  58,F
0146:  MOVF   FF4,W
0148:  ADDWFC 57,F
014A:  MOVLW  00
014C:  CLRF   02
014E:  ADDWFC 03,F
0150:  ADDWFC 02,F
0152:  MOVF   4F,W
0154:  MULWF  55
0156:  MOVF   FF3,W
0158:  ADDWF  57,F
015A:  MOVF   FF4,W
015C:  ADDWFC 03,F
015E:  MOVLW  00
0160:  ADDWFC 02,F
0162:  MOVF   4F,W
0164:  MULWF  54
0166:  MOVF   FF3,W
0168:  ADDWF  03,F
016A:  MOVF   FF4,W
016C:  ADDWFC 02,F
016E:  MOVLW  00
0170:  CLRF   01
0172:  ADDWFC 01,F
0174:  MOVF   51,W
0176:  MULWF  53
0178:  MOVF   FF3,W
017A:  ADDWF  57,F
017C:  MOVF   FF4,W
017E:  ADDWFC 03,F
0180:  MOVLW  00
0182:  ADDWFC 02,F
0184:  ADDWFC 01,F
0186:  MOVF   50,W
0188:  MULWF  53
018A:  MOVF   FF3,W
018C:  ADDWF  03,F
018E:  MOVF   FF4,W
0190:  ADDWFC 02,F
0192:  MOVLW  00
0194:  ADDWFC 01,F
0196:  MOVF   4F,W
0198:  MULWF  53
019A:  MOVF   FF3,W
019C:  ADDWF  02,F
019E:  MOVF   FF4,W
01A0:  ADDWFC 01,F
01A2:  INCF   00,F
01A4:  BTFSC  01.7
01A6:  BRA    01B2
01A8:  RLCF   57,F
01AA:  RLCF   03,F
01AC:  RLCF   02,F
01AE:  RLCF   01,F
01B0:  DECF   00,F
01B2:  MOVLW  00
01B4:  BTFSS  57.7
01B6:  BRA    01CC
01B8:  INCF   03,F
01BA:  ADDWFC 02,F
01BC:  ADDWFC 01,F
01BE:  MOVF   01,W
01C0:  BNZ   01CC
01C2:  MOVF   02,W
01C4:  BNZ   01CC
01C6:  MOVF   03,W
01C8:  BNZ   01CC
01CA:  INCF   00,F
01CC:  BTFSC  56.7
01CE:  BSF    01.7
01D0:  BTFSS  56.7
01D2:  BCF    01.7
01D4:  BRA    01DE
01D6:  CLRF   00
01D8:  CLRF   01
01DA:  CLRF   02
01DC:  CLRF   03
01DE:  RETURN 0
01E0:  MOVF   47,W
01E2:  BTFSC  FD8.2
01E4:  BRA    0330
01E6:  MOVWF  53
01E8:  MOVF   4B,W
01EA:  BTFSC  FD8.2
01EC:  BRA    0330
01EE:  SUBWF  53,F
01F0:  BNC   01FC
01F2:  MOVLW  7F
01F4:  ADDWF  53,F
01F6:  BTFSC  FD8.0
01F8:  BRA    0330
01FA:  BRA    0208
01FC:  MOVLW  81
01FE:  SUBWF  53,F
0200:  BTFSS  FD8.0
0202:  BRA    0330
0204:  BTFSC  FD8.2
0206:  BRA    0330
0208:  MOVFF  53,00
020C:  CLRF   01
020E:  CLRF   02
0210:  CLRF   03
0212:  CLRF   52
0214:  MOVFF  48,51
0218:  BSF    51.7
021A:  MOVFF  49,50
021E:  MOVFF  4A,4F
0222:  MOVLW  19
0224:  MOVWF  53
0226:  MOVF   4E,W
0228:  SUBWF  4F,F
022A:  BC    0246
022C:  MOVLW  01
022E:  SUBWF  50,F
0230:  BC    0246
0232:  SUBWF  51,F
0234:  BC    0246
0236:  SUBWF  52,F
0238:  BC    0246
023A:  INCF   52,F
023C:  INCF   51,F
023E:  INCF   50,F
0240:  MOVF   4E,W
0242:  ADDWF  4F,F
0244:  BRA    0296
0246:  MOVF   4D,W
0248:  SUBWF  50,F
024A:  BC    0270
024C:  MOVLW  01
024E:  SUBWF  51,F
0250:  BC    0270
0252:  SUBWF  52,F
0254:  BC    0270
0256:  INCF   52,F
0258:  INCF   51,F
025A:  MOVF   4D,W
025C:  ADDWF  50,F
025E:  MOVF   4E,W
0260:  ADDWF  4F,F
0262:  BNC   0296
0264:  INCF   50,F
0266:  BNZ   0296
0268:  INCF   51,F
026A:  BNZ   0296
026C:  INCF   52,F
026E:  BRA    0296
0270:  MOVF   4C,W
0272:  IORLW  80
0274:  SUBWF  51,F
0276:  BC    0294
0278:  MOVLW  01
027A:  SUBWF  52,F
027C:  BC    0294
027E:  INCF   52,F
0280:  MOVF   4C,W
0282:  IORLW  80
0284:  ADDWF  51,F
0286:  MOVF   4D,W
0288:  ADDWF  50,F
028A:  BNC   025E
028C:  INCF   51,F
028E:  BNZ   025E
0290:  INCF   52,F
0292:  BRA    025E
0294:  BSF    03.0
0296:  DECFSZ 53,F
0298:  BRA    029C
029A:  BRA    02B2
029C:  BCF    FD8.0
029E:  RLCF   4F,F
02A0:  RLCF   50,F
02A2:  RLCF   51,F
02A4:  RLCF   52,F
02A6:  BCF    FD8.0
02A8:  RLCF   03,F
02AA:  RLCF   02,F
02AC:  RLCF   01,F
02AE:  RLCF   54,F
02B0:  BRA    0226
02B2:  BTFSS  54.0
02B4:  BRA    02C2
02B6:  BCF    FD8.0
02B8:  RRCF   01,F
02BA:  RRCF   02,F
02BC:  RRCF   03,F
02BE:  RRCF   54,F
02C0:  BRA    02C6
02C2:  DECF   00,F
02C4:  BZ    0330
02C6:  BTFSC  54.7
02C8:  BRA    0306
02CA:  BCF    FD8.0
02CC:  RLCF   4F,F
02CE:  RLCF   50,F
02D0:  RLCF   51,F
02D2:  RLCF   52,F
02D4:  MOVF   4E,W
02D6:  SUBWF  4F,F
02D8:  BC    02E8
02DA:  MOVLW  01
02DC:  SUBWF  50,F
02DE:  BC    02E8
02E0:  SUBWF  51,F
02E2:  BC    02E8
02E4:  SUBWF  52,F
02E6:  BNC   031C
02E8:  MOVF   4D,W
02EA:  SUBWF  50,F
02EC:  BC    02F8
02EE:  MOVLW  01
02F0:  SUBWF  51,F
02F2:  BC    02F8
02F4:  SUBWF  52,F
02F6:  BNC   031C
02F8:  MOVF   4C,W
02FA:  IORLW  80
02FC:  SUBWF  51,F
02FE:  BC    0306
0300:  MOVLW  01
0302:  SUBWF  52,F
0304:  BNC   031C
0306:  INCF   03,F
0308:  BNZ   031C
030A:  INCF   02,F
030C:  BNZ   031C
030E:  INCF   01,F
0310:  BNZ   031C
0312:  INCF   00,F
0314:  BZ    0330
0316:  RRCF   01,F
0318:  RRCF   02,F
031A:  RRCF   03,F
031C:  MOVFF  48,53
0320:  MOVF   4C,W
0322:  XORWF  53,F
0324:  BTFSS  53.7
0326:  BRA    032C
0328:  BSF    01.7
032A:  BRA    0338
032C:  BCF    01.7
032E:  BRA    0338
0330:  CLRF   00
0332:  CLRF   01
0334:  CLRF   02
0336:  CLRF   03
0338:  RETURN 0
033A:  MOVLW  80
033C:  BTFSC  FD8.1
033E:  XORWF  57,F
0340:  CLRF   5C
0342:  CLRF   5D
0344:  MOVFF  53,5B
0348:  MOVF   57,W
034A:  XORWF  5B,F
034C:  MOVF   52,W
034E:  BTFSC  FD8.2
0350:  BRA    050A
0352:  MOVWF  5A
0354:  MOVWF  00
0356:  MOVF   56,W
0358:  BTFSC  FD8.2
035A:  BRA    051C
035C:  SUBWF  5A,F
035E:  BTFSC  FD8.2
0360:  BRA    0464
0362:  BNC   03DE
0364:  MOVFF  57,60
0368:  BSF    x60.7
036A:  MOVFF  58,5F
036E:  MOVFF  59,5E
0372:  CLRF   5D
0374:  BCF    FD8.0
0376:  RRCF   x60,F
0378:  RRCF   5F,F
037A:  RRCF   5E,F
037C:  RRCF   5D,F
037E:  DECFSZ 5A,F
0380:  BRA    0372
0382:  BTFSS  5B.7
0384:  BRA    038C
0386:  BSF    5C.0
0388:  BRA    0544
038A:  BCF    5C.0
038C:  BCF    5A.0
038E:  BSF    5C.4
0390:  CLRF   FEA
0392:  MOVLW  55
0394:  MOVWF  FE9
0396:  BRA    056A
0398:  BCF    5C.4
039A:  BTFSC  5B.7
039C:  BRA    03B2
039E:  BTFSS  5A.0
03A0:  BRA    03C8
03A2:  RRCF   x60,F
03A4:  RRCF   5F,F
03A6:  RRCF   5E,F
03A8:  RRCF   5D,F
03AA:  INCF   00,F
03AC:  BTFSC  FD8.2
03AE:  BRA    053A
03B0:  BRA    03C8
03B2:  BTFSC  x60.7
03B4:  BRA    03CE
03B6:  BCF    FD8.0
03B8:  RLCF   5D,F
03BA:  RLCF   5E,F
03BC:  RLCF   5F,F
03BE:  RLCF   x60,F
03C0:  DECF   00,F
03C2:  BTFSC  FD8.2
03C4:  BRA    053A
03C6:  BRA    03B2
03C8:  BSF    5C.6
03CA:  BRA    04A2
03CC:  BCF    5C.6
03CE:  MOVFF  53,5B
03D2:  BTFSS  53.7
03D4:  BRA    03DA
03D6:  BSF    x60.7
03D8:  BRA    052C
03DA:  BCF    x60.7
03DC:  BRA    052C
03DE:  MOVFF  56,5A
03E2:  MOVFF  56,00
03E6:  MOVF   52,W
03E8:  SUBWF  5A,F
03EA:  MOVFF  53,60
03EE:  BSF    x60.7
03F0:  MOVFF  54,5F
03F4:  MOVFF  55,5E
03F8:  CLRF   5D
03FA:  BCF    FD8.0
03FC:  RRCF   x60,F
03FE:  RRCF   5F,F
0400:  RRCF   5E,F
0402:  RRCF   5D,F
0404:  DECFSZ 5A,F
0406:  BRA    03F8
0408:  BTFSS  5B.7
040A:  BRA    0412
040C:  BSF    5C.1
040E:  BRA    0544
0410:  BCF    5C.1
0412:  BCF    5A.0
0414:  BSF    5C.5
0416:  CLRF   FEA
0418:  MOVLW  59
041A:  MOVWF  FE9
041C:  BRA    056A
041E:  BCF    5C.5
0420:  BTFSC  5B.7
0422:  BRA    0438
0424:  BTFSS  5A.0
0426:  BRA    044E
0428:  RRCF   x60,F
042A:  RRCF   5F,F
042C:  RRCF   5E,F
042E:  RRCF   5D,F
0430:  INCF   00,F
0432:  BTFSC  FD8.2
0434:  BRA    053A
0436:  BRA    044E
0438:  BTFSC  x60.7
043A:  BRA    0454
043C:  BCF    FD8.0
043E:  RLCF   5D,F
0440:  RLCF   5E,F
0442:  RLCF   5F,F
0444:  RLCF   x60,F
0446:  DECF   00,F
0448:  BTFSC  FD8.2
044A:  BRA    053A
044C:  BRA    0438
044E:  BSF    5C.7
0450:  BRA    04A2
0452:  BCF    5C.7
0454:  MOVFF  57,5B
0458:  BTFSS  57.7
045A:  BRA    0460
045C:  BSF    x60.7
045E:  BRA    052C
0460:  BCF    x60.7
0462:  BRA    052C
0464:  MOVFF  57,60
0468:  BSF    x60.7
046A:  MOVFF  58,5F
046E:  MOVFF  59,5E
0472:  BTFSS  5B.7
0474:  BRA    047E
0476:  BCF    x60.7
0478:  BSF    5C.2
047A:  BRA    0544
047C:  BCF    5C.2
047E:  CLRF   5D
0480:  BCF    5A.0
0482:  CLRF   FEA
0484:  MOVLW  55
0486:  MOVWF  FE9
0488:  BRA    056A
048A:  BTFSC  5B.7
048C:  BRA    04C6
048E:  MOVFF  53,5B
0492:  BTFSS  5A.0
0494:  BRA    04A2
0496:  RRCF   x60,F
0498:  RRCF   5F,F
049A:  RRCF   5E,F
049C:  RRCF   5D,F
049E:  INCF   00,F
04A0:  BZ    053A
04A2:  BTFSS  5D.7
04A4:  BRA    04BC
04A6:  INCF   5E,F
04A8:  BNZ   04BC
04AA:  INCF   5F,F
04AC:  BNZ   04BC
04AE:  INCF   x60,F
04B0:  BNZ   04BC
04B2:  RRCF   x60,F
04B4:  RRCF   5F,F
04B6:  RRCF   5E,F
04B8:  INCF   00,F
04BA:  BZ    053A
04BC:  BTFSC  5C.6
04BE:  BRA    03CC
04C0:  BTFSC  5C.7
04C2:  BRA    0452
04C4:  BRA    04FE
04C6:  MOVLW  80
04C8:  XORWF  x60,F
04CA:  BTFSS  x60.7
04CC:  BRA    04D6
04CE:  BRA    0544
04D0:  MOVFF  57,5B
04D4:  BRA    04EA
04D6:  MOVFF  53,5B
04DA:  MOVF   x60,F
04DC:  BNZ   04EA
04DE:  MOVF   5F,F
04E0:  BNZ   04EA
04E2:  MOVF   5E,F
04E4:  BNZ   04EA
04E6:  CLRF   00
04E8:  BRA    052C
04EA:  BTFSC  x60.7
04EC:  BRA    04FE
04EE:  BCF    FD8.0
04F0:  RLCF   5D,F
04F2:  RLCF   5E,F
04F4:  RLCF   5F,F
04F6:  RLCF   x60,F
04F8:  DECFSZ 00,F
04FA:  BRA    04EA
04FC:  BRA    053A
04FE:  BTFSS  5B.7
0500:  BRA    0506
0502:  BSF    x60.7
0504:  BRA    052C
0506:  BCF    x60.7
0508:  BRA    052C
050A:  MOVFF  56,00
050E:  MOVFF  57,60
0512:  MOVFF  58,5F
0516:  MOVFF  59,5E
051A:  BRA    052C
051C:  MOVFF  52,00
0520:  MOVFF  53,60
0524:  MOVFF  54,5F
0528:  MOVFF  55,5E
052C:  MOVFF  60,01
0530:  MOVFF  5F,02
0534:  MOVFF  5E,03
0538:  BRA    05A2
053A:  CLRF   00
053C:  CLRF   01
053E:  CLRF   02
0540:  CLRF   03
0542:  BRA    05A2
0544:  CLRF   5D
0546:  COMF   5E,F
0548:  COMF   5F,F
054A:  COMF   x60,F
054C:  COMF   5D,F
054E:  INCF   5D,F
0550:  BNZ   055C
0552:  INCF   5E,F
0554:  BNZ   055C
0556:  INCF   5F,F
0558:  BNZ   055C
055A:  INCF   x60,F
055C:  BTFSC  5C.0
055E:  BRA    038A
0560:  BTFSC  5C.1
0562:  BRA    0410
0564:  BTFSC  5C.2
0566:  BRA    047C
0568:  BRA    04D0
056A:  MOVF   FEF,W
056C:  ADDWF  5E,F
056E:  BNC   057A
0570:  INCF   5F,F
0572:  BNZ   057A
0574:  INCF   x60,F
0576:  BTFSC  FD8.2
0578:  BSF    5A.0
057A:  MOVF   FED,F
057C:  MOVF   FEF,W
057E:  ADDWF  5F,F
0580:  BNC   0588
0582:  INCF   x60,F
0584:  BTFSC  FD8.2
0586:  BSF    5A.0
0588:  MOVF   FED,F
058A:  MOVF   FEF,W
058C:  BTFSC  FEF.7
058E:  BRA    0592
0590:  XORLW  80
0592:  ADDWF  x60,F
0594:  BTFSC  FD8.0
0596:  BSF    5A.0
0598:  BTFSC  5C.4
059A:  BRA    0398
059C:  BTFSC  5C.5
059E:  BRA    041E
05A0:  BRA    048A
05A2:  RETURN 0
05A4:  MOVFF  4F,56
05A8:  MOVF   53,W
05AA:  XORWF  56,F
05AC:  BTFSS  56.7
05AE:  BRA    05BA
05B0:  BCF    FD8.2
05B2:  BCF    FD8.0
05B4:  BTFSC  4F.7
05B6:  BSF    FD8.0
05B8:  BRA    0618
05BA:  MOVFF  4F,56
05BE:  MOVFF  52,57
05C2:  MOVF   4E,W
05C4:  SUBWF  57,F
05C6:  BZ    05D4
05C8:  BTFSS  56.7
05CA:  BRA    0618
05CC:  MOVF   FD8,W
05CE:  XORLW  01
05D0:  MOVWF  FD8
05D2:  BRA    0618
05D4:  MOVFF  53,57
05D8:  MOVF   4F,W
05DA:  SUBWF  57,F
05DC:  BZ    05EA
05DE:  BTFSS  56.7
05E0:  BRA    0618
05E2:  MOVF   FD8,W
05E4:  XORLW  01
05E6:  MOVWF  FD8
05E8:  BRA    0618
05EA:  MOVFF  54,57
05EE:  MOVF   50,W
05F0:  SUBWF  57,F
05F2:  BZ    0600
05F4:  BTFSS  56.7
05F6:  BRA    0618
05F8:  MOVF   FD8,W
05FA:  XORLW  01
05FC:  MOVWF  FD8
05FE:  BRA    0618
0600:  MOVFF  55,57
0604:  MOVF   51,W
0606:  SUBWF  57,F
0608:  BZ    0616
060A:  BTFSS  56.7
060C:  BRA    0618
060E:  MOVF   FD8,W
0610:  XORLW  01
0612:  MOVWF  FD8
0614:  BRA    0618
0616:  BCF    FD8.0
0618:  RETURN 0
061A:  MOVLW  8E
061C:  MOVWF  00
061E:  MOVFF  45,01
0622:  MOVFF  44,02
0626:  CLRF   03
0628:  BTFSS  45.7
062A:  BRA    0636
062C:  COMF   01,F
062E:  COMF   02,F
0630:  INCF   02,F
0632:  BNZ   0636
0634:  INCF   01,F
0636:  MOVF   01,F
0638:  BNZ   064C
063A:  MOVFF  02,01
063E:  CLRF   02
0640:  MOVLW  08
0642:  SUBWF  00,F
0644:  MOVF   01,F
0646:  BNZ   064C
0648:  CLRF   00
064A:  BRA    0660
064C:  BCF    FD8.0
064E:  BTFSC  01.7
0650:  BRA    065A
0652:  RLCF   02,F
0654:  RLCF   01,F
0656:  DECF   00,F
0658:  BRA    064C
065A:  BTFSC  45.7
065C:  BRA    0660
065E:  BCF    01.7
0660:  RETURN 0
*
09A2:  MOVLW  8E
09A4:  MOVWF  00
09A6:  MOVF   4E,W
09A8:  SUBWF  00,F
09AA:  MOVFF  4F,02
09AE:  MOVFF  50,01
09B2:  BSF    02.7
09B4:  MOVF   00,F
09B6:  BZ    09CA
09B8:  BCF    FD8.0
09BA:  MOVF   02,F
09BC:  BNZ   09C2
09BE:  MOVF   01,F
09C0:  BZ    09CA
09C2:  RRCF   02,F
09C4:  RRCF   01,F
09C6:  DECFSZ 00,F
09C8:  BRA    09B8
09CA:  BTFSS  4F.7
09CC:  BRA    09D8
09CE:  COMF   01,F
09D0:  COMF   02,F
09D2:  INCF   01,F
09D4:  BTFSC  FD8.2
09D6:  INCF   02,F
09D8:  RETURN 0
*
1826:  TBLRD*+
1828:  MOVF   FF5,F
182A:  BZ    1844
182C:  MOVFF  FF6,22
1830:  MOVFF  FF7,23
1834:  MOVFF  FF5,24
1838:  BRA    1800
183A:  MOVFF  22,FF6
183E:  MOVFF  23,FF7
1842:  BRA    1826
1844:  GOTO   18DE (RETURN)
....................  
.................... #list 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
09DA:  BCF    4D.0
....................    y = x; 
09DC:  MOVFF  41,46
09E0:  MOVFF  40,45
09E4:  MOVFF  3F,44
09E8:  MOVFF  3E,43
....................  
....................    if (x < 0) 
09EC:  MOVFF  41,51
09F0:  MOVFF  40,50
09F4:  MOVFF  3F,4F
09F8:  MOVFF  3E,4E
09FC:  CLRF   55
09FE:  CLRF   54
0A00:  CLRF   53
0A02:  CLRF   52
0A04:  RCALL  05A4
0A06:  BNC   0A10
....................    { 
....................       s = 1; 
0A08:  BSF    4D.0
....................       y = -y; 
0A0A:  MOVF   44,W
0A0C:  XORLW  80
0A0E:  MOVWF  44
....................    } 
....................  
....................    if (y <= 32768.0) 
0A10:  MOVFF  46,51
0A14:  MOVFF  45,50
0A18:  MOVFF  44,4F
0A1C:  MOVFF  43,4E
0A20:  CLRF   55
0A22:  CLRF   54
0A24:  CLRF   53
0A26:  MOVLW  8E
0A28:  MOVWF  52
0A2A:  RCALL  05A4
0A2C:  BC    0A30
0A2E:  BNZ   0A60
....................       res = (float32)(unsigned int16)y; 
0A30:  MOVFF  46,51
0A34:  MOVFF  45,50
0A38:  MOVFF  44,4F
0A3C:  MOVFF  43,4E
0A40:  RCALL  09A2
0A42:  MOVFF  02,53
0A46:  MOVFF  01,52
0A4A:  CALL   00B8
0A4E:  MOVFF  03,4A
0A52:  MOVFF  02,49
0A56:  MOVFF  01,48
0A5A:  MOVFF  00,47
0A5E:  BRA    0BEA
....................  
....................  else if (y < 10000000.0) 
0A60:  MOVFF  46,51
0A64:  MOVFF  45,50
0A68:  MOVFF  44,4F
0A6C:  MOVFF  43,4E
0A70:  MOVLW  80
0A72:  MOVWF  55
0A74:  MOVLW  96
0A76:  MOVWF  54
0A78:  MOVLW  18
0A7A:  MOVWF  53
0A7C:  MOVLW  96
0A7E:  MOVWF  52
0A80:  RCALL  05A4
0A82:  BTFSS  FD8.0
0A84:  BRA    0BDA
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
0A86:  MOVFF  46,51
0A8A:  MOVFF  45,50
0A8E:  MOVFF  44,4F
0A92:  MOVFF  43,4E
0A96:  CLRF   55
0A98:  CLRF   54
0A9A:  CLRF   53
0A9C:  MOVLW  70
0A9E:  MOVWF  52
0AA0:  CALL   00EE
0AA4:  MOVFF  03,51
0AA8:  MOVFF  02,50
0AAC:  MOVFF  01,4F
0AB0:  MOVFF  00,4E
0AB4:  RCALL  09A2
0AB6:  MOVFF  02,4C
0ABA:  MOVFF  01,4B
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
0ABE:  MOVFF  46,51
0AC2:  MOVFF  45,50
0AC6:  MOVFF  44,4F
0ACA:  MOVFF  43,4E
0ACE:  CLRF   55
0AD0:  CLRF   54
0AD2:  CLRF   53
0AD4:  MOVLW  70
0AD6:  MOVWF  52
0AD8:  CALL   00EE
0ADC:  MOVFF  03,51
0AE0:  MOVFF  02,50
0AE4:  MOVFF  01,4F
0AE8:  MOVFF  00,4E
0AEC:  MOVFF  4C,53
0AF0:  MOVFF  4B,52
0AF4:  CALL   00B8
0AF8:  BSF    FD8.1
0AFA:  MOVFF  51,55
0AFE:  MOVFF  50,54
0B02:  MOVFF  4F,53
0B06:  MOVFF  4E,52
0B0A:  MOVFF  03,59
0B0E:  MOVFF  02,58
0B12:  MOVFF  01,57
0B16:  MOVFF  00,56
0B1A:  RCALL  033A
0B1C:  CLRF   51
0B1E:  CLRF   50
0B20:  CLRF   4F
0B22:  MOVLW  8E
0B24:  MOVWF  4E
0B26:  MOVFF  03,55
0B2A:  MOVFF  02,54
0B2E:  MOVFF  01,53
0B32:  MOVFF  00,52
0B36:  CALL   00EE
0B3A:  MOVFF  03,46
0B3E:  MOVFF  02,45
0B42:  MOVFF  01,44
0B46:  MOVFF  00,43
....................       res = 32768.0*(float32)l; 
0B4A:  MOVFF  4C,53
0B4E:  MOVFF  4B,52
0B52:  CALL   00B8
0B56:  CLRF   51
0B58:  CLRF   50
0B5A:  CLRF   4F
0B5C:  MOVLW  8E
0B5E:  MOVWF  4E
0B60:  MOVFF  03,55
0B64:  MOVFF  02,54
0B68:  MOVFF  01,53
0B6C:  MOVFF  00,52
0B70:  CALL   00EE
0B74:  MOVFF  03,4A
0B78:  MOVFF  02,49
0B7C:  MOVFF  01,48
0B80:  MOVFF  00,47
....................       res += (float32)(unsigned int16)y; 
0B84:  MOVFF  46,51
0B88:  MOVFF  45,50
0B8C:  MOVFF  44,4F
0B90:  MOVFF  43,4E
0B94:  RCALL  09A2
0B96:  MOVFF  02,53
0B9A:  MOVFF  01,52
0B9E:  CALL   00B8
0BA2:  BCF    FD8.1
0BA4:  MOVFF  4A,55
0BA8:  MOVFF  49,54
0BAC:  MOVFF  48,53
0BB0:  MOVFF  47,52
0BB4:  MOVFF  03,59
0BB8:  MOVFF  02,58
0BBC:  MOVFF  01,57
0BC0:  MOVFF  00,56
0BC4:  CALL   033A
0BC8:  MOVFF  03,4A
0BCC:  MOVFF  02,49
0BD0:  MOVFF  01,48
0BD4:  MOVFF  00,47
....................    } 
0BD8:  BRA    0BEA
....................  
....................  else 
....................   res = y; 
0BDA:  MOVFF  46,4A
0BDE:  MOVFF  45,49
0BE2:  MOVFF  44,48
0BE6:  MOVFF  43,47
....................  
....................  y = y - (float32)(unsigned int16)y; 
0BEA:  MOVFF  46,51
0BEE:  MOVFF  45,50
0BF2:  MOVFF  44,4F
0BF6:  MOVFF  43,4E
0BFA:  RCALL  09A2
0BFC:  MOVFF  02,53
0C00:  MOVFF  01,52
0C04:  CALL   00B8
0C08:  BSF    FD8.1
0C0A:  MOVFF  46,55
0C0E:  MOVFF  45,54
0C12:  MOVFF  44,53
0C16:  MOVFF  43,52
0C1A:  MOVFF  03,59
0C1E:  MOVFF  02,58
0C22:  MOVFF  01,57
0C26:  MOVFF  00,56
0C2A:  CALL   033A
0C2E:  MOVFF  03,46
0C32:  MOVFF  02,45
0C36:  MOVFF  01,44
0C3A:  MOVFF  00,43
....................  
....................  if (s) 
0C3E:  BTFSS  4D.0
0C40:  BRA    0C48
....................   res = -res; 
0C42:  MOVF   48,W
0C44:  XORLW  80
0C46:  MOVWF  48
....................  
....................  if (y != 0) 
0C48:  MOVFF  46,51
0C4C:  MOVFF  45,50
0C50:  MOVFF  44,4F
0C54:  MOVFF  43,4E
0C58:  CLRF   55
0C5A:  CLRF   54
0C5C:  CLRF   53
0C5E:  CLRF   52
0C60:  RCALL  05A4
0C62:  BZ    0CD4
....................  { 
....................   if (s == 1 && n == 0) 
0C64:  BTFSS  4D.0
0C66:  BRA    0C9C
0C68:  MOVF   42,F
0C6A:  BNZ   0C9C
....................    res -= 1.0; 
0C6C:  BSF    FD8.1
0C6E:  MOVFF  4A,55
0C72:  MOVFF  49,54
0C76:  MOVFF  48,53
0C7A:  MOVFF  47,52
0C7E:  CLRF   59
0C80:  CLRF   58
0C82:  CLRF   57
0C84:  MOVLW  7F
0C86:  MOVWF  56
0C88:  CALL   033A
0C8C:  MOVFF  03,4A
0C90:  MOVFF  02,49
0C94:  MOVFF  01,48
0C98:  MOVFF  00,47
....................  
....................   if (s == 0 && n == 1) 
0C9C:  BTFSC  4D.0
0C9E:  BRA    0CD4
0CA0:  DECFSZ 42,W
0CA2:  BRA    0CD4
....................    res += 1.0; 
0CA4:  BCF    FD8.1
0CA6:  MOVFF  4A,55
0CAA:  MOVFF  49,54
0CAE:  MOVFF  48,53
0CB2:  MOVFF  47,52
0CB6:  CLRF   59
0CB8:  CLRF   58
0CBA:  CLRF   57
0CBC:  MOVLW  7F
0CBE:  MOVWF  56
0CC0:  CALL   033A
0CC4:  MOVFF  03,4A
0CC8:  MOVFF  02,49
0CCC:  MOVFF  01,48
0CD0:  MOVFF  00,47
....................  } 
....................  if (x == 0) 
0CD4:  MOVFF  41,51
0CD8:  MOVFF  40,50
0CDC:  MOVFF  3F,4F
0CE0:  MOVFF  3E,4E
0CE4:  CLRF   55
0CE6:  CLRF   54
0CE8:  CLRF   53
0CEA:  CLRF   52
0CEC:  RCALL  05A4
0CEE:  BNZ   0CF8
....................     res = 0; 
0CF0:  CLRF   4A
0CF2:  CLRF   49
0CF4:  CLRF   48
0CF6:  CLRF   47
....................  
....................  return (res); 
0CF8:  MOVFF  47,00
0CFC:  MOVFF  48,01
0D00:  MOVFF  49,02
0D04:  MOVFF  4A,03
0D08:  RETURN 0
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
*
0D24:  MOVFF  3D,41
0D28:  MOVFF  3C,40
0D2C:  MOVFF  3B,3F
0D30:  MOVFF  3A,3E
0D34:  CLRF   42
0D36:  RCALL  09DA
0D38:  GOTO   0E3A (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
0D0A:  MOVFF  3D,41
0D0E:  MOVFF  3C,40
0D12:  MOVFF  3B,3F
0D16:  MOVFF  3A,3E
0D1A:  MOVLW  01
0D1C:  MOVWF  42
0D1E:  RCALL  09DA
0D20:  GOTO   0DF2 (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
*
0D3C:  MOVFF  31,51
0D40:  MOVFF  30,50
0D44:  MOVFF  2F,4F
0D48:  MOVFF  2E,4E
0D4C:  CLRF   55
0D4E:  CLRF   54
0D50:  CLRF   53
0D52:  CLRF   52
0D54:  RCALL  05A4
0D56:  BTFSC  FD8.2
0D58:  BRA    0E96
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
0D5A:  MOVFF  2D,4A
0D5E:  MOVFF  2C,49
0D62:  MOVFF  2B,48
0D66:  MOVFF  2A,47
0D6A:  MOVFF  31,4E
0D6E:  MOVFF  30,4D
0D72:  MOVFF  2F,4C
0D76:  MOVFF  2E,4B
0D7A:  CALL   01E0
0D7E:  MOVFF  03,39
0D82:  MOVFF  02,38
0D86:  MOVFF  01,37
0D8A:  MOVFF  00,36
0D8E:  MOVFF  03,51
0D92:  MOVFF  02,50
0D96:  MOVFF  01,4F
0D9A:  MOVFF  00,4E
0D9E:  CLRF   55
0DA0:  CLRF   54
0DA2:  CLRF   53
0DA4:  CLRF   52
0DA6:  CALL   05A4
0DAA:  BNC   0DF4
0DAC:  MOVFF  2D,4A
0DB0:  MOVFF  2C,49
0DB4:  MOVFF  2B,48
0DB8:  MOVFF  2A,47
0DBC:  MOVFF  31,4E
0DC0:  MOVFF  30,4D
0DC4:  MOVFF  2F,4C
0DC8:  MOVFF  2E,4B
0DCC:  CALL   01E0
0DD0:  MOVFF  03,39
0DD4:  MOVFF  02,38
0DD8:  MOVFF  01,37
0DDC:  MOVFF  00,36
0DE0:  MOVFF  03,3D
0DE4:  MOVFF  02,3C
0DE8:  MOVFF  01,3B
0DEC:  MOVFF  00,3A
0DF0:  BRA    0D0A
0DF2:  BRA    0E3A
0DF4:  MOVFF  2D,4A
0DF8:  MOVFF  2C,49
0DFC:  MOVFF  2B,48
0E00:  MOVFF  2A,47
0E04:  MOVFF  31,4E
0E08:  MOVFF  30,4D
0E0C:  MOVFF  2F,4C
0E10:  MOVFF  2E,4B
0E14:  CALL   01E0
0E18:  MOVFF  03,39
0E1C:  MOVFF  02,38
0E20:  MOVFF  01,37
0E24:  MOVFF  00,36
0E28:  MOVFF  03,3D
0E2C:  MOVFF  02,3C
0E30:  MOVFF  01,3B
0E34:  MOVFF  00,3A
0E38:  BRA    0D24
0E3A:  MOVFF  03,35
0E3E:  MOVFF  02,34
0E42:  MOVFF  01,33
0E46:  MOVFF  00,32
....................       return(x-(i*y)); 
0E4A:  MOVFF  35,51
0E4E:  MOVFF  34,50
0E52:  MOVFF  33,4F
0E56:  MOVFF  32,4E
0E5A:  MOVFF  31,55
0E5E:  MOVFF  30,54
0E62:  MOVFF  2F,53
0E66:  MOVFF  2E,52
0E6A:  CALL   00EE
0E6E:  BSF    FD8.1
0E70:  MOVFF  2D,55
0E74:  MOVFF  2C,54
0E78:  MOVFF  2B,53
0E7C:  MOVFF  2A,52
0E80:  MOVFF  03,59
0E84:  MOVFF  02,58
0E88:  MOVFF  01,57
0E8C:  MOVFF  00,56
0E90:  CALL   033A
0E94:  BRA    0E96
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
0E96:  RETURN 0
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
0E98:  MOVFF  31,51
0E9C:  MOVFF  30,50
0EA0:  MOVFF  2F,4F
0EA4:  MOVFF  2E,4E
0EA8:  MOVLW  3B
0EAA:  MOVWF  55
0EAC:  MOVLW  AA
0EAE:  MOVWF  54
0EB0:  MOVLW  38
0EB2:  MOVWF  53
0EB4:  MOVLW  7F
0EB6:  MOVWF  52
0EB8:  CALL   00EE
0EBC:  MOVFF  03,51
0EC0:  MOVFF  02,50
0EC4:  MOVFF  01,4F
0EC8:  MOVFF  00,4E
0ECC:  RCALL  09A2
0ECE:  MOVFF  01,3E
....................    s = 0; 
0ED2:  BCF    3F.0
....................    y = x; 
0ED4:  MOVFF  31,35
0ED8:  MOVFF  30,34
0EDC:  MOVFF  2F,33
0EE0:  MOVFF  2E,32
....................  
....................    if (x < 0) 
0EE4:  MOVFF  31,51
0EE8:  MOVFF  30,50
0EEC:  MOVFF  2F,4F
0EF0:  MOVFF  2E,4E
0EF4:  CLRF   55
0EF6:  CLRF   54
0EF8:  CLRF   53
0EFA:  CLRF   52
0EFC:  CALL   05A4
0F00:  BNC   0F0C
....................    { 
....................       s = 1; 
0F02:  BSF    3F.0
....................       n = -n; 
0F04:  NEGF   3E
....................       y = -y; 
0F06:  MOVF   33,W
0F08:  XORLW  80
0F0A:  MOVWF  33
....................    } 
....................  
....................    res = 0.0; 
0F0C:  CLRF   39
0F0E:  CLRF   38
0F10:  CLRF   37
0F12:  CLRF   36
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
0F14:  CLRF   41
0F16:  MOVLW  36
0F18:  MOVWF  FE9
0F1A:  MOVFF  41,FEA
0F1E:  MOVLW  7F
0F20:  ADDWF  3E,W
0F22:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
0F24:  MOVFF  35,51
0F28:  MOVFF  34,50
0F2C:  MOVFF  33,4F
0F30:  MOVFF  32,4E
0F34:  MOVLW  3B
0F36:  MOVWF  55
0F38:  MOVLW  AA
0F3A:  MOVWF  54
0F3C:  MOVLW  38
0F3E:  MOVWF  53
0F40:  MOVLW  7F
0F42:  MOVWF  52
0F44:  CALL   00EE
0F48:  MOVFF  03,43
0F4C:  MOVFF  02,42
0F50:  MOVFF  01,41
0F54:  MOVFF  00,40
0F58:  CLRF   45
0F5A:  MOVFF  3E,44
0F5E:  BTFSC  44.7
0F60:  DECF   45,F
0F62:  CALL   061A
0F66:  BSF    FD8.1
0F68:  MOVFF  43,55
0F6C:  MOVFF  42,54
0F70:  MOVFF  41,53
0F74:  MOVFF  40,52
0F78:  MOVFF  03,59
0F7C:  MOVFF  02,58
0F80:  MOVFF  01,57
0F84:  MOVFF  00,56
0F88:  CALL   033A
0F8C:  MOVFF  03,35
0F90:  MOVFF  02,34
0F94:  MOVFF  01,33
0F98:  MOVFF  00,32
....................  
....................    r = pe[0]*y + pe[1]; 
0F9C:  MOVLW  7C
0F9E:  MOVWF  51
0FA0:  MOVLW  88
0FA2:  MOVWF  50
0FA4:  MOVLW  59
0FA6:  MOVWF  4F
0FA8:  MOVLW  72
0FAA:  MOVWF  4E
0FAC:  MOVFF  35,55
0FB0:  MOVFF  34,54
0FB4:  MOVFF  33,53
0FB8:  MOVFF  32,52
0FBC:  CALL   00EE
0FC0:  MOVFF  03,43
0FC4:  MOVFF  02,42
0FC8:  MOVFF  01,41
0FCC:  MOVFF  00,40
0FD0:  BCF    FD8.1
0FD2:  MOVFF  03,55
0FD6:  MOVFF  02,54
0FDA:  MOVFF  01,53
0FDE:  MOVFF  00,52
0FE2:  MOVLW  E0
0FE4:  MOVWF  59
0FE6:  MOVLW  97
0FE8:  MOVWF  58
0FEA:  MOVLW  26
0FEC:  MOVWF  57
0FEE:  MOVLW  75
0FF0:  MOVWF  56
0FF2:  CALL   033A
0FF6:  MOVFF  03,3D
0FFA:  MOVFF  02,3C
0FFE:  MOVFF  01,3B
1002:  MOVFF  00,3A
....................    r = r*y + pe[2]; 
1006:  MOVFF  3D,51
100A:  MOVFF  3C,50
100E:  MOVFF  3B,4F
1012:  MOVFF  3A,4E
1016:  MOVFF  35,55
101A:  MOVFF  34,54
101E:  MOVFF  33,53
1022:  MOVFF  32,52
1026:  CALL   00EE
102A:  MOVFF  03,43
102E:  MOVFF  02,42
1032:  MOVFF  01,41
1036:  MOVFF  00,40
103A:  BCF    FD8.1
103C:  MOVFF  03,55
1040:  MOVFF  02,54
1044:  MOVFF  01,53
1048:  MOVFF  00,52
104C:  MOVLW  C4
104E:  MOVWF  59
1050:  MOVLW  1D
1052:  MOVWF  58
1054:  MOVLW  1E
1056:  MOVWF  57
1058:  MOVLW  78
105A:  MOVWF  56
105C:  CALL   033A
1060:  MOVFF  03,3D
1064:  MOVFF  02,3C
1068:  MOVFF  01,3B
106C:  MOVFF  00,3A
....................    r = r*y + pe[3]; 
1070:  MOVFF  3D,51
1074:  MOVFF  3C,50
1078:  MOVFF  3B,4F
107C:  MOVFF  3A,4E
1080:  MOVFF  35,55
1084:  MOVFF  34,54
1088:  MOVFF  33,53
108C:  MOVFF  32,52
1090:  CALL   00EE
1094:  MOVFF  03,43
1098:  MOVFF  02,42
109C:  MOVFF  01,41
10A0:  MOVFF  00,40
10A4:  BCF    FD8.1
10A6:  MOVFF  03,55
10AA:  MOVFF  02,54
10AE:  MOVFF  01,53
10B2:  MOVFF  00,52
10B6:  MOVLW  5E
10B8:  MOVWF  59
10BA:  MOVLW  50
10BC:  MOVWF  58
10BE:  MOVLW  63
10C0:  MOVWF  57
10C2:  MOVLW  7A
10C4:  MOVWF  56
10C6:  CALL   033A
10CA:  MOVFF  03,3D
10CE:  MOVFF  02,3C
10D2:  MOVFF  01,3B
10D6:  MOVFF  00,3A
....................    r = r*y + pe[4]; 
10DA:  MOVFF  3D,51
10DE:  MOVFF  3C,50
10E2:  MOVFF  3B,4F
10E6:  MOVFF  3A,4E
10EA:  MOVFF  35,55
10EE:  MOVFF  34,54
10F2:  MOVFF  33,53
10F6:  MOVFF  32,52
10FA:  CALL   00EE
10FE:  MOVFF  03,43
1102:  MOVFF  02,42
1106:  MOVFF  01,41
110A:  MOVFF  00,40
110E:  BCF    FD8.1
1110:  MOVFF  03,55
1114:  MOVFF  02,54
1118:  MOVFF  01,53
111C:  MOVFF  00,52
1120:  MOVLW  1A
1122:  MOVWF  59
1124:  MOVLW  FE
1126:  MOVWF  58
1128:  MOVLW  75
112A:  MOVWF  57
112C:  MOVLW  7C
112E:  MOVWF  56
1130:  CALL   033A
1134:  MOVFF  03,3D
1138:  MOVFF  02,3C
113C:  MOVFF  01,3B
1140:  MOVFF  00,3A
....................    r = r*y + pe[5]; 
1144:  MOVFF  3D,51
1148:  MOVFF  3C,50
114C:  MOVFF  3B,4F
1150:  MOVFF  3A,4E
1154:  MOVFF  35,55
1158:  MOVFF  34,54
115C:  MOVFF  33,53
1160:  MOVFF  32,52
1164:  CALL   00EE
1168:  MOVFF  03,43
116C:  MOVFF  02,42
1170:  MOVFF  01,41
1174:  MOVFF  00,40
1178:  BCF    FD8.1
117A:  MOVFF  03,55
117E:  MOVFF  02,54
1182:  MOVFF  01,53
1186:  MOVFF  00,52
118A:  MOVLW  18
118C:  MOVWF  59
118E:  MOVLW  72
1190:  MOVWF  58
1192:  MOVLW  31
1194:  MOVWF  57
1196:  MOVLW  7E
1198:  MOVWF  56
119A:  CALL   033A
119E:  MOVFF  03,3D
11A2:  MOVFF  02,3C
11A6:  MOVFF  01,3B
11AA:  MOVFF  00,3A
....................  
....................    res = res*(1.0 + y*r); 
11AE:  MOVFF  35,51
11B2:  MOVFF  34,50
11B6:  MOVFF  33,4F
11BA:  MOVFF  32,4E
11BE:  MOVFF  3D,55
11C2:  MOVFF  3C,54
11C6:  MOVFF  3B,53
11CA:  MOVFF  3A,52
11CE:  CALL   00EE
11D2:  BCF    FD8.1
11D4:  CLRF   55
11D6:  CLRF   54
11D8:  CLRF   53
11DA:  MOVLW  7F
11DC:  MOVWF  52
11DE:  MOVFF  03,59
11E2:  MOVFF  02,58
11E6:  MOVFF  01,57
11EA:  MOVFF  00,56
11EE:  CALL   033A
11F2:  MOVFF  39,51
11F6:  MOVFF  38,50
11FA:  MOVFF  37,4F
11FE:  MOVFF  36,4E
1202:  MOVFF  03,55
1206:  MOVFF  02,54
120A:  MOVFF  01,53
120E:  MOVFF  00,52
1212:  CALL   00EE
1216:  MOVFF  03,39
121A:  MOVFF  02,38
121E:  MOVFF  01,37
1222:  MOVFF  00,36
....................  
....................    if (s) 
1226:  BTFSS  3F.0
1228:  BRA    1258
....................       res = 1.0/res; 
122A:  CLRF   4A
122C:  CLRF   49
122E:  CLRF   48
1230:  MOVLW  7F
1232:  MOVWF  47
1234:  MOVFF  39,4E
1238:  MOVFF  38,4D
123C:  MOVFF  37,4C
1240:  MOVFF  36,4B
1244:  CALL   01E0
1248:  MOVFF  03,39
124C:  MOVFF  02,38
1250:  MOVFF  01,37
1254:  MOVFF  00,36
....................    return(res); 
1258:  MOVFF  36,00
125C:  MOVFF  37,01
1260:  MOVFF  38,02
1264:  MOVFF  39,03
1268:  RETURN 0
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
*
0662:  MOVFF  31,35
0666:  MOVFF  30,34
066A:  MOVFF  2F,33
066E:  MOVFF  2E,32
....................  
....................    if (y != 1.0) 
0672:  MOVFF  35,51
0676:  MOVFF  34,50
067A:  MOVFF  33,4F
067E:  MOVFF  32,4E
0682:  CLRF   55
0684:  CLRF   54
0686:  CLRF   53
0688:  MOVLW  7F
068A:  MOVWF  52
068C:  RCALL  05A4
068E:  BTFSC  FD8.2
0690:  BRA    0988
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
0692:  CLRF   44
0694:  MOVLW  32
0696:  MOVWF  FE9
0698:  MOVFF  44,FEA
069C:  MOVLW  7E
069E:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
06A0:  BSF    FD8.1
06A2:  MOVFF  35,55
06A6:  MOVFF  34,54
06AA:  MOVFF  33,53
06AE:  MOVFF  32,52
06B2:  CLRF   59
06B4:  CLRF   58
06B6:  CLRF   57
06B8:  MOVLW  7F
06BA:  MOVWF  56
06BC:  RCALL  033A
06BE:  MOVFF  03,46
06C2:  MOVFF  02,45
06C6:  MOVFF  01,44
06CA:  MOVFF  00,43
06CE:  BCF    FD8.1
06D0:  MOVFF  35,55
06D4:  MOVFF  34,54
06D8:  MOVFF  33,53
06DC:  MOVFF  32,52
06E0:  CLRF   59
06E2:  CLRF   58
06E4:  CLRF   57
06E6:  MOVLW  7F
06E8:  MOVWF  56
06EA:  RCALL  033A
06EC:  MOVFF  46,4A
06F0:  MOVFF  45,49
06F4:  MOVFF  44,48
06F8:  MOVFF  43,47
06FC:  MOVFF  03,4E
0700:  MOVFF  02,4D
0704:  MOVFF  01,4C
0708:  MOVFF  00,4B
070C:  RCALL  01E0
070E:  MOVFF  03,35
0712:  MOVFF  02,34
0716:  MOVFF  01,33
071A:  MOVFF  00,32
....................  
....................       y2=y*y; 
071E:  MOVFF  35,51
0722:  MOVFF  34,50
0726:  MOVFF  33,4F
072A:  MOVFF  32,4E
072E:  MOVFF  35,55
0732:  MOVFF  34,54
0736:  MOVFF  33,53
073A:  MOVFF  32,52
073E:  RCALL  00EE
0740:  MOVFF  03,41
0744:  MOVFF  02,40
0748:  MOVFF  01,3F
074C:  MOVFF  00,3E
....................  
....................       res = pl[0]*y2 + pl[1]; 
0750:  MOVLW  99
0752:  MOVWF  51
0754:  MOVLW  47
0756:  MOVWF  50
0758:  MOVLW  8A
075A:  MOVWF  4F
075C:  MOVLW  7F
075E:  MOVWF  4E
0760:  MOVFF  41,55
0764:  MOVFF  40,54
0768:  MOVFF  3F,53
076C:  MOVFF  3E,52
0770:  RCALL  00EE
0772:  MOVFF  03,46
0776:  MOVFF  02,45
077A:  MOVFF  01,44
077E:  MOVFF  00,43
0782:  BCF    FD8.1
0784:  MOVFF  03,55
0788:  MOVFF  02,54
078C:  MOVFF  01,53
0790:  MOVFF  00,52
0794:  CLRF   59
0796:  CLRF   58
0798:  CLRF   57
079A:  MOVLW  80
079C:  MOVWF  56
079E:  RCALL  033A
07A0:  MOVFF  03,39
07A4:  MOVFF  02,38
07A8:  MOVFF  01,37
07AC:  MOVFF  00,36
....................  
....................       r = ql[0]*y2 + ql[1]; 
07B0:  MOVLW  4C
07B2:  MOVWF  51
07B4:  MOVLW  F3
07B6:  MOVWF  50
07B8:  MOVLW  3A
07BA:  MOVWF  4F
07BC:  MOVLW  7B
07BE:  MOVWF  4E
07C0:  MOVFF  41,55
07C4:  MOVFF  40,54
07C8:  MOVFF  3F,53
07CC:  MOVFF  3E,52
07D0:  RCALL  00EE
07D2:  MOVFF  03,46
07D6:  MOVFF  02,45
07DA:  MOVFF  01,44
07DE:  MOVFF  00,43
07E2:  BCF    FD8.1
07E4:  MOVFF  03,55
07E8:  MOVFF  02,54
07EC:  MOVFF  01,53
07F0:  MOVFF  00,52
07F4:  MOVLW  2B
07F6:  MOVWF  59
07F8:  MOVLW  9D
07FA:  MOVWF  58
07FC:  MOVLW  DF
07FE:  MOVWF  57
0800:  MOVLW  7E
0802:  MOVWF  56
0804:  RCALL  033A
0806:  MOVFF  03,3D
080A:  MOVFF  02,3C
080E:  MOVFF  01,3B
0812:  MOVFF  00,3A
....................       r = r*y2 + 1.0; 
0816:  MOVFF  3D,51
081A:  MOVFF  3C,50
081E:  MOVFF  3B,4F
0822:  MOVFF  3A,4E
0826:  MOVFF  41,55
082A:  MOVFF  40,54
082E:  MOVFF  3F,53
0832:  MOVFF  3E,52
0836:  RCALL  00EE
0838:  MOVFF  03,46
083C:  MOVFF  02,45
0840:  MOVFF  01,44
0844:  MOVFF  00,43
0848:  BCF    FD8.1
084A:  MOVFF  03,55
084E:  MOVFF  02,54
0852:  MOVFF  01,53
0856:  MOVFF  00,52
085A:  CLRF   59
085C:  CLRF   58
085E:  CLRF   57
0860:  MOVLW  7F
0862:  MOVWF  56
0864:  RCALL  033A
0866:  MOVFF  03,3D
086A:  MOVFF  02,3C
086E:  MOVFF  01,3B
0872:  MOVFF  00,3A
....................  
....................       res = y*res/r; 
0876:  MOVFF  35,51
087A:  MOVFF  34,50
087E:  MOVFF  33,4F
0882:  MOVFF  32,4E
0886:  MOVFF  39,55
088A:  MOVFF  38,54
088E:  MOVFF  37,53
0892:  MOVFF  36,52
0896:  RCALL  00EE
0898:  MOVFF  03,46
089C:  MOVFF  02,45
08A0:  MOVFF  01,44
08A4:  MOVFF  00,43
08A8:  MOVFF  03,4A
08AC:  MOVFF  02,49
08B0:  MOVFF  01,48
08B4:  MOVFF  00,47
08B8:  MOVFF  3D,4E
08BC:  MOVFF  3C,4D
08C0:  MOVFF  3B,4C
08C4:  MOVFF  3A,4B
08C8:  RCALL  01E0
08CA:  MOVFF  03,39
08CE:  MOVFF  02,38
08D2:  MOVFF  01,37
08D6:  MOVFF  00,36
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
08DA:  CLRF   44
08DC:  MOVLW  2E
08DE:  MOVWF  FE9
08E0:  MOVFF  44,FEA
08E4:  MOVLW  7E
08E6:  SUBWF  FEF,W
08E8:  MOVWF  42
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
08EA:  BTFSS  42.7
08EC:  BRA    0912
....................          r = -(float32)-n; 
08EE:  MOVLW  00
08F0:  BSF    FD8.0
08F2:  SUBFWB 42,W
08F4:  CLRF   45
08F6:  MOVWF  44
08F8:  BTFSC  44.7
08FA:  DECF   45,F
08FC:  RCALL  061A
08FE:  MOVFF  00,3A
0902:  MOVF   01,W
0904:  XORLW  80
0906:  MOVWF  3B
0908:  MOVFF  02,3C
090C:  MOVFF  03,3D
0910:  BRA    092E
....................       else 
....................          r = (float32)n; 
0912:  CLRF   45
0914:  MOVFF  42,44
0918:  BTFSC  44.7
091A:  DECF   45,F
091C:  RCALL  061A
091E:  MOVFF  03,3D
0922:  MOVFF  02,3C
0926:  MOVFF  01,3B
092A:  MOVFF  00,3A
....................  
....................       res += r*LN2; 
092E:  MOVFF  3D,51
0932:  MOVFF  3C,50
0936:  MOVFF  3B,4F
093A:  MOVFF  3A,4E
093E:  MOVLW  18
0940:  MOVWF  55
0942:  MOVLW  72
0944:  MOVWF  54
0946:  MOVLW  31
0948:  MOVWF  53
094A:  MOVLW  7E
094C:  MOVWF  52
094E:  CALL   00EE
0952:  BCF    FD8.1
0954:  MOVFF  39,55
0958:  MOVFF  38,54
095C:  MOVFF  37,53
0960:  MOVFF  36,52
0964:  MOVFF  03,59
0968:  MOVFF  02,58
096C:  MOVFF  01,57
0970:  MOVFF  00,56
0974:  RCALL  033A
0976:  MOVFF  03,39
097A:  MOVFF  02,38
097E:  MOVFF  01,37
0982:  MOVFF  00,36
....................    } 
0986:  BRA    0990
....................  
....................    else 
....................       res = 0.0; 
0988:  CLRF   39
098A:  CLRF   38
098C:  CLRF   37
098E:  CLRF   36
....................  
....................    return(res); 
0990:  MOVFF  36,00
0994:  MOVFF  37,01
0998:  MOVFF  38,02
099C:  MOVFF  39,03
09A0:  RETURN 0
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
*
126A:  MOVFF  25,51
126E:  MOVFF  24,50
1272:  MOVFF  23,4F
1276:  MOVFF  22,4E
127A:  CLRF   55
127C:  CLRF   54
127E:  CLRF   53
1280:  CLRF   52
1282:  CALL   05A4
1286:  BTFSS  FD8.0
1288:  BRA    1420
128A:  MOVFF  29,2D
128E:  MOVFF  28,2C
1292:  MOVFF  27,2B
1296:  MOVFF  26,2A
129A:  CLRF   31
129C:  CLRF   30
129E:  CLRF   2F
12A0:  MOVLW  7F
12A2:  MOVWF  2E
12A4:  RCALL  0D3C
12A6:  MOVFF  03,2D
12AA:  MOVFF  02,2C
12AE:  MOVFF  01,2B
12B2:  MOVFF  00,2A
12B6:  MOVFF  03,51
12BA:  MOVFF  02,50
12BE:  MOVFF  01,4F
12C2:  MOVFF  00,4E
12C6:  CLRF   55
12C8:  CLRF   54
12CA:  CLRF   53
12CC:  CLRF   52
12CE:  CALL   05A4
12D2:  BTFSS  FD8.2
12D4:  BRA    1420
....................       if(fmod(y, 2) == 0) { 
12D6:  MOVFF  29,2D
12DA:  MOVFF  28,2C
12DE:  MOVFF  27,2B
12E2:  MOVFF  26,2A
12E6:  CLRF   31
12E8:  CLRF   30
12EA:  CLRF   2F
12EC:  MOVLW  80
12EE:  MOVWF  2E
12F0:  RCALL  0D3C
12F2:  MOVFF  03,2D
12F6:  MOVFF  02,2C
12FA:  MOVFF  01,2B
12FE:  MOVFF  00,2A
1302:  MOVFF  03,51
1306:  MOVFF  02,50
130A:  MOVFF  01,4F
130E:  MOVFF  00,4E
1312:  CLRF   55
1314:  CLRF   54
1316:  CLRF   53
1318:  CLRF   52
131A:  CALL   05A4
131E:  BNZ   139E
....................          return (exp(log(-x) * y)); 
1320:  MOVFF  22,2A
1324:  MOVF   23,W
1326:  XORLW  80
1328:  MOVWF  2B
132A:  MOVFF  24,2C
132E:  MOVFF  25,2D
1332:  MOVFF  25,31
1336:  MOVFF  24,30
133A:  MOVWF  2F
133C:  MOVFF  22,2E
1340:  CALL   0662
1344:  MOVFF  03,2D
1348:  MOVFF  02,2C
134C:  MOVFF  01,2B
1350:  MOVFF  00,2A
1354:  MOVFF  03,51
1358:  MOVFF  02,50
135C:  MOVFF  01,4F
1360:  MOVFF  00,4E
1364:  MOVFF  29,55
1368:  MOVFF  28,54
136C:  MOVFF  27,53
1370:  MOVFF  26,52
1374:  CALL   00EE
1378:  MOVFF  03,2D
137C:  MOVFF  02,2C
1380:  MOVFF  01,2B
1384:  MOVFF  00,2A
1388:  MOVFF  03,31
138C:  MOVFF  02,30
1390:  MOVFF  01,2F
1394:  MOVFF  00,2E
1398:  RCALL  0E98
139A:  BRA    153C
....................       } else { 
139C:  BRA    141E
....................          return (-exp(log(-x) * y)); 
139E:  MOVFF  22,2A
13A2:  MOVF   23,W
13A4:  XORLW  80
13A6:  MOVWF  2B
13A8:  MOVFF  24,2C
13AC:  MOVFF  25,2D
13B0:  MOVFF  25,31
13B4:  MOVFF  24,30
13B8:  MOVWF  2F
13BA:  MOVFF  22,2E
13BE:  CALL   0662
13C2:  MOVFF  03,2D
13C6:  MOVFF  02,2C
13CA:  MOVFF  01,2B
13CE:  MOVFF  00,2A
13D2:  MOVFF  03,51
13D6:  MOVFF  02,50
13DA:  MOVFF  01,4F
13DE:  MOVFF  00,4E
13E2:  MOVFF  29,55
13E6:  MOVFF  28,54
13EA:  MOVFF  27,53
13EE:  MOVFF  26,52
13F2:  CALL   00EE
13F6:  MOVFF  03,2D
13FA:  MOVFF  02,2C
13FE:  MOVFF  01,2B
1402:  MOVFF  00,2A
1406:  MOVFF  03,31
140A:  MOVFF  02,30
140E:  MOVFF  01,2F
1412:  MOVFF  00,2E
1416:  RCALL  0E98
1418:  MOVLW  80
141A:  XORWF  01,F
141C:  BRA    153C
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
141E:  BRA    153C
1420:  MOVFF  25,51
1424:  MOVFF  24,50
1428:  MOVFF  23,4F
142C:  MOVFF  22,4E
1430:  CLRF   55
1432:  CLRF   54
1434:  CLRF   53
1436:  CLRF   52
1438:  CALL   05A4
143C:  BNC   1494
143E:  MOVFF  29,2D
1442:  MOVFF  28,2C
1446:  MOVFF  27,2B
144A:  MOVFF  26,2A
144E:  CLRF   31
1450:  CLRF   30
1452:  CLRF   2F
1454:  MOVLW  7F
1456:  MOVWF  2E
1458:  RCALL  0D3C
145A:  MOVFF  03,2D
145E:  MOVFF  02,2C
1462:  MOVFF  01,2B
1466:  MOVFF  00,2A
146A:  MOVFF  03,51
146E:  MOVFF  02,50
1472:  MOVFF  01,4F
1476:  MOVFF  00,4E
147A:  CLRF   55
147C:  CLRF   54
147E:  CLRF   53
1480:  CLRF   52
1482:  CALL   05A4
1486:  BZ    1494
....................       return 0; 
1488:  CLRF   00
148A:  CLRF   01
148C:  CLRF   02
148E:  CLRF   03
1490:  BRA    153C
....................    } else { 
1492:  BRA    153C
....................       if(x != 0 || 0 >= y) { 
1494:  MOVFF  25,51
1498:  MOVFF  24,50
149C:  MOVFF  23,4F
14A0:  MOVFF  22,4E
14A4:  CLRF   55
14A6:  CLRF   54
14A8:  CLRF   53
14AA:  CLRF   52
14AC:  CALL   05A4
14B0:  BNZ   14D2
14B2:  MOVFF  29,51
14B6:  MOVFF  28,50
14BA:  MOVFF  27,4F
14BE:  MOVFF  26,4E
14C2:  CLRF   55
14C4:  CLRF   54
14C6:  CLRF   53
14C8:  CLRF   52
14CA:  CALL   05A4
14CE:  BC    14D2
14D0:  BNZ   153C
....................          return (exp(log(x) * y)); 
14D2:  MOVFF  25,31
14D6:  MOVFF  24,30
14DA:  MOVFF  23,2F
14DE:  MOVFF  22,2E
14E2:  CALL   0662
14E6:  MOVFF  03,2D
14EA:  MOVFF  02,2C
14EE:  MOVFF  01,2B
14F2:  MOVFF  00,2A
14F6:  MOVFF  03,51
14FA:  MOVFF  02,50
14FE:  MOVFF  01,4F
1502:  MOVFF  00,4E
1506:  MOVFF  29,55
150A:  MOVFF  28,54
150E:  MOVFF  27,53
1512:  MOVFF  26,52
1516:  CALL   00EE
151A:  MOVFF  03,2D
151E:  MOVFF  02,2C
1522:  MOVFF  01,2B
1526:  MOVFF  00,2A
152A:  MOVFF  03,31
152E:  MOVFF  02,30
1532:  MOVFF  01,2F
1536:  MOVFF  00,2E
153A:  RCALL  0E98
....................       } 
....................    } 
153C:  GOTO   16D8 (RETURN)
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #fuses XT,NOWDT,PUT,NOBROWNOUT,NOLVP    // bits de configuração 
.................... #use   delay(clock=40000000)// definir isso direito  
*
002C:  CLRF   FEA
002E:  MOVLW  23
0030:  MOVWF  FE9
0032:  MOVF   FEF,W
0034:  BZ    0052
0036:  MOVLW  0C
0038:  MOVWF  01
003A:  CLRF   00
003C:  DECFSZ 00,F
003E:  BRA    003C
0040:  DECFSZ 01,F
0042:  BRA    003A
0044:  MOVLW  F7
0046:  MOVWF  00
0048:  DECFSZ 00,F
004A:  BRA    0048
004C:  BRA    004E
004E:  DECFSZ FEF,F
0050:  BRA    0036
0052:  RETURN 0
0054:  MOVLW  02
0056:  SUBWF  22,F
0058:  BNC   0070
005A:  CLRF   FEA
005C:  MOVLW  22
005E:  MOVWF  FE9
0060:  MOVF   FEF,W
0062:  BZ    0070
0064:  MOVLW  02
0066:  MOVWF  00
0068:  DECFSZ 00,F
006A:  BRA    0068
006C:  DECFSZ FEF,F
006E:  BRA    0064
0070:  GOTO   009A (RETURN)
.................... #use   fast_io(a) 
.................... #use   fast_io(b) 
.................... #use   fast_io(c) 
.................... #use   fast_io(d) 
.................... #use   fast_io(e) 
....................  
.................... #byte   porta = 0xf80 
.................... #byte   portb = 0xf81 
.................... #byte   portc = 0xf82 
.................... #byte   portd = 0xf83 
.................... #byte   porte = 0xf84 
.................... #bit NTC = porta.0 
.................... #bit RELE_LAMP = portb.2 
.................... #bit PIN_COOLER = portb.7 
.................... #bit rs = porte.0     // via do lcd que sinaliza recepção de dados ou comando 
.................... #bit enable = porte.1 // enable do lcd 
.................... #byte   DISPLAY = portd  //tem que ser a mesma porta escolhida dentro do arquivo lcd.h 
.................... // Bibliotecas 
.................... #include   <lcd.h> 
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *      Rotina que envia um COMANDO para o LCD                 * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void comando_lcd(int caracter) 
.................... { 
....................    rs = 0;               // seleciona o envio de um caracter 
*
0008:  BCF    F84.0
....................    portd = caracter;         // carrega o portc com o caracter 
000A:  MOVFF  22,F83
....................    enable = 1 ;            // gera pulso no enable 
000E:  BSF    F84.1
....................    delay_us(1);            // espera 1 microsegundos 
0010:  MOVLW  02
0012:  MOVWF  00
0014:  DECFSZ 00,F
0016:  BRA    0014
0018:  BRA    001A
001A:  NOP   
....................    enable = 0;            // desce o pino de enable 
001C:  BCF    F84.1
....................  
....................    delay_us(40);            // espera mínimo 40 microsegundos 
001E:  MOVLW  84
0020:  MOVWF  00
0022:  DECFSZ 00,F
0024:  BRA    0022
0026:  BRA    0028
0028:  NOP   
....................     
....................    return;               // retorna 
002A:  RETURN 0
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *      Rotina que envia um DADO a ser escrito no LCD              * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void escreve_lcd(int caracter) 
.................... { 
....................    rs = 1;               // seleciona o envio de um comando 
*
1800:  BSF    F84.0
....................    portd = caracter;         // carrega o portc com o valor do comando 
1802:  MOVFF  24,F83
....................    enable = 1;            // gera pulso no enable 
1806:  BSF    F84.1
....................    delay_us(1);            // espera 3 microsegundos 
1808:  MOVLW  02
180A:  MOVWF  00
180C:  DECFSZ 00,F
180E:  BRA    180C
1810:  BRA    1812
1812:  NOP   
....................    enable = 0;            // desce o pino de enable 
1814:  BCF    F84.1
....................  
....................    delay_us(40);            // espera mínimo 40 microsegundos 
1816:  MOVLW  84
1818:  MOVWF  00
181A:  DECFSZ 00,F
181C:  BRA    181A
181E:  BRA    1820
1820:  NOP   
....................     
....................    return;               // retorna 
1822:  GOTO   183A (RETURN)
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *              Função para limpar o LCD                 * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void limpa_lcd() 
.................... { 
....................    comando_lcd(0x01);         // limpa lcd    
*
0074:  MOVLW  01
0076:  MOVWF  22
0078:  RCALL  0008
....................    delay_ms (2); 
007A:  MOVLW  02
007C:  MOVWF  23
007E:  RCALL  002C
....................    return; 
0080:  RETURN 0
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *           Inicialização do Display de LCD                 * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void inicializa_lcd() 
.................... { 
....................    comando_lcd(0x30);         // envia comando para inicializar display 
0082:  MOVLW  30
0084:  MOVWF  22
0086:  RCALL  0008
....................    delay_ms(4);            // espera 4 milisengundos 
0088:  MOVLW  04
008A:  MOVWF  23
008C:  RCALL  002C
....................  
....................    comando_lcd(0x30);         // envia comando para inicializar display 
008E:  MOVLW  30
0090:  MOVWF  22
0092:  RCALL  0008
....................    delay_us(100);            // espera 100 microsengundos 
0094:  MOVLW  64
0096:  MOVWF  22
0098:  BRA    0054
....................  
....................    comando_lcd(0x30);         // envia comando para inicializar display 
009A:  MOVLW  30
009C:  MOVWF  22
009E:  RCALL  0008
....................  
....................    comando_lcd(0x38);         // liga o display, sem cursor e sem blink 
00A0:  MOVLW  38
00A2:  MOVWF  22
00A4:  RCALL  0008
....................  
....................    limpa_lcd();            // limpa lcd 
00A6:  RCALL  0074
....................  
....................    comando_lcd(0x0c);         // display sem cursor 
00A8:  MOVLW  0C
00AA:  MOVWF  22
00AC:  RCALL  0008
....................  
....................    comando_lcd(0x06);         // desloca cursor para a direita 
00AE:  MOVLW  06
00B0:  MOVWF  22
00B2:  RCALL  0008
....................  
....................    return;               // retorna 
00B4:  GOTO   18BA (RETURN)
.................... }    
....................  
....................  
.................... float ntc_val = 0; 
.................... float rntc = 0; 
.................... float b1=0; 
.................... float c1=0; 
.................... float temp=0; 
.................... float temperatura; 
.................... const float a = 0.0011303; 
.................... const float b = 0.0002339; 
.................... const double c = 0.00000008863; 
....................  
....................       float ntc(){ 
....................       set_adc_channel(0); //  escolhe o pino analogico para ler  
*
1540:  MOVLW  00
1542:  MOVWF  01
1544:  MOVF   FC2,W
1546:  ANDLW  C3
1548:  IORWF  01,W
154A:  MOVWF  FC2
....................       delay_us(10); // delay para começar a conversão  
154C:  MOVLW  20
154E:  MOVWF  00
1550:  DECFSZ 00,F
1552:  BRA    1550
1554:  BRA    1556
1556:  NOP   
....................       ntc_val = read_adc(); // le o valor na porta analogica 
1558:  BSF    FC2.1
155A:  BTFSC  FC2.1
155C:  BRA    155A
155E:  MOVF   FC4,W
1560:  CLRF   53
1562:  MOVWF  52
1564:  CALL   00B8
1568:  MOVFF  03,0D
156C:  MOVFF  02,0C
1570:  MOVFF  01,0B
1574:  MOVFF  00,0A
....................       ntc_val *=5; //  
1578:  MOVFF  0D,51
157C:  MOVFF  0C,50
1580:  MOVFF  0B,4F
1584:  MOVFF  0A,4E
1588:  CLRF   55
158A:  CLRF   54
158C:  MOVLW  20
158E:  MOVWF  53
1590:  MOVLW  81
1592:  MOVWF  52
1594:  CALL   00EE
1598:  MOVFF  03,0D
159C:  MOVFF  02,0C
15A0:  MOVFF  01,0B
15A4:  MOVFF  00,0A
....................       ntc_val/=1023; 
15A8:  MOVFF  0D,4A
15AC:  MOVFF  0C,49
15B0:  MOVFF  0B,48
15B4:  MOVFF  0A,47
15B8:  CLRF   4E
15BA:  MOVLW  C0
15BC:  MOVWF  4D
15BE:  MOVLW  7F
15C0:  MOVWF  4C
15C2:  MOVLW  88
15C4:  MOVWF  4B
15C6:  CALL   01E0
15CA:  MOVFF  03,0D
15CE:  MOVFF  02,0C
15D2:  MOVFF  01,0B
15D6:  MOVFF  00,0A
....................       rntc=33000/ntc_val;     
15DA:  CLRF   4A
15DC:  MOVLW  E8
15DE:  MOVWF  49
15E0:  CLRF   48
15E2:  MOVLW  8E
15E4:  MOVWF  47
15E6:  MOVFF  0D,4E
15EA:  MOVFF  0C,4D
15EE:  MOVFF  0B,4C
15F2:  MOVFF  0A,4B
15F6:  CALL   01E0
15FA:  MOVFF  03,11
15FE:  MOVFF  02,10
1602:  MOVFF  01,0F
1606:  MOVFF  00,0E
....................              rntc=rntc-10000;       
160A:  BSF    FD8.1
160C:  MOVFF  11,55
1610:  MOVFF  10,54
1614:  MOVFF  0F,53
1618:  MOVFF  0E,52
161C:  CLRF   59
161E:  MOVLW  40
1620:  MOVWF  58
1622:  MOVLW  1C
1624:  MOVWF  57
1626:  MOVLW  8C
1628:  MOVWF  56
162A:  CALL   033A
162E:  MOVFF  03,11
1632:  MOVFF  02,10
1636:  MOVFF  01,0F
163A:  MOVFF  00,0E
....................              b1=log(rntc);           
163E:  MOVFF  11,31
1642:  MOVFF  10,30
1646:  MOVFF  0F,2F
164A:  MOVFF  0E,2E
164E:  CALL   0662
1652:  MOVFF  03,15
1656:  MOVFF  02,14
165A:  MOVFF  01,13
165E:  MOVFF  00,12
....................              b1=b1*b;                
1662:  MOVFF  15,51
1666:  MOVFF  14,50
166A:  MOVFF  13,4F
166E:  MOVFF  12,4E
1672:  MOVLW  0E
1674:  MOVWF  55
1676:  MOVLW  43
1678:  MOVWF  54
167A:  MOVLW  75
167C:  MOVWF  53
167E:  MOVLW  72
1680:  MOVWF  52
1682:  CALL   00EE
1686:  MOVFF  03,15
168A:  MOVFF  02,14
168E:  MOVFF  01,13
1692:  MOVFF  00,12
....................              c1=log(rntc);           
1696:  MOVFF  11,31
169A:  MOVFF  10,30
169E:  MOVFF  0F,2F
16A2:  MOVFF  0E,2E
16A6:  CALL   0662
16AA:  MOVFF  03,19
16AE:  MOVFF  02,18
16B2:  MOVFF  01,17
16B6:  MOVFF  00,16
....................              c1=pow(c1,3);           
16BA:  MOVFF  19,25
16BE:  MOVFF  18,24
16C2:  MOVFF  17,23
16C6:  MOVFF  16,22
16CA:  CLRF   29
16CC:  CLRF   28
16CE:  MOVLW  40
16D0:  MOVWF  27
16D2:  MOVLW  80
16D4:  MOVWF  26
16D6:  BRA    126A
16D8:  MOVFF  03,19
16DC:  MOVFF  02,18
16E0:  MOVFF  01,17
16E4:  MOVFF  00,16
....................              c1=c1*c;                
16E8:  MOVFF  19,51
16EC:  MOVFF  18,50
16F0:  MOVFF  17,4F
16F4:  MOVFF  16,4E
16F8:  MOVLW  DC
16FA:  MOVWF  55
16FC:  MOVLW  54
16FE:  MOVWF  54
1700:  MOVLW  3E
1702:  MOVWF  53
1704:  MOVLW  67
1706:  MOVWF  52
1708:  CALL   00EE
170C:  MOVFF  03,19
1710:  MOVFF  02,18
1714:  MOVFF  01,17
1718:  MOVFF  00,16
....................              temp=a+b1+c1;           
171C:  BCF    FD8.1
171E:  MOVLW  93
1720:  MOVWF  55
1722:  MOVLW  26
1724:  MOVWF  54
1726:  MOVLW  14
1728:  MOVWF  53
172A:  MOVLW  75
172C:  MOVWF  52
172E:  MOVFF  15,59
1732:  MOVFF  14,58
1736:  MOVFF  13,57
173A:  MOVFF  12,56
173E:  CALL   033A
1742:  MOVFF  03,25
1746:  MOVFF  02,24
174A:  MOVFF  01,23
174E:  MOVFF  00,22
1752:  BCF    FD8.1
1754:  MOVFF  03,55
1758:  MOVFF  02,54
175C:  MOVFF  01,53
1760:  MOVFF  00,52
1764:  MOVFF  19,59
1768:  MOVFF  18,58
176C:  MOVFF  17,57
1770:  MOVFF  16,56
1774:  CALL   033A
1778:  MOVFF  03,1D
177C:  MOVFF  02,1C
1780:  MOVFF  01,1B
1784:  MOVFF  00,1A
....................              temp=1/temp;            
1788:  CLRF   4A
178A:  CLRF   49
178C:  CLRF   48
178E:  MOVLW  7F
1790:  MOVWF  47
1792:  MOVFF  1D,4E
1796:  MOVFF  1C,4D
179A:  MOVFF  1B,4C
179E:  MOVFF  1A,4B
17A2:  CALL   01E0
17A6:  MOVFF  03,1D
17AA:  MOVFF  02,1C
17AE:  MOVFF  01,1B
17B2:  MOVFF  00,1A
....................              temp=temp-273.15; 
17B6:  BSF    FD8.1
17B8:  MOVFF  1D,55
17BC:  MOVFF  1C,54
17C0:  MOVFF  1B,53
17C4:  MOVFF  1A,52
17C8:  MOVLW  33
17CA:  MOVWF  59
17CC:  MOVLW  93
17CE:  MOVWF  58
17D0:  MOVLW  08
17D2:  MOVWF  57
17D4:  MOVLW  87
17D6:  MOVWF  56
17D8:  CALL   033A
17DC:  MOVFF  03,1D
17E0:  MOVFF  02,1C
17E4:  MOVFF  01,1B
17E8:  MOVFF  00,1A
....................              return temp; 
17EC:  MOVFF  1A,00
17F0:  MOVFF  1B,01
17F4:  MOVFF  1C,02
17F8:  MOVFF  1D,03
17FC:  GOTO   18BC (RETURN)
....................        
....................       } 
....................   
....................  void main (void){ 
*
1848:  CLRF   FF8
184A:  BCF    FD0.7
184C:  CLRF   0D
184E:  CLRF   0C
1850:  CLRF   0B
1852:  CLRF   0A
1854:  CLRF   11
1856:  CLRF   10
1858:  CLRF   0F
185A:  CLRF   0E
185C:  CLRF   15
185E:  CLRF   14
1860:  CLRF   13
1862:  CLRF   12
1864:  CLRF   19
1866:  CLRF   18
1868:  CLRF   17
186A:  CLRF   16
186C:  CLRF   1D
186E:  CLRF   1C
1870:  CLRF   1B
1872:  CLRF   1A
1874:  MOVF   FC1,W
1876:  ANDLW  C0
1878:  IORLW  0F
187A:  MOVWF  FC1
187C:  MOVLW  07
187E:  MOVWF  FB4
1880:  CLRF   04
1882:  CLRF   05
....................   
....................          setup_adc(  ADC_CLOCK_INTERNAL  );  
1884:  MOVF   FC0,W
1886:  ANDLW  C0
1888:  IORLW  07
188A:  MOVWF  FC0
188C:  BCF    FC0.7
188E:  BSF    FC2.0
....................          setup_adc_ports( AN0_TO_AN3 ); 
1890:  MOVF   FC1,W
1892:  ANDLW  C0
1894:  IORLW  0B
1896:  MOVWF  FC1
....................          set_tris_a(0b00001111);  
1898:  MOVLW  0F
189A:  MOVWF  F92
....................          set_tris_b(0b11000000);  
189C:  MOVLW  C0
189E:  MOVWF  F93
....................          set_tris_c(0b11111111); 
18A0:  MOVLW  FF
18A2:  MOVWF  F94
....................       set_tris_d(0b00000000); 
18A4:  MOVLW  00
18A6:  MOVWF  F95
....................       set_tris_e(0b00000100); 
18A8:  MOVLW  04
18AA:  MOVWF  F96
....................             porta=0x00;            // limpa porta 
18AC:  CLRF   F80
....................       portb=0x00;            // limpa portb 
18AE:  CLRF   F81
....................       portc=0x00;            // limpa portc 
18B0:  CLRF   F82
....................       portd=0x00;            // limpa portd 
18B2:  CLRF   F83
....................       porte=0x00;            // limpa porte 
18B4:  CLRF   F84
....................  
....................       inicializa_lcd();         // configura o lcd 
18B6:  GOTO   0082
....................           
....................                   while(true){ 
....................                  temperatura = ntc(); 
18BA:  BRA    1540
18BC:  MOVFF  03,21
18C0:  MOVFF  02,20
18C4:  MOVFF  01,1F
18C8:  MOVFF  00,1E
....................                  comando_lcd(0x83);      // posiciona o cursor no endereço 83h 
18CC:  MOVLW  83
18CE:  MOVWF  22
18D0:  CALL   0008
....................       printf(escreve_lcd, "ola"); 
18D4:  MOVLW  04
18D6:  MOVWF  FF6
18D8:  MOVLW  00
18DA:  MOVWF  FF7
18DC:  BRA    1826
....................       delay_ms(1000); 
18DE:  MOVLW  04
18E0:  MOVWF  22
18E2:  MOVLW  FA
18E4:  MOVWF  23
18E6:  CALL   002C
18EA:  DECFSZ 22,F
18EC:  BRA    18E2
....................        limpa_lcd(); 
18EE:  CALL   0074
....................       delay_ms(1000); 
18F2:  MOVLW  04
18F4:  MOVWF  22
18F6:  MOVLW  FA
18F8:  MOVWF  23
18FA:  CALL   002C
18FE:  DECFSZ 22,F
1900:  BRA    18F6
....................                   
....................                  if(temperatura<=38){ 
1902:  MOVFF  21,51
1906:  MOVFF  20,50
190A:  MOVFF  1F,4F
190E:  MOVFF  1E,4E
1912:  CLRF   55
1914:  CLRF   54
1916:  MOVLW  18
1918:  MOVWF  53
191A:  MOVLW  84
191C:  MOVWF  52
191E:  CALL   05A4
1922:  BC    1926
1924:  BNZ   192A
....................                  PIN_COOLER =0 ; 
1926:  BCF    F81.7
....................                  RELE_LAMP = 1 ; 
1928:  BSF    F81.2
....................                 } 
....................                 if(temperatura>38){ 
192A:  CLRF   51
192C:  CLRF   50
192E:  MOVLW  18
1930:  MOVWF  4F
1932:  MOVLW  84
1934:  MOVWF  4E
1936:  MOVFF  21,55
193A:  MOVFF  20,54
193E:  MOVFF  1F,53
1942:  MOVFF  1E,52
1946:  CALL   05A4
194A:  BNC   1950
....................                 PIN_COOLER =1 ; 
194C:  BSF    F81.7
....................                 RELE_LAMP = 0 ;  
194E:  BCF    F81.2
....................                 } 
....................                 delay_ms(2000);    
1950:  MOVLW  08
1952:  MOVWF  22
1954:  MOVLW  FA
1956:  MOVWF  23
1958:  CALL   002C
195C:  DECFSZ 22,F
195E:  BRA    1954
1960:  BRA    18BA
....................               } 
....................    
.................... } 
1962:  SLEEP 

Configuration Fuses:
   Word  1: C03F   PLL12 CPUDIV4 USBDIV XT FCMEN IESO
   Word  2: 1E38   PUT NOBROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
