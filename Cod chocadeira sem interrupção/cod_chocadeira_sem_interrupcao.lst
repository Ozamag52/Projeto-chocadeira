CCS PCH C Compiler, Version 5.015, 5967               24-jun-17 22:29

               Filename:   C:\Users\henri\Documents\GitHub\Projeto-chocadeira\Cod chocadeira sem interrupção\cod_chocadeira_sem_interrupcao.lst

               ROM used:   7426 bytes (23%)
                           Largest free fragment is 25342
               RAM used:   53 (3%) at main() level
                           117 (6%) worst case
               Stack used: 6 locations
               Stack size: 31

*
0000:  GOTO   1BD2
....................  
.................... #INCLUDE<18F4550.h>//   Inclui a biblioteca resposável por estabelecer os parametros do pic utilizado no projeto 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
*
0090:  MOVLW  8E
0092:  MOVWF  00
0094:  MOVFF  66,01
0098:  MOVFF  65,02
009C:  CLRF   03
009E:  MOVF   01,F
00A0:  BNZ   00B4
00A2:  MOVFF  02,01
00A6:  CLRF   02
00A8:  MOVLW  08
00AA:  SUBWF  00,F
00AC:  MOVF   01,F
00AE:  BNZ   00B4
00B0:  CLRF   00
00B2:  BRA    00C4
00B4:  BCF    FD8.0
00B6:  BTFSC  01.7
00B8:  BRA    00C2
00BA:  RLCF   02,F
00BC:  RLCF   01,F
00BE:  DECF   00,F
00C0:  BRA    00B4
00C2:  BCF    01.7
00C4:  RETURN 0
00C6:  MOVF   x61,W
00C8:  BTFSC  FD8.2
00CA:  BRA    01AE
00CC:  MOVWF  00
00CE:  MOVF   x65,W
00D0:  BTFSC  FD8.2
00D2:  BRA    01AE
00D4:  ADDWF  00,F
00D6:  BNC   00E0
00D8:  MOVLW  81
00DA:  ADDWF  00,F
00DC:  BC    01AE
00DE:  BRA    00E8
00E0:  MOVLW  7F
00E2:  SUBWF  00,F
00E4:  BNC   01AE
00E6:  BZ    01AE
00E8:  MOVFF  62,69
00EC:  MOVF   x66,W
00EE:  XORWF  x69,F
00F0:  BSF    x62.7
00F2:  BSF    x66.7
00F4:  MOVF   x64,W
00F6:  MULWF  x68
00F8:  MOVFF  FF4,6B
00FC:  MOVF   x63,W
00FE:  MULWF  x67
0100:  MOVFF  FF4,03
0104:  MOVFF  FF3,6A
0108:  MULWF  x68
010A:  MOVF   FF3,W
010C:  ADDWF  x6B,F
010E:  MOVF   FF4,W
0110:  ADDWFC x6A,F
0112:  MOVLW  00
0114:  ADDWFC 03,F
0116:  MOVF   x64,W
0118:  MULWF  x67
011A:  MOVF   FF3,W
011C:  ADDWF  x6B,F
011E:  MOVF   FF4,W
0120:  ADDWFC x6A,F
0122:  MOVLW  00
0124:  CLRF   02
0126:  ADDWFC 03,F
0128:  ADDWFC 02,F
012A:  MOVF   x62,W
012C:  MULWF  x68
012E:  MOVF   FF3,W
0130:  ADDWF  x6A,F
0132:  MOVF   FF4,W
0134:  ADDWFC 03,F
0136:  MOVLW  00
0138:  ADDWFC 02,F
013A:  MOVF   x62,W
013C:  MULWF  x67
013E:  MOVF   FF3,W
0140:  ADDWF  03,F
0142:  MOVF   FF4,W
0144:  ADDWFC 02,F
0146:  MOVLW  00
0148:  CLRF   01
014A:  ADDWFC 01,F
014C:  MOVF   x64,W
014E:  MULWF  x66
0150:  MOVF   FF3,W
0152:  ADDWF  x6A,F
0154:  MOVF   FF4,W
0156:  ADDWFC 03,F
0158:  MOVLW  00
015A:  ADDWFC 02,F
015C:  ADDWFC 01,F
015E:  MOVF   x63,W
0160:  MULWF  x66
0162:  MOVF   FF3,W
0164:  ADDWF  03,F
0166:  MOVF   FF4,W
0168:  ADDWFC 02,F
016A:  MOVLW  00
016C:  ADDWFC 01,F
016E:  MOVF   x62,W
0170:  MULWF  x66
0172:  MOVF   FF3,W
0174:  ADDWF  02,F
0176:  MOVF   FF4,W
0178:  ADDWFC 01,F
017A:  INCF   00,F
017C:  BTFSC  01.7
017E:  BRA    018A
0180:  RLCF   x6A,F
0182:  RLCF   03,F
0184:  RLCF   02,F
0186:  RLCF   01,F
0188:  DECF   00,F
018A:  MOVLW  00
018C:  BTFSS  x6A.7
018E:  BRA    01A4
0190:  INCF   03,F
0192:  ADDWFC 02,F
0194:  ADDWFC 01,F
0196:  MOVF   01,W
0198:  BNZ   01A4
019A:  MOVF   02,W
019C:  BNZ   01A4
019E:  MOVF   03,W
01A0:  BNZ   01A4
01A2:  INCF   00,F
01A4:  BTFSC  x69.7
01A6:  BSF    01.7
01A8:  BTFSS  x69.7
01AA:  BCF    01.7
01AC:  BRA    01B6
01AE:  CLRF   00
01B0:  CLRF   01
01B2:  CLRF   02
01B4:  CLRF   03
01B6:  RETURN 0
01B8:  MOVF   5A,W
01BA:  BTFSC  FD8.2
01BC:  BRA    0308
01BE:  MOVWF  x66
01C0:  MOVF   5E,W
01C2:  BTFSC  FD8.2
01C4:  BRA    0308
01C6:  SUBWF  x66,F
01C8:  BNC   01D4
01CA:  MOVLW  7F
01CC:  ADDWF  x66,F
01CE:  BTFSC  FD8.0
01D0:  BRA    0308
01D2:  BRA    01E0
01D4:  MOVLW  81
01D6:  SUBWF  x66,F
01D8:  BTFSS  FD8.0
01DA:  BRA    0308
01DC:  BTFSC  FD8.2
01DE:  BRA    0308
01E0:  MOVFF  66,00
01E4:  CLRF   01
01E6:  CLRF   02
01E8:  CLRF   03
01EA:  CLRF   x65
01EC:  MOVFF  5B,64
01F0:  BSF    x64.7
01F2:  MOVFF  5C,63
01F6:  MOVFF  5D,62
01FA:  MOVLW  19
01FC:  MOVWF  x66
01FE:  MOVF   x61,W
0200:  SUBWF  x62,F
0202:  BC    021E
0204:  MOVLW  01
0206:  SUBWF  x63,F
0208:  BC    021E
020A:  SUBWF  x64,F
020C:  BC    021E
020E:  SUBWF  x65,F
0210:  BC    021E
0212:  INCF   x65,F
0214:  INCF   x64,F
0216:  INCF   x63,F
0218:  MOVF   x61,W
021A:  ADDWF  x62,F
021C:  BRA    026E
021E:  MOVF   x60,W
0220:  SUBWF  x63,F
0222:  BC    0248
0224:  MOVLW  01
0226:  SUBWF  x64,F
0228:  BC    0248
022A:  SUBWF  x65,F
022C:  BC    0248
022E:  INCF   x65,F
0230:  INCF   x64,F
0232:  MOVF   x60,W
0234:  ADDWF  x63,F
0236:  MOVF   x61,W
0238:  ADDWF  x62,F
023A:  BNC   026E
023C:  INCF   x63,F
023E:  BNZ   026E
0240:  INCF   x64,F
0242:  BNZ   026E
0244:  INCF   x65,F
0246:  BRA    026E
0248:  MOVF   5F,W
024A:  IORLW  80
024C:  SUBWF  x64,F
024E:  BC    026C
0250:  MOVLW  01
0252:  SUBWF  x65,F
0254:  BC    026C
0256:  INCF   x65,F
0258:  MOVF   5F,W
025A:  IORLW  80
025C:  ADDWF  x64,F
025E:  MOVF   x60,W
0260:  ADDWF  x63,F
0262:  BNC   0236
0264:  INCF   x64,F
0266:  BNZ   0236
0268:  INCF   x65,F
026A:  BRA    0236
026C:  BSF    03.0
026E:  DECFSZ x66,F
0270:  BRA    0274
0272:  BRA    028A
0274:  BCF    FD8.0
0276:  RLCF   x62,F
0278:  RLCF   x63,F
027A:  RLCF   x64,F
027C:  RLCF   x65,F
027E:  BCF    FD8.0
0280:  RLCF   03,F
0282:  RLCF   02,F
0284:  RLCF   01,F
0286:  RLCF   x67,F
0288:  BRA    01FE
028A:  BTFSS  x67.0
028C:  BRA    029A
028E:  BCF    FD8.0
0290:  RRCF   01,F
0292:  RRCF   02,F
0294:  RRCF   03,F
0296:  RRCF   x67,F
0298:  BRA    029E
029A:  DECF   00,F
029C:  BZ    0308
029E:  BTFSC  x67.7
02A0:  BRA    02DE
02A2:  BCF    FD8.0
02A4:  RLCF   x62,F
02A6:  RLCF   x63,F
02A8:  RLCF   x64,F
02AA:  RLCF   x65,F
02AC:  MOVF   x61,W
02AE:  SUBWF  x62,F
02B0:  BC    02C0
02B2:  MOVLW  01
02B4:  SUBWF  x63,F
02B6:  BC    02C0
02B8:  SUBWF  x64,F
02BA:  BC    02C0
02BC:  SUBWF  x65,F
02BE:  BNC   02F4
02C0:  MOVF   x60,W
02C2:  SUBWF  x63,F
02C4:  BC    02D0
02C6:  MOVLW  01
02C8:  SUBWF  x64,F
02CA:  BC    02D0
02CC:  SUBWF  x65,F
02CE:  BNC   02F4
02D0:  MOVF   5F,W
02D2:  IORLW  80
02D4:  SUBWF  x64,F
02D6:  BC    02DE
02D8:  MOVLW  01
02DA:  SUBWF  x65,F
02DC:  BNC   02F4
02DE:  INCF   03,F
02E0:  BNZ   02F4
02E2:  INCF   02,F
02E4:  BNZ   02F4
02E6:  INCF   01,F
02E8:  BNZ   02F4
02EA:  INCF   00,F
02EC:  BZ    0308
02EE:  RRCF   01,F
02F0:  RRCF   02,F
02F2:  RRCF   03,F
02F4:  MOVFF  5B,66
02F8:  MOVF   5F,W
02FA:  XORWF  x66,F
02FC:  BTFSS  x66.7
02FE:  BRA    0304
0300:  BSF    01.7
0302:  BRA    0310
0304:  BCF    01.7
0306:  BRA    0310
0308:  CLRF   00
030A:  CLRF   01
030C:  CLRF   02
030E:  CLRF   03
0310:  RETURN 0
0312:  MOVLW  80
0314:  BTFSC  FD8.1
0316:  XORWF  x6A,F
0318:  CLRF   x6F
031A:  CLRF   x70
031C:  MOVFF  66,6E
0320:  MOVF   x6A,W
0322:  XORWF  x6E,F
0324:  MOVF   x65,W
0326:  BTFSC  FD8.2
0328:  BRA    04E2
032A:  MOVWF  x6D
032C:  MOVWF  00
032E:  MOVF   x69,W
0330:  BTFSC  FD8.2
0332:  BRA    04F4
0334:  SUBWF  x6D,F
0336:  BTFSC  FD8.2
0338:  BRA    043C
033A:  BNC   03B6
033C:  MOVFF  6A,73
0340:  BSF    x73.7
0342:  MOVFF  6B,72
0346:  MOVFF  6C,71
034A:  CLRF   x70
034C:  BCF    FD8.0
034E:  RRCF   x73,F
0350:  RRCF   x72,F
0352:  RRCF   x71,F
0354:  RRCF   x70,F
0356:  DECFSZ x6D,F
0358:  BRA    034A
035A:  BTFSS  x6E.7
035C:  BRA    0364
035E:  BSF    x6F.0
0360:  BRA    051C
0362:  BCF    x6F.0
0364:  BCF    x6D.0
0366:  BSF    x6F.4
0368:  CLRF   FEA
036A:  MOVLW  68
036C:  MOVWF  FE9
036E:  BRA    0542
0370:  BCF    x6F.4
0372:  BTFSC  x6E.7
0374:  BRA    038A
0376:  BTFSS  x6D.0
0378:  BRA    03A0
037A:  RRCF   x73,F
037C:  RRCF   x72,F
037E:  RRCF   x71,F
0380:  RRCF   x70,F
0382:  INCF   00,F
0384:  BTFSC  FD8.2
0386:  BRA    0512
0388:  BRA    03A0
038A:  BTFSC  x73.7
038C:  BRA    03A6
038E:  BCF    FD8.0
0390:  RLCF   x70,F
0392:  RLCF   x71,F
0394:  RLCF   x72,F
0396:  RLCF   x73,F
0398:  DECF   00,F
039A:  BTFSC  FD8.2
039C:  BRA    0512
039E:  BRA    038A
03A0:  BSF    x6F.6
03A2:  BRA    047A
03A4:  BCF    x6F.6
03A6:  MOVFF  66,6E
03AA:  BTFSS  x66.7
03AC:  BRA    03B2
03AE:  BSF    x73.7
03B0:  BRA    0504
03B2:  BCF    x73.7
03B4:  BRA    0504
03B6:  MOVFF  69,6D
03BA:  MOVFF  69,00
03BE:  MOVF   x65,W
03C0:  SUBWF  x6D,F
03C2:  MOVFF  66,73
03C6:  BSF    x73.7
03C8:  MOVFF  67,72
03CC:  MOVFF  68,71
03D0:  CLRF   x70
03D2:  BCF    FD8.0
03D4:  RRCF   x73,F
03D6:  RRCF   x72,F
03D8:  RRCF   x71,F
03DA:  RRCF   x70,F
03DC:  DECFSZ x6D,F
03DE:  BRA    03D0
03E0:  BTFSS  x6E.7
03E2:  BRA    03EA
03E4:  BSF    x6F.1
03E6:  BRA    051C
03E8:  BCF    x6F.1
03EA:  BCF    x6D.0
03EC:  BSF    x6F.5
03EE:  CLRF   FEA
03F0:  MOVLW  6C
03F2:  MOVWF  FE9
03F4:  BRA    0542
03F6:  BCF    x6F.5
03F8:  BTFSC  x6E.7
03FA:  BRA    0410
03FC:  BTFSS  x6D.0
03FE:  BRA    0426
0400:  RRCF   x73,F
0402:  RRCF   x72,F
0404:  RRCF   x71,F
0406:  RRCF   x70,F
0408:  INCF   00,F
040A:  BTFSC  FD8.2
040C:  BRA    0512
040E:  BRA    0426
0410:  BTFSC  x73.7
0412:  BRA    042C
0414:  BCF    FD8.0
0416:  RLCF   x70,F
0418:  RLCF   x71,F
041A:  RLCF   x72,F
041C:  RLCF   x73,F
041E:  DECF   00,F
0420:  BTFSC  FD8.2
0422:  BRA    0512
0424:  BRA    0410
0426:  BSF    x6F.7
0428:  BRA    047A
042A:  BCF    x6F.7
042C:  MOVFF  6A,6E
0430:  BTFSS  x6A.7
0432:  BRA    0438
0434:  BSF    x73.7
0436:  BRA    0504
0438:  BCF    x73.7
043A:  BRA    0504
043C:  MOVFF  6A,73
0440:  BSF    x73.7
0442:  MOVFF  6B,72
0446:  MOVFF  6C,71
044A:  BTFSS  x6E.7
044C:  BRA    0456
044E:  BCF    x73.7
0450:  BSF    x6F.2
0452:  BRA    051C
0454:  BCF    x6F.2
0456:  CLRF   x70
0458:  BCF    x6D.0
045A:  CLRF   FEA
045C:  MOVLW  68
045E:  MOVWF  FE9
0460:  BRA    0542
0462:  BTFSC  x6E.7
0464:  BRA    049E
0466:  MOVFF  66,6E
046A:  BTFSS  x6D.0
046C:  BRA    047A
046E:  RRCF   x73,F
0470:  RRCF   x72,F
0472:  RRCF   x71,F
0474:  RRCF   x70,F
0476:  INCF   00,F
0478:  BZ    0512
047A:  BTFSS  x70.7
047C:  BRA    0494
047E:  INCF   x71,F
0480:  BNZ   0494
0482:  INCF   x72,F
0484:  BNZ   0494
0486:  INCF   x73,F
0488:  BNZ   0494
048A:  RRCF   x73,F
048C:  RRCF   x72,F
048E:  RRCF   x71,F
0490:  INCF   00,F
0492:  BZ    0512
0494:  BTFSC  x6F.6
0496:  BRA    03A4
0498:  BTFSC  x6F.7
049A:  BRA    042A
049C:  BRA    04D6
049E:  MOVLW  80
04A0:  XORWF  x73,F
04A2:  BTFSS  x73.7
04A4:  BRA    04AE
04A6:  BRA    051C
04A8:  MOVFF  6A,6E
04AC:  BRA    04C2
04AE:  MOVFF  66,6E
04B2:  MOVF   x73,F
04B4:  BNZ   04C2
04B6:  MOVF   x72,F
04B8:  BNZ   04C2
04BA:  MOVF   x71,F
04BC:  BNZ   04C2
04BE:  CLRF   00
04C0:  BRA    0504
04C2:  BTFSC  x73.7
04C4:  BRA    04D6
04C6:  BCF    FD8.0
04C8:  RLCF   x70,F
04CA:  RLCF   x71,F
04CC:  RLCF   x72,F
04CE:  RLCF   x73,F
04D0:  DECFSZ 00,F
04D2:  BRA    04C2
04D4:  BRA    0512
04D6:  BTFSS  x6E.7
04D8:  BRA    04DE
04DA:  BSF    x73.7
04DC:  BRA    0504
04DE:  BCF    x73.7
04E0:  BRA    0504
04E2:  MOVFF  69,00
04E6:  MOVFF  6A,73
04EA:  MOVFF  6B,72
04EE:  MOVFF  6C,71
04F2:  BRA    0504
04F4:  MOVFF  65,00
04F8:  MOVFF  66,73
04FC:  MOVFF  67,72
0500:  MOVFF  68,71
0504:  MOVFF  73,01
0508:  MOVFF  72,02
050C:  MOVFF  71,03
0510:  BRA    057A
0512:  CLRF   00
0514:  CLRF   01
0516:  CLRF   02
0518:  CLRF   03
051A:  BRA    057A
051C:  CLRF   x70
051E:  COMF   x71,F
0520:  COMF   x72,F
0522:  COMF   x73,F
0524:  COMF   x70,F
0526:  INCF   x70,F
0528:  BNZ   0534
052A:  INCF   x71,F
052C:  BNZ   0534
052E:  INCF   x72,F
0530:  BNZ   0534
0532:  INCF   x73,F
0534:  BTFSC  x6F.0
0536:  BRA    0362
0538:  BTFSC  x6F.1
053A:  BRA    03E8
053C:  BTFSC  x6F.2
053E:  BRA    0454
0540:  BRA    04A8
0542:  MOVF   FEF,W
0544:  ADDWF  x71,F
0546:  BNC   0552
0548:  INCF   x72,F
054A:  BNZ   0552
054C:  INCF   x73,F
054E:  BTFSC  FD8.2
0550:  BSF    x6D.0
0552:  MOVF   FED,F
0554:  MOVF   FEF,W
0556:  ADDWF  x72,F
0558:  BNC   0560
055A:  INCF   x73,F
055C:  BTFSC  FD8.2
055E:  BSF    x6D.0
0560:  MOVF   FED,F
0562:  MOVF   FEF,W
0564:  BTFSC  FEF.7
0566:  BRA    056A
0568:  XORLW  80
056A:  ADDWF  x73,F
056C:  BTFSC  FD8.0
056E:  BSF    x6D.0
0570:  BTFSC  x6F.4
0572:  BRA    0370
0574:  BTFSC  x6F.5
0576:  BRA    03F6
0578:  BRA    0462
057A:  RETURN 0
057C:  MOVFF  62,69
0580:  MOVF   x66,W
0582:  XORWF  x69,F
0584:  BTFSS  x69.7
0586:  BRA    0592
0588:  BCF    FD8.2
058A:  BCF    FD8.0
058C:  BTFSC  x62.7
058E:  BSF    FD8.0
0590:  BRA    05F0
0592:  MOVFF  62,69
0596:  MOVFF  65,6A
059A:  MOVF   x61,W
059C:  SUBWF  x6A,F
059E:  BZ    05AC
05A0:  BTFSS  x69.7
05A2:  BRA    05F0
05A4:  MOVF   FD8,W
05A6:  XORLW  01
05A8:  MOVWF  FD8
05AA:  BRA    05F0
05AC:  MOVFF  66,6A
05B0:  MOVF   x62,W
05B2:  SUBWF  x6A,F
05B4:  BZ    05C2
05B6:  BTFSS  x69.7
05B8:  BRA    05F0
05BA:  MOVF   FD8,W
05BC:  XORLW  01
05BE:  MOVWF  FD8
05C0:  BRA    05F0
05C2:  MOVFF  67,6A
05C6:  MOVF   x63,W
05C8:  SUBWF  x6A,F
05CA:  BZ    05D8
05CC:  BTFSS  x69.7
05CE:  BRA    05F0
05D0:  MOVF   FD8,W
05D2:  XORLW  01
05D4:  MOVWF  FD8
05D6:  BRA    05F0
05D8:  MOVFF  68,6A
05DC:  MOVF   x64,W
05DE:  SUBWF  x6A,F
05E0:  BZ    05EE
05E2:  BTFSS  x69.7
05E4:  BRA    05F0
05E6:  MOVF   FD8,W
05E8:  XORLW  01
05EA:  MOVWF  FD8
05EC:  BRA    05F0
05EE:  BCF    FD8.0
05F0:  RETURN 0
05F2:  MOVLW  8E
05F4:  MOVWF  00
05F6:  MOVFF  58,01
05FA:  MOVFF  57,02
05FE:  CLRF   03
0600:  BTFSS  58.7
0602:  BRA    060E
0604:  COMF   01,F
0606:  COMF   02,F
0608:  INCF   02,F
060A:  BNZ   060E
060C:  INCF   01,F
060E:  MOVF   01,F
0610:  BNZ   0624
0612:  MOVFF  02,01
0616:  CLRF   02
0618:  MOVLW  08
061A:  SUBWF  00,F
061C:  MOVF   01,F
061E:  BNZ   0624
0620:  CLRF   00
0622:  BRA    0638
0624:  BCF    FD8.0
0626:  BTFSC  01.7
0628:  BRA    0632
062A:  RLCF   02,F
062C:  RLCF   01,F
062E:  DECF   00,F
0630:  BRA    0624
0632:  BTFSC  58.7
0634:  BRA    0638
0636:  BCF    01.7
0638:  RETURN 0
*
097A:  MOVLW  8E
097C:  MOVWF  00
097E:  MOVF   x61,W
0980:  SUBWF  00,F
0982:  MOVFF  62,02
0986:  MOVFF  63,01
098A:  BSF    02.7
098C:  MOVF   00,F
098E:  BZ    09A2
0990:  BCF    FD8.0
0992:  MOVF   02,F
0994:  BNZ   099A
0996:  MOVF   01,F
0998:  BZ    09A2
099A:  RRCF   02,F
099C:  RRCF   01,F
099E:  DECFSZ 00,F
09A0:  BRA    0990
09A2:  BTFSS  x62.7
09A4:  BRA    09B0
09A6:  COMF   01,F
09A8:  COMF   02,F
09AA:  INCF   01,F
09AC:  BTFSC  FD8.2
09AE:  INCF   02,F
09B0:  RETURN 0
*
18D4:  MOVF   36,W
18D6:  CLRF   01
18D8:  SUBWF  35,W
18DA:  BC    18E2
18DC:  MOVFF  35,00
18E0:  BRA    18FA
18E2:  CLRF   00
18E4:  MOVLW  08
18E6:  MOVWF  37
18E8:  RLCF   35,F
18EA:  RLCF   00,F
18EC:  MOVF   36,W
18EE:  SUBWF  00,W
18F0:  BTFSC  FD8.0
18F2:  MOVWF  00
18F4:  RLCF   01,F
18F6:  DECFSZ 37,F
18F8:  BRA    18E8
18FA:  RETURN 0
*
196C:  MOVF   42,W
196E:  SUBLW  B6
1970:  MOVWF  42
1972:  CLRF   03
1974:  MOVFF  43,46
1978:  BSF    43.7
197A:  BCF    FD8.0
197C:  RRCF   43,F
197E:  RRCF   44,F
1980:  RRCF   45,F
1982:  RRCF   03,F
1984:  RRCF   02,F
1986:  RRCF   01,F
1988:  RRCF   00,F
198A:  DECFSZ 42,F
198C:  BRA    197A
198E:  BTFSS  46.7
1990:  BRA    19A8
1992:  COMF   00,F
1994:  COMF   01,F
1996:  COMF   02,F
1998:  COMF   03,F
199A:  INCF   00,F
199C:  BTFSC  FD8.2
199E:  INCF   01,F
19A0:  BTFSC  FD8.2
19A2:  INCF   02,F
19A4:  BTFSC  FD8.2
19A6:  INCF   03,F
19A8:  GOTO   1AA6 (RETURN)
19AC:  BTFSC  FD8.1
19AE:  BRA    19B6
19B0:  CLRF   FEA
19B2:  MOVLW  4A
19B4:  MOVWF  FE9
19B6:  CLRF   00
19B8:  CLRF   01
19BA:  CLRF   02
19BC:  CLRF   03
19BE:  CLRF   4A
19C0:  CLRF   4B
19C2:  CLRF   4C
19C4:  CLRF   4D
19C6:  MOVF   49,W
19C8:  IORWF  48,W
19CA:  IORWF  47,W
19CC:  IORWF  46,W
19CE:  BZ    1A28
19D0:  MOVLW  20
19D2:  MOVWF  4E
19D4:  BCF    FD8.0
19D6:  RLCF   42,F
19D8:  RLCF   43,F
19DA:  RLCF   44,F
19DC:  RLCF   45,F
19DE:  RLCF   4A,F
19E0:  RLCF   4B,F
19E2:  RLCF   4C,F
19E4:  RLCF   4D,F
19E6:  MOVF   49,W
19E8:  SUBWF  4D,W
19EA:  BNZ   19FC
19EC:  MOVF   48,W
19EE:  SUBWF  4C,W
19F0:  BNZ   19FC
19F2:  MOVF   47,W
19F4:  SUBWF  4B,W
19F6:  BNZ   19FC
19F8:  MOVF   46,W
19FA:  SUBWF  4A,W
19FC:  BNC   1A1C
19FE:  MOVF   46,W
1A00:  SUBWF  4A,F
1A02:  MOVF   47,W
1A04:  BTFSS  FD8.0
1A06:  INCFSZ 47,W
1A08:  SUBWF  4B,F
1A0A:  MOVF   48,W
1A0C:  BTFSS  FD8.0
1A0E:  INCFSZ 48,W
1A10:  SUBWF  4C,F
1A12:  MOVF   49,W
1A14:  BTFSS  FD8.0
1A16:  INCFSZ 49,W
1A18:  SUBWF  4D,F
1A1A:  BSF    FD8.0
1A1C:  RLCF   00,F
1A1E:  RLCF   01,F
1A20:  RLCF   02,F
1A22:  RLCF   03,F
1A24:  DECFSZ 4E,F
1A26:  BRA    19D4
1A28:  MOVFF  4A,FEF
1A2C:  MOVFF  4B,FEC
1A30:  MOVFF  4C,FEC
1A34:  MOVFF  4D,FEC
1A38:  RETURN 0
*
1A56:  MOVF   FE9,W
1A58:  MOVWF  3A
1A5A:  MOVF   39,W
1A5C:  MOVWF  3C
1A5E:  BZ    1A94
1A60:  MOVFF  38,64
1A64:  MOVFF  37,63
1A68:  MOVFF  36,62
1A6C:  MOVFF  35,61
1A70:  CLRF   x68
1A72:  CLRF   x67
1A74:  MOVLW  20
1A76:  MOVWF  x66
1A78:  MOVLW  82
1A7A:  MOVWF  x65
1A7C:  CALL   00C6
1A80:  MOVFF  03,38
1A84:  MOVFF  02,37
1A88:  MOVFF  01,36
1A8C:  MOVFF  00,35
1A90:  DECFSZ 3C,F
1A92:  BRA    1A60
1A94:  MOVFF  38,45
1A98:  MOVFF  37,44
1A9C:  MOVFF  36,43
1AA0:  MOVFF  35,42
1AA4:  BRA    196C
1AA6:  MOVFF  03,38
1AAA:  MOVFF  02,37
1AAE:  MOVFF  01,36
1AB2:  MOVFF  00,35
1AB6:  BTFSS  38.7
1AB8:  BRA    1AD4
1ABA:  DECF   3A,F
1ABC:  BSF    3A.5
1ABE:  COMF   35,F
1AC0:  COMF   36,F
1AC2:  COMF   37,F
1AC4:  COMF   38,F
1AC6:  INCF   35,F
1AC8:  BTFSC  FD8.2
1ACA:  INCF   36,F
1ACC:  BTFSC  FD8.2
1ACE:  INCF   37,F
1AD0:  BTFSC  FD8.2
1AD2:  INCF   38,F
1AD4:  MOVLW  3B
1AD6:  MOVWF  41
1AD8:  MOVLW  9A
1ADA:  MOVWF  40
1ADC:  MOVLW  CA
1ADE:  MOVWF  3F
1AE0:  CLRF   3E
1AE2:  MOVLW  0A
1AE4:  MOVWF  3C
1AE6:  MOVF   39,W
1AE8:  BTFSC  FD8.2
1AEA:  INCF   3A,F
1AEC:  BSF    FD8.1
1AEE:  CLRF   FEA
1AF0:  MOVLW  35
1AF2:  MOVWF  FE9
1AF4:  MOVFF  38,45
1AF8:  MOVFF  37,44
1AFC:  MOVFF  36,43
1B00:  MOVFF  35,42
1B04:  MOVFF  41,49
1B08:  MOVFF  40,48
1B0C:  MOVFF  3F,47
1B10:  MOVFF  3E,46
1B14:  RCALL  19AC
1B16:  MOVF   01,W
1B18:  MOVF   00,F
1B1A:  BNZ   1B3A
1B1C:  INCF   39,W
1B1E:  SUBWF  3C,W
1B20:  BZ    1B3A
1B22:  MOVF   3A,W
1B24:  BZ    1B3E
1B26:  ANDLW  0F
1B28:  SUBWF  3C,W
1B2A:  BZ    1B2E
1B2C:  BC    1B9C
1B2E:  BTFSC  3A.7
1B30:  BRA    1B9C
1B32:  BTFSC  3A.6
1B34:  BRA    1B3E
1B36:  MOVLW  20
1B38:  BRA    1B94
1B3A:  MOVLW  20
1B3C:  ANDWF  3A,F
1B3E:  BTFSS  3A.5
1B40:  BRA    1B5A
1B42:  BCF    3A.5
1B44:  MOVF   39,W
1B46:  BTFSS  FD8.2
1B48:  DECF   3A,F
1B4A:  MOVF   00,W
1B4C:  MOVWF  3A
1B4E:  MOVLW  2D
1B50:  MOVWF  42
1B52:  RCALL  1A3A
1B54:  MOVF   3A,W
1B56:  MOVWF  00
1B58:  CLRF   3A
1B5A:  MOVF   39,W
1B5C:  SUBWF  3C,W
1B5E:  BNZ   1B74
1B60:  MOVF   00,W
1B62:  MOVWF  3A
1B64:  MOVLW  2E
1B66:  MOVWF  42
1B68:  RCALL  1A3A
1B6A:  MOVF   3A,W
1B6C:  MOVWF  00
1B6E:  MOVLW  20
1B70:  ANDWF  3A,F
1B72:  MOVLW  00
1B74:  MOVLW  30
1B76:  BTFSS  3A.5
1B78:  BRA    1B94
1B7A:  BCF    3A.5
1B7C:  MOVF   39,W
1B7E:  BTFSS  FD8.2
1B80:  DECF   3A,F
1B82:  MOVF   00,W
1B84:  MOVWF  3A
1B86:  MOVLW  2D
1B88:  MOVWF  42
1B8A:  RCALL  1A3A
1B8C:  MOVF   3A,W
1B8E:  MOVWF  00
1B90:  CLRF   3A
1B92:  MOVLW  30
1B94:  ADDWF  00,F
1B96:  MOVFF  00,42
1B9A:  RCALL  1A3A
1B9C:  BCF    FD8.1
1B9E:  MOVFF  41,45
1BA2:  MOVFF  40,44
1BA6:  MOVFF  3F,43
1BAA:  MOVFF  3E,42
1BAE:  CLRF   49
1BB0:  CLRF   48
1BB2:  CLRF   47
1BB4:  MOVLW  0A
1BB6:  MOVWF  46
1BB8:  RCALL  19AC
1BBA:  MOVFF  03,41
1BBE:  MOVFF  02,40
1BC2:  MOVFF  01,3F
1BC6:  MOVFF  00,3E
1BCA:  DECFSZ 3C,F
1BCC:  BRA    1AEC
1BCE:  GOTO   1CAA (RETURN)
....................  
.................... #list 
....................  
.................... #DEVICE ADC =10  // seleciona o conversor a/d com 10 bits 
.................... #INCLUDE <stdlib.h>   
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <math.h> //  Inclui a biblioteca responsavel por fornecer funções de calculos matematicos  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
09B2:  BCF    x60.0
....................    y = x; 
09B4:  MOVFF  54,59
09B8:  MOVFF  53,58
09BC:  MOVFF  52,57
09C0:  MOVFF  51,56
....................  
....................    if (x < 0) 
09C4:  MOVFF  54,64
09C8:  MOVFF  53,63
09CC:  MOVFF  52,62
09D0:  MOVFF  51,61
09D4:  CLRF   x68
09D6:  CLRF   x67
09D8:  CLRF   x66
09DA:  CLRF   x65
09DC:  RCALL  057C
09DE:  BNC   09E8
....................    { 
....................       s = 1; 
09E0:  BSF    x60.0
....................       y = -y; 
09E2:  MOVF   57,W
09E4:  XORLW  80
09E6:  MOVWF  57
....................    } 
....................  
....................    if (y <= 32768.0) 
09E8:  MOVFF  59,64
09EC:  MOVFF  58,63
09F0:  MOVFF  57,62
09F4:  MOVFF  56,61
09F8:  CLRF   x68
09FA:  CLRF   x67
09FC:  CLRF   x66
09FE:  MOVLW  8E
0A00:  MOVWF  x65
0A02:  RCALL  057C
0A04:  BC    0A08
0A06:  BNZ   0A38
....................       res = (float32)(unsigned int16)y; 
0A08:  MOVFF  59,64
0A0C:  MOVFF  58,63
0A10:  MOVFF  57,62
0A14:  MOVFF  56,61
0A18:  RCALL  097A
0A1A:  MOVFF  02,66
0A1E:  MOVFF  01,65
0A22:  CALL   0090
0A26:  MOVFF  03,5D
0A2A:  MOVFF  02,5C
0A2E:  MOVFF  01,5B
0A32:  MOVFF  00,5A
0A36:  BRA    0BC2
....................  
....................  else if (y < 10000000.0) 
0A38:  MOVFF  59,64
0A3C:  MOVFF  58,63
0A40:  MOVFF  57,62
0A44:  MOVFF  56,61
0A48:  MOVLW  80
0A4A:  MOVWF  x68
0A4C:  MOVLW  96
0A4E:  MOVWF  x67
0A50:  MOVLW  18
0A52:  MOVWF  x66
0A54:  MOVLW  96
0A56:  MOVWF  x65
0A58:  RCALL  057C
0A5A:  BTFSS  FD8.0
0A5C:  BRA    0BB2
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
0A5E:  MOVFF  59,64
0A62:  MOVFF  58,63
0A66:  MOVFF  57,62
0A6A:  MOVFF  56,61
0A6E:  CLRF   x68
0A70:  CLRF   x67
0A72:  CLRF   x66
0A74:  MOVLW  70
0A76:  MOVWF  x65
0A78:  CALL   00C6
0A7C:  MOVFF  03,64
0A80:  MOVFF  02,63
0A84:  MOVFF  01,62
0A88:  MOVFF  00,61
0A8C:  RCALL  097A
0A8E:  MOVFF  02,5F
0A92:  MOVFF  01,5E
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
0A96:  MOVFF  59,64
0A9A:  MOVFF  58,63
0A9E:  MOVFF  57,62
0AA2:  MOVFF  56,61
0AA6:  CLRF   x68
0AA8:  CLRF   x67
0AAA:  CLRF   x66
0AAC:  MOVLW  70
0AAE:  MOVWF  x65
0AB0:  CALL   00C6
0AB4:  MOVFF  03,64
0AB8:  MOVFF  02,63
0ABC:  MOVFF  01,62
0AC0:  MOVFF  00,61
0AC4:  MOVFF  5F,66
0AC8:  MOVFF  5E,65
0ACC:  CALL   0090
0AD0:  BSF    FD8.1
0AD2:  MOVFF  64,68
0AD6:  MOVFF  63,67
0ADA:  MOVFF  62,66
0ADE:  MOVFF  61,65
0AE2:  MOVFF  03,6C
0AE6:  MOVFF  02,6B
0AEA:  MOVFF  01,6A
0AEE:  MOVFF  00,69
0AF2:  RCALL  0312
0AF4:  CLRF   x64
0AF6:  CLRF   x63
0AF8:  CLRF   x62
0AFA:  MOVLW  8E
0AFC:  MOVWF  x61
0AFE:  MOVFF  03,68
0B02:  MOVFF  02,67
0B06:  MOVFF  01,66
0B0A:  MOVFF  00,65
0B0E:  CALL   00C6
0B12:  MOVFF  03,59
0B16:  MOVFF  02,58
0B1A:  MOVFF  01,57
0B1E:  MOVFF  00,56
....................       res = 32768.0*(float32)l; 
0B22:  MOVFF  5F,66
0B26:  MOVFF  5E,65
0B2A:  CALL   0090
0B2E:  CLRF   x64
0B30:  CLRF   x63
0B32:  CLRF   x62
0B34:  MOVLW  8E
0B36:  MOVWF  x61
0B38:  MOVFF  03,68
0B3C:  MOVFF  02,67
0B40:  MOVFF  01,66
0B44:  MOVFF  00,65
0B48:  CALL   00C6
0B4C:  MOVFF  03,5D
0B50:  MOVFF  02,5C
0B54:  MOVFF  01,5B
0B58:  MOVFF  00,5A
....................       res += (float32)(unsigned int16)y; 
0B5C:  MOVFF  59,64
0B60:  MOVFF  58,63
0B64:  MOVFF  57,62
0B68:  MOVFF  56,61
0B6C:  RCALL  097A
0B6E:  MOVFF  02,66
0B72:  MOVFF  01,65
0B76:  CALL   0090
0B7A:  BCF    FD8.1
0B7C:  MOVFF  5D,68
0B80:  MOVFF  5C,67
0B84:  MOVFF  5B,66
0B88:  MOVFF  5A,65
0B8C:  MOVFF  03,6C
0B90:  MOVFF  02,6B
0B94:  MOVFF  01,6A
0B98:  MOVFF  00,69
0B9C:  CALL   0312
0BA0:  MOVFF  03,5D
0BA4:  MOVFF  02,5C
0BA8:  MOVFF  01,5B
0BAC:  MOVFF  00,5A
....................    } 
0BB0:  BRA    0BC2
....................  
....................  else 
....................   res = y; 
0BB2:  MOVFF  59,5D
0BB6:  MOVFF  58,5C
0BBA:  MOVFF  57,5B
0BBE:  MOVFF  56,5A
....................  
....................  y = y - (float32)(unsigned int16)y; 
0BC2:  MOVFF  59,64
0BC6:  MOVFF  58,63
0BCA:  MOVFF  57,62
0BCE:  MOVFF  56,61
0BD2:  RCALL  097A
0BD4:  MOVFF  02,66
0BD8:  MOVFF  01,65
0BDC:  CALL   0090
0BE0:  BSF    FD8.1
0BE2:  MOVFF  59,68
0BE6:  MOVFF  58,67
0BEA:  MOVFF  57,66
0BEE:  MOVFF  56,65
0BF2:  MOVFF  03,6C
0BF6:  MOVFF  02,6B
0BFA:  MOVFF  01,6A
0BFE:  MOVFF  00,69
0C02:  CALL   0312
0C06:  MOVFF  03,59
0C0A:  MOVFF  02,58
0C0E:  MOVFF  01,57
0C12:  MOVFF  00,56
....................  
....................  if (s) 
0C16:  BTFSS  x60.0
0C18:  BRA    0C20
....................   res = -res; 
0C1A:  MOVF   5B,W
0C1C:  XORLW  80
0C1E:  MOVWF  5B
....................  
....................  if (y != 0) 
0C20:  MOVFF  59,64
0C24:  MOVFF  58,63
0C28:  MOVFF  57,62
0C2C:  MOVFF  56,61
0C30:  CLRF   x68
0C32:  CLRF   x67
0C34:  CLRF   x66
0C36:  CLRF   x65
0C38:  RCALL  057C
0C3A:  BZ    0CAC
....................  { 
....................   if (s == 1 && n == 0) 
0C3C:  BTFSS  x60.0
0C3E:  BRA    0C74
0C40:  MOVF   55,F
0C42:  BNZ   0C74
....................    res -= 1.0; 
0C44:  BSF    FD8.1
0C46:  MOVFF  5D,68
0C4A:  MOVFF  5C,67
0C4E:  MOVFF  5B,66
0C52:  MOVFF  5A,65
0C56:  CLRF   x6C
0C58:  CLRF   x6B
0C5A:  CLRF   x6A
0C5C:  MOVLW  7F
0C5E:  MOVWF  x69
0C60:  CALL   0312
0C64:  MOVFF  03,5D
0C68:  MOVFF  02,5C
0C6C:  MOVFF  01,5B
0C70:  MOVFF  00,5A
....................  
....................   if (s == 0 && n == 1) 
0C74:  BTFSC  x60.0
0C76:  BRA    0CAC
0C78:  DECFSZ 55,W
0C7A:  BRA    0CAC
....................    res += 1.0; 
0C7C:  BCF    FD8.1
0C7E:  MOVFF  5D,68
0C82:  MOVFF  5C,67
0C86:  MOVFF  5B,66
0C8A:  MOVFF  5A,65
0C8E:  CLRF   x6C
0C90:  CLRF   x6B
0C92:  CLRF   x6A
0C94:  MOVLW  7F
0C96:  MOVWF  x69
0C98:  CALL   0312
0C9C:  MOVFF  03,5D
0CA0:  MOVFF  02,5C
0CA4:  MOVFF  01,5B
0CA8:  MOVFF  00,5A
....................  } 
....................  if (x == 0) 
0CAC:  MOVFF  54,64
0CB0:  MOVFF  53,63
0CB4:  MOVFF  52,62
0CB8:  MOVFF  51,61
0CBC:  CLRF   x68
0CBE:  CLRF   x67
0CC0:  CLRF   x66
0CC2:  CLRF   x65
0CC4:  RCALL  057C
0CC6:  BNZ   0CD0
....................     res = 0; 
0CC8:  CLRF   5D
0CCA:  CLRF   5C
0CCC:  CLRF   5B
0CCE:  CLRF   5A
....................  
....................  return (res); 
0CD0:  MOVFF  5A,00
0CD4:  MOVFF  5B,01
0CD8:  MOVFF  5C,02
0CDC:  MOVFF  5D,03
0CE0:  RETURN 0
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
*
0CFC:  MOVFF  50,54
0D00:  MOVFF  4F,53
0D04:  MOVFF  4E,52
0D08:  MOVFF  4D,51
0D0C:  CLRF   55
0D0E:  RCALL  09B2
0D10:  GOTO   0E12 (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
0CE2:  MOVFF  50,54
0CE6:  MOVFF  4F,53
0CEA:  MOVFF  4E,52
0CEE:  MOVFF  4D,51
0CF2:  MOVLW  01
0CF4:  MOVWF  55
0CF6:  RCALL  09B2
0CF8:  GOTO   0DCA (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
*
0D14:  MOVFF  44,64
0D18:  MOVFF  43,63
0D1C:  MOVFF  42,62
0D20:  MOVFF  41,61
0D24:  CLRF   x68
0D26:  CLRF   x67
0D28:  CLRF   x66
0D2A:  CLRF   x65
0D2C:  RCALL  057C
0D2E:  BTFSC  FD8.2
0D30:  BRA    0E6E
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
0D32:  MOVFF  40,5D
0D36:  MOVFF  3F,5C
0D3A:  MOVFF  3E,5B
0D3E:  MOVFF  3D,5A
0D42:  MOVFF  44,61
0D46:  MOVFF  43,60
0D4A:  MOVFF  42,5F
0D4E:  MOVFF  41,5E
0D52:  CALL   01B8
0D56:  MOVFF  03,4C
0D5A:  MOVFF  02,4B
0D5E:  MOVFF  01,4A
0D62:  MOVFF  00,49
0D66:  MOVFF  03,64
0D6A:  MOVFF  02,63
0D6E:  MOVFF  01,62
0D72:  MOVFF  00,61
0D76:  CLRF   x68
0D78:  CLRF   x67
0D7A:  CLRF   x66
0D7C:  CLRF   x65
0D7E:  CALL   057C
0D82:  BNC   0DCC
0D84:  MOVFF  40,5D
0D88:  MOVFF  3F,5C
0D8C:  MOVFF  3E,5B
0D90:  MOVFF  3D,5A
0D94:  MOVFF  44,61
0D98:  MOVFF  43,60
0D9C:  MOVFF  42,5F
0DA0:  MOVFF  41,5E
0DA4:  CALL   01B8
0DA8:  MOVFF  03,4C
0DAC:  MOVFF  02,4B
0DB0:  MOVFF  01,4A
0DB4:  MOVFF  00,49
0DB8:  MOVFF  03,50
0DBC:  MOVFF  02,4F
0DC0:  MOVFF  01,4E
0DC4:  MOVFF  00,4D
0DC8:  BRA    0CE2
0DCA:  BRA    0E12
0DCC:  MOVFF  40,5D
0DD0:  MOVFF  3F,5C
0DD4:  MOVFF  3E,5B
0DD8:  MOVFF  3D,5A
0DDC:  MOVFF  44,61
0DE0:  MOVFF  43,60
0DE4:  MOVFF  42,5F
0DE8:  MOVFF  41,5E
0DEC:  CALL   01B8
0DF0:  MOVFF  03,4C
0DF4:  MOVFF  02,4B
0DF8:  MOVFF  01,4A
0DFC:  MOVFF  00,49
0E00:  MOVFF  03,50
0E04:  MOVFF  02,4F
0E08:  MOVFF  01,4E
0E0C:  MOVFF  00,4D
0E10:  BRA    0CFC
0E12:  MOVFF  03,48
0E16:  MOVFF  02,47
0E1A:  MOVFF  01,46
0E1E:  MOVFF  00,45
....................       return(x-(i*y)); 
0E22:  MOVFF  48,64
0E26:  MOVFF  47,63
0E2A:  MOVFF  46,62
0E2E:  MOVFF  45,61
0E32:  MOVFF  44,68
0E36:  MOVFF  43,67
0E3A:  MOVFF  42,66
0E3E:  MOVFF  41,65
0E42:  CALL   00C6
0E46:  BSF    FD8.1
0E48:  MOVFF  40,68
0E4C:  MOVFF  3F,67
0E50:  MOVFF  3E,66
0E54:  MOVFF  3D,65
0E58:  MOVFF  03,6C
0E5C:  MOVFF  02,6B
0E60:  MOVFF  01,6A
0E64:  MOVFF  00,69
0E68:  CALL   0312
0E6C:  BRA    0E6E
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
0E6E:  RETURN 0
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
0E70:  MOVFF  44,64
0E74:  MOVFF  43,63
0E78:  MOVFF  42,62
0E7C:  MOVFF  41,61
0E80:  MOVLW  3B
0E82:  MOVWF  x68
0E84:  MOVLW  AA
0E86:  MOVWF  x67
0E88:  MOVLW  38
0E8A:  MOVWF  x66
0E8C:  MOVLW  7F
0E8E:  MOVWF  x65
0E90:  CALL   00C6
0E94:  MOVFF  03,64
0E98:  MOVFF  02,63
0E9C:  MOVFF  01,62
0EA0:  MOVFF  00,61
0EA4:  RCALL  097A
0EA6:  MOVFF  01,51
....................    s = 0; 
0EAA:  BCF    52.0
....................    y = x; 
0EAC:  MOVFF  44,48
0EB0:  MOVFF  43,47
0EB4:  MOVFF  42,46
0EB8:  MOVFF  41,45
....................  
....................    if (x < 0) 
0EBC:  MOVFF  44,64
0EC0:  MOVFF  43,63
0EC4:  MOVFF  42,62
0EC8:  MOVFF  41,61
0ECC:  CLRF   x68
0ECE:  CLRF   x67
0ED0:  CLRF   x66
0ED2:  CLRF   x65
0ED4:  CALL   057C
0ED8:  BNC   0EE4
....................    { 
....................       s = 1; 
0EDA:  BSF    52.0
....................       n = -n; 
0EDC:  NEGF   51
....................       y = -y; 
0EDE:  MOVF   46,W
0EE0:  XORLW  80
0EE2:  MOVWF  46
....................    } 
....................  
....................    res = 0.0; 
0EE4:  CLRF   4C
0EE6:  CLRF   4B
0EE8:  CLRF   4A
0EEA:  CLRF   49
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
0EEC:  CLRF   54
0EEE:  MOVLW  49
0EF0:  MOVWF  FE9
0EF2:  MOVFF  54,FEA
0EF6:  MOVLW  7F
0EF8:  ADDWF  51,W
0EFA:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
0EFC:  MOVFF  48,64
0F00:  MOVFF  47,63
0F04:  MOVFF  46,62
0F08:  MOVFF  45,61
0F0C:  MOVLW  3B
0F0E:  MOVWF  x68
0F10:  MOVLW  AA
0F12:  MOVWF  x67
0F14:  MOVLW  38
0F16:  MOVWF  x66
0F18:  MOVLW  7F
0F1A:  MOVWF  x65
0F1C:  CALL   00C6
0F20:  MOVFF  03,56
0F24:  MOVFF  02,55
0F28:  MOVFF  01,54
0F2C:  MOVFF  00,53
0F30:  CLRF   58
0F32:  MOVFF  51,57
0F36:  BTFSC  57.7
0F38:  DECF   58,F
0F3A:  CALL   05F2
0F3E:  BSF    FD8.1
0F40:  MOVFF  56,68
0F44:  MOVFF  55,67
0F48:  MOVFF  54,66
0F4C:  MOVFF  53,65
0F50:  MOVFF  03,6C
0F54:  MOVFF  02,6B
0F58:  MOVFF  01,6A
0F5C:  MOVFF  00,69
0F60:  CALL   0312
0F64:  MOVFF  03,48
0F68:  MOVFF  02,47
0F6C:  MOVFF  01,46
0F70:  MOVFF  00,45
....................  
....................    r = pe[0]*y + pe[1]; 
0F74:  MOVLW  7C
0F76:  MOVWF  x64
0F78:  MOVLW  88
0F7A:  MOVWF  x63
0F7C:  MOVLW  59
0F7E:  MOVWF  x62
0F80:  MOVLW  72
0F82:  MOVWF  x61
0F84:  MOVFF  48,68
0F88:  MOVFF  47,67
0F8C:  MOVFF  46,66
0F90:  MOVFF  45,65
0F94:  CALL   00C6
0F98:  MOVFF  03,56
0F9C:  MOVFF  02,55
0FA0:  MOVFF  01,54
0FA4:  MOVFF  00,53
0FA8:  BCF    FD8.1
0FAA:  MOVFF  03,68
0FAE:  MOVFF  02,67
0FB2:  MOVFF  01,66
0FB6:  MOVFF  00,65
0FBA:  MOVLW  E0
0FBC:  MOVWF  x6C
0FBE:  MOVLW  97
0FC0:  MOVWF  x6B
0FC2:  MOVLW  26
0FC4:  MOVWF  x6A
0FC6:  MOVLW  75
0FC8:  MOVWF  x69
0FCA:  CALL   0312
0FCE:  MOVFF  03,50
0FD2:  MOVFF  02,4F
0FD6:  MOVFF  01,4E
0FDA:  MOVFF  00,4D
....................    r = r*y + pe[2]; 
0FDE:  MOVFF  50,64
0FE2:  MOVFF  4F,63
0FE6:  MOVFF  4E,62
0FEA:  MOVFF  4D,61
0FEE:  MOVFF  48,68
0FF2:  MOVFF  47,67
0FF6:  MOVFF  46,66
0FFA:  MOVFF  45,65
0FFE:  CALL   00C6
1002:  MOVFF  03,56
1006:  MOVFF  02,55
100A:  MOVFF  01,54
100E:  MOVFF  00,53
1012:  BCF    FD8.1
1014:  MOVFF  03,68
1018:  MOVFF  02,67
101C:  MOVFF  01,66
1020:  MOVFF  00,65
1024:  MOVLW  C4
1026:  MOVWF  x6C
1028:  MOVLW  1D
102A:  MOVWF  x6B
102C:  MOVLW  1E
102E:  MOVWF  x6A
1030:  MOVLW  78
1032:  MOVWF  x69
1034:  CALL   0312
1038:  MOVFF  03,50
103C:  MOVFF  02,4F
1040:  MOVFF  01,4E
1044:  MOVFF  00,4D
....................    r = r*y + pe[3]; 
1048:  MOVFF  50,64
104C:  MOVFF  4F,63
1050:  MOVFF  4E,62
1054:  MOVFF  4D,61
1058:  MOVFF  48,68
105C:  MOVFF  47,67
1060:  MOVFF  46,66
1064:  MOVFF  45,65
1068:  CALL   00C6
106C:  MOVFF  03,56
1070:  MOVFF  02,55
1074:  MOVFF  01,54
1078:  MOVFF  00,53
107C:  BCF    FD8.1
107E:  MOVFF  03,68
1082:  MOVFF  02,67
1086:  MOVFF  01,66
108A:  MOVFF  00,65
108E:  MOVLW  5E
1090:  MOVWF  x6C
1092:  MOVLW  50
1094:  MOVWF  x6B
1096:  MOVLW  63
1098:  MOVWF  x6A
109A:  MOVLW  7A
109C:  MOVWF  x69
109E:  CALL   0312
10A2:  MOVFF  03,50
10A6:  MOVFF  02,4F
10AA:  MOVFF  01,4E
10AE:  MOVFF  00,4D
....................    r = r*y + pe[4]; 
10B2:  MOVFF  50,64
10B6:  MOVFF  4F,63
10BA:  MOVFF  4E,62
10BE:  MOVFF  4D,61
10C2:  MOVFF  48,68
10C6:  MOVFF  47,67
10CA:  MOVFF  46,66
10CE:  MOVFF  45,65
10D2:  CALL   00C6
10D6:  MOVFF  03,56
10DA:  MOVFF  02,55
10DE:  MOVFF  01,54
10E2:  MOVFF  00,53
10E6:  BCF    FD8.1
10E8:  MOVFF  03,68
10EC:  MOVFF  02,67
10F0:  MOVFF  01,66
10F4:  MOVFF  00,65
10F8:  MOVLW  1A
10FA:  MOVWF  x6C
10FC:  MOVLW  FE
10FE:  MOVWF  x6B
1100:  MOVLW  75
1102:  MOVWF  x6A
1104:  MOVLW  7C
1106:  MOVWF  x69
1108:  CALL   0312
110C:  MOVFF  03,50
1110:  MOVFF  02,4F
1114:  MOVFF  01,4E
1118:  MOVFF  00,4D
....................    r = r*y + pe[5]; 
111C:  MOVFF  50,64
1120:  MOVFF  4F,63
1124:  MOVFF  4E,62
1128:  MOVFF  4D,61
112C:  MOVFF  48,68
1130:  MOVFF  47,67
1134:  MOVFF  46,66
1138:  MOVFF  45,65
113C:  CALL   00C6
1140:  MOVFF  03,56
1144:  MOVFF  02,55
1148:  MOVFF  01,54
114C:  MOVFF  00,53
1150:  BCF    FD8.1
1152:  MOVFF  03,68
1156:  MOVFF  02,67
115A:  MOVFF  01,66
115E:  MOVFF  00,65
1162:  MOVLW  18
1164:  MOVWF  x6C
1166:  MOVLW  72
1168:  MOVWF  x6B
116A:  MOVLW  31
116C:  MOVWF  x6A
116E:  MOVLW  7E
1170:  MOVWF  x69
1172:  CALL   0312
1176:  MOVFF  03,50
117A:  MOVFF  02,4F
117E:  MOVFF  01,4E
1182:  MOVFF  00,4D
....................  
....................    res = res*(1.0 + y*r); 
1186:  MOVFF  48,64
118A:  MOVFF  47,63
118E:  MOVFF  46,62
1192:  MOVFF  45,61
1196:  MOVFF  50,68
119A:  MOVFF  4F,67
119E:  MOVFF  4E,66
11A2:  MOVFF  4D,65
11A6:  CALL   00C6
11AA:  BCF    FD8.1
11AC:  CLRF   x68
11AE:  CLRF   x67
11B0:  CLRF   x66
11B2:  MOVLW  7F
11B4:  MOVWF  x65
11B6:  MOVFF  03,6C
11BA:  MOVFF  02,6B
11BE:  MOVFF  01,6A
11C2:  MOVFF  00,69
11C6:  CALL   0312
11CA:  MOVFF  4C,64
11CE:  MOVFF  4B,63
11D2:  MOVFF  4A,62
11D6:  MOVFF  49,61
11DA:  MOVFF  03,68
11DE:  MOVFF  02,67
11E2:  MOVFF  01,66
11E6:  MOVFF  00,65
11EA:  CALL   00C6
11EE:  MOVFF  03,4C
11F2:  MOVFF  02,4B
11F6:  MOVFF  01,4A
11FA:  MOVFF  00,49
....................  
....................    if (s) 
11FE:  BTFSS  52.0
1200:  BRA    1230
....................       res = 1.0/res; 
1202:  CLRF   5D
1204:  CLRF   5C
1206:  CLRF   5B
1208:  MOVLW  7F
120A:  MOVWF  5A
120C:  MOVFF  4C,61
1210:  MOVFF  4B,60
1214:  MOVFF  4A,5F
1218:  MOVFF  49,5E
121C:  CALL   01B8
1220:  MOVFF  03,4C
1224:  MOVFF  02,4B
1228:  MOVFF  01,4A
122C:  MOVFF  00,49
....................    return(res); 
1230:  MOVFF  49,00
1234:  MOVFF  4A,01
1238:  MOVFF  4B,02
123C:  MOVFF  4C,03
1240:  RETURN 0
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
*
063A:  MOVFF  44,48
063E:  MOVFF  43,47
0642:  MOVFF  42,46
0646:  MOVFF  41,45
....................  
....................    if (y != 1.0) 
064A:  MOVFF  48,64
064E:  MOVFF  47,63
0652:  MOVFF  46,62
0656:  MOVFF  45,61
065A:  CLRF   x68
065C:  CLRF   x67
065E:  CLRF   x66
0660:  MOVLW  7F
0662:  MOVWF  x65
0664:  RCALL  057C
0666:  BTFSC  FD8.2
0668:  BRA    0960
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
066A:  CLRF   57
066C:  MOVLW  45
066E:  MOVWF  FE9
0670:  MOVFF  57,FEA
0674:  MOVLW  7E
0676:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
0678:  BSF    FD8.1
067A:  MOVFF  48,68
067E:  MOVFF  47,67
0682:  MOVFF  46,66
0686:  MOVFF  45,65
068A:  CLRF   x6C
068C:  CLRF   x6B
068E:  CLRF   x6A
0690:  MOVLW  7F
0692:  MOVWF  x69
0694:  RCALL  0312
0696:  MOVFF  03,59
069A:  MOVFF  02,58
069E:  MOVFF  01,57
06A2:  MOVFF  00,56
06A6:  BCF    FD8.1
06A8:  MOVFF  48,68
06AC:  MOVFF  47,67
06B0:  MOVFF  46,66
06B4:  MOVFF  45,65
06B8:  CLRF   x6C
06BA:  CLRF   x6B
06BC:  CLRF   x6A
06BE:  MOVLW  7F
06C0:  MOVWF  x69
06C2:  RCALL  0312
06C4:  MOVFF  59,5D
06C8:  MOVFF  58,5C
06CC:  MOVFF  57,5B
06D0:  MOVFF  56,5A
06D4:  MOVFF  03,61
06D8:  MOVFF  02,60
06DC:  MOVFF  01,5F
06E0:  MOVFF  00,5E
06E4:  RCALL  01B8
06E6:  MOVFF  03,48
06EA:  MOVFF  02,47
06EE:  MOVFF  01,46
06F2:  MOVFF  00,45
....................  
....................       y2=y*y; 
06F6:  MOVFF  48,64
06FA:  MOVFF  47,63
06FE:  MOVFF  46,62
0702:  MOVFF  45,61
0706:  MOVFF  48,68
070A:  MOVFF  47,67
070E:  MOVFF  46,66
0712:  MOVFF  45,65
0716:  RCALL  00C6
0718:  MOVFF  03,54
071C:  MOVFF  02,53
0720:  MOVFF  01,52
0724:  MOVFF  00,51
....................  
....................       res = pl[0]*y2 + pl[1]; 
0728:  MOVLW  99
072A:  MOVWF  x64
072C:  MOVLW  47
072E:  MOVWF  x63
0730:  MOVLW  8A
0732:  MOVWF  x62
0734:  MOVLW  7F
0736:  MOVWF  x61
0738:  MOVFF  54,68
073C:  MOVFF  53,67
0740:  MOVFF  52,66
0744:  MOVFF  51,65
0748:  RCALL  00C6
074A:  MOVFF  03,59
074E:  MOVFF  02,58
0752:  MOVFF  01,57
0756:  MOVFF  00,56
075A:  BCF    FD8.1
075C:  MOVFF  03,68
0760:  MOVFF  02,67
0764:  MOVFF  01,66
0768:  MOVFF  00,65
076C:  CLRF   x6C
076E:  CLRF   x6B
0770:  CLRF   x6A
0772:  MOVLW  80
0774:  MOVWF  x69
0776:  RCALL  0312
0778:  MOVFF  03,4C
077C:  MOVFF  02,4B
0780:  MOVFF  01,4A
0784:  MOVFF  00,49
....................  
....................       r = ql[0]*y2 + ql[1]; 
0788:  MOVLW  4C
078A:  MOVWF  x64
078C:  MOVLW  F3
078E:  MOVWF  x63
0790:  MOVLW  3A
0792:  MOVWF  x62
0794:  MOVLW  7B
0796:  MOVWF  x61
0798:  MOVFF  54,68
079C:  MOVFF  53,67
07A0:  MOVFF  52,66
07A4:  MOVFF  51,65
07A8:  RCALL  00C6
07AA:  MOVFF  03,59
07AE:  MOVFF  02,58
07B2:  MOVFF  01,57
07B6:  MOVFF  00,56
07BA:  BCF    FD8.1
07BC:  MOVFF  03,68
07C0:  MOVFF  02,67
07C4:  MOVFF  01,66
07C8:  MOVFF  00,65
07CC:  MOVLW  2B
07CE:  MOVWF  x6C
07D0:  MOVLW  9D
07D2:  MOVWF  x6B
07D4:  MOVLW  DF
07D6:  MOVWF  x6A
07D8:  MOVLW  7E
07DA:  MOVWF  x69
07DC:  RCALL  0312
07DE:  MOVFF  03,50
07E2:  MOVFF  02,4F
07E6:  MOVFF  01,4E
07EA:  MOVFF  00,4D
....................       r = r*y2 + 1.0; 
07EE:  MOVFF  50,64
07F2:  MOVFF  4F,63
07F6:  MOVFF  4E,62
07FA:  MOVFF  4D,61
07FE:  MOVFF  54,68
0802:  MOVFF  53,67
0806:  MOVFF  52,66
080A:  MOVFF  51,65
080E:  RCALL  00C6
0810:  MOVFF  03,59
0814:  MOVFF  02,58
0818:  MOVFF  01,57
081C:  MOVFF  00,56
0820:  BCF    FD8.1
0822:  MOVFF  03,68
0826:  MOVFF  02,67
082A:  MOVFF  01,66
082E:  MOVFF  00,65
0832:  CLRF   x6C
0834:  CLRF   x6B
0836:  CLRF   x6A
0838:  MOVLW  7F
083A:  MOVWF  x69
083C:  RCALL  0312
083E:  MOVFF  03,50
0842:  MOVFF  02,4F
0846:  MOVFF  01,4E
084A:  MOVFF  00,4D
....................  
....................       res = y*res/r; 
084E:  MOVFF  48,64
0852:  MOVFF  47,63
0856:  MOVFF  46,62
085A:  MOVFF  45,61
085E:  MOVFF  4C,68
0862:  MOVFF  4B,67
0866:  MOVFF  4A,66
086A:  MOVFF  49,65
086E:  RCALL  00C6
0870:  MOVFF  03,59
0874:  MOVFF  02,58
0878:  MOVFF  01,57
087C:  MOVFF  00,56
0880:  MOVFF  03,5D
0884:  MOVFF  02,5C
0888:  MOVFF  01,5B
088C:  MOVFF  00,5A
0890:  MOVFF  50,61
0894:  MOVFF  4F,60
0898:  MOVFF  4E,5F
089C:  MOVFF  4D,5E
08A0:  RCALL  01B8
08A2:  MOVFF  03,4C
08A6:  MOVFF  02,4B
08AA:  MOVFF  01,4A
08AE:  MOVFF  00,49
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
08B2:  CLRF   57
08B4:  MOVLW  41
08B6:  MOVWF  FE9
08B8:  MOVFF  57,FEA
08BC:  MOVLW  7E
08BE:  SUBWF  FEF,W
08C0:  MOVWF  55
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
08C2:  BTFSS  55.7
08C4:  BRA    08EA
....................          r = -(float32)-n; 
08C6:  MOVLW  00
08C8:  BSF    FD8.0
08CA:  SUBFWB 55,W
08CC:  CLRF   58
08CE:  MOVWF  57
08D0:  BTFSC  57.7
08D2:  DECF   58,F
08D4:  RCALL  05F2
08D6:  MOVFF  00,4D
08DA:  MOVF   01,W
08DC:  XORLW  80
08DE:  MOVWF  4E
08E0:  MOVFF  02,4F
08E4:  MOVFF  03,50
08E8:  BRA    0906
....................       else 
....................          r = (float32)n; 
08EA:  CLRF   58
08EC:  MOVFF  55,57
08F0:  BTFSC  57.7
08F2:  DECF   58,F
08F4:  RCALL  05F2
08F6:  MOVFF  03,50
08FA:  MOVFF  02,4F
08FE:  MOVFF  01,4E
0902:  MOVFF  00,4D
....................  
....................       res += r*LN2; 
0906:  MOVFF  50,64
090A:  MOVFF  4F,63
090E:  MOVFF  4E,62
0912:  MOVFF  4D,61
0916:  MOVLW  18
0918:  MOVWF  x68
091A:  MOVLW  72
091C:  MOVWF  x67
091E:  MOVLW  31
0920:  MOVWF  x66
0922:  MOVLW  7E
0924:  MOVWF  x65
0926:  CALL   00C6
092A:  BCF    FD8.1
092C:  MOVFF  4C,68
0930:  MOVFF  4B,67
0934:  MOVFF  4A,66
0938:  MOVFF  49,65
093C:  MOVFF  03,6C
0940:  MOVFF  02,6B
0944:  MOVFF  01,6A
0948:  MOVFF  00,69
094C:  RCALL  0312
094E:  MOVFF  03,4C
0952:  MOVFF  02,4B
0956:  MOVFF  01,4A
095A:  MOVFF  00,49
....................    } 
095E:  BRA    0968
....................  
....................    else 
....................       res = 0.0; 
0960:  CLRF   4C
0962:  CLRF   4B
0964:  CLRF   4A
0966:  CLRF   49
....................  
....................    return(res); 
0968:  MOVFF  49,00
096C:  MOVFF  4A,01
0970:  MOVFF  4B,02
0974:  MOVFF  4C,03
0978:  RETURN 0
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
*
1242:  MOVFF  38,64
1246:  MOVFF  37,63
124A:  MOVFF  36,62
124E:  MOVFF  35,61
1252:  CLRF   x68
1254:  CLRF   x67
1256:  CLRF   x66
1258:  CLRF   x65
125A:  CALL   057C
125E:  BTFSS  FD8.0
1260:  BRA    13F8
1262:  MOVFF  3C,40
1266:  MOVFF  3B,3F
126A:  MOVFF  3A,3E
126E:  MOVFF  39,3D
1272:  CLRF   44
1274:  CLRF   43
1276:  CLRF   42
1278:  MOVLW  7F
127A:  MOVWF  41
127C:  RCALL  0D14
127E:  MOVFF  03,40
1282:  MOVFF  02,3F
1286:  MOVFF  01,3E
128A:  MOVFF  00,3D
128E:  MOVFF  03,64
1292:  MOVFF  02,63
1296:  MOVFF  01,62
129A:  MOVFF  00,61
129E:  CLRF   x68
12A0:  CLRF   x67
12A2:  CLRF   x66
12A4:  CLRF   x65
12A6:  CALL   057C
12AA:  BTFSS  FD8.2
12AC:  BRA    13F8
....................       if(fmod(y, 2) == 0) { 
12AE:  MOVFF  3C,40
12B2:  MOVFF  3B,3F
12B6:  MOVFF  3A,3E
12BA:  MOVFF  39,3D
12BE:  CLRF   44
12C0:  CLRF   43
12C2:  CLRF   42
12C4:  MOVLW  80
12C6:  MOVWF  41
12C8:  RCALL  0D14
12CA:  MOVFF  03,40
12CE:  MOVFF  02,3F
12D2:  MOVFF  01,3E
12D6:  MOVFF  00,3D
12DA:  MOVFF  03,64
12DE:  MOVFF  02,63
12E2:  MOVFF  01,62
12E6:  MOVFF  00,61
12EA:  CLRF   x68
12EC:  CLRF   x67
12EE:  CLRF   x66
12F0:  CLRF   x65
12F2:  CALL   057C
12F6:  BNZ   1376
....................          return (exp(log(-x) * y)); 
12F8:  MOVFF  35,3D
12FC:  MOVF   36,W
12FE:  XORLW  80
1300:  MOVWF  3E
1302:  MOVFF  37,3F
1306:  MOVFF  38,40
130A:  MOVFF  38,44
130E:  MOVFF  37,43
1312:  MOVWF  42
1314:  MOVFF  35,41
1318:  CALL   063A
131C:  MOVFF  03,40
1320:  MOVFF  02,3F
1324:  MOVFF  01,3E
1328:  MOVFF  00,3D
132C:  MOVFF  03,64
1330:  MOVFF  02,63
1334:  MOVFF  01,62
1338:  MOVFF  00,61
133C:  MOVFF  3C,68
1340:  MOVFF  3B,67
1344:  MOVFF  3A,66
1348:  MOVFF  39,65
134C:  CALL   00C6
1350:  MOVFF  03,40
1354:  MOVFF  02,3F
1358:  MOVFF  01,3E
135C:  MOVFF  00,3D
1360:  MOVFF  03,44
1364:  MOVFF  02,43
1368:  MOVFF  01,42
136C:  MOVFF  00,41
1370:  RCALL  0E70
1372:  BRA    1514
....................       } else { 
1374:  BRA    13F6
....................          return (-exp(log(-x) * y)); 
1376:  MOVFF  35,3D
137A:  MOVF   36,W
137C:  XORLW  80
137E:  MOVWF  3E
1380:  MOVFF  37,3F
1384:  MOVFF  38,40
1388:  MOVFF  38,44
138C:  MOVFF  37,43
1390:  MOVWF  42
1392:  MOVFF  35,41
1396:  CALL   063A
139A:  MOVFF  03,40
139E:  MOVFF  02,3F
13A2:  MOVFF  01,3E
13A6:  MOVFF  00,3D
13AA:  MOVFF  03,64
13AE:  MOVFF  02,63
13B2:  MOVFF  01,62
13B6:  MOVFF  00,61
13BA:  MOVFF  3C,68
13BE:  MOVFF  3B,67
13C2:  MOVFF  3A,66
13C6:  MOVFF  39,65
13CA:  CALL   00C6
13CE:  MOVFF  03,40
13D2:  MOVFF  02,3F
13D6:  MOVFF  01,3E
13DA:  MOVFF  00,3D
13DE:  MOVFF  03,44
13E2:  MOVFF  02,43
13E6:  MOVFF  01,42
13EA:  MOVFF  00,41
13EE:  RCALL  0E70
13F0:  MOVLW  80
13F2:  XORWF  01,F
13F4:  BRA    1514
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
13F6:  BRA    1514
13F8:  MOVFF  38,64
13FC:  MOVFF  37,63
1400:  MOVFF  36,62
1404:  MOVFF  35,61
1408:  CLRF   x68
140A:  CLRF   x67
140C:  CLRF   x66
140E:  CLRF   x65
1410:  CALL   057C
1414:  BNC   146C
1416:  MOVFF  3C,40
141A:  MOVFF  3B,3F
141E:  MOVFF  3A,3E
1422:  MOVFF  39,3D
1426:  CLRF   44
1428:  CLRF   43
142A:  CLRF   42
142C:  MOVLW  7F
142E:  MOVWF  41
1430:  RCALL  0D14
1432:  MOVFF  03,40
1436:  MOVFF  02,3F
143A:  MOVFF  01,3E
143E:  MOVFF  00,3D
1442:  MOVFF  03,64
1446:  MOVFF  02,63
144A:  MOVFF  01,62
144E:  MOVFF  00,61
1452:  CLRF   x68
1454:  CLRF   x67
1456:  CLRF   x66
1458:  CLRF   x65
145A:  CALL   057C
145E:  BZ    146C
....................       return 0; 
1460:  CLRF   00
1462:  CLRF   01
1464:  CLRF   02
1466:  CLRF   03
1468:  BRA    1514
....................    } else { 
146A:  BRA    1514
....................       if(x != 0 || 0 >= y) { 
146C:  MOVFF  38,64
1470:  MOVFF  37,63
1474:  MOVFF  36,62
1478:  MOVFF  35,61
147C:  CLRF   x68
147E:  CLRF   x67
1480:  CLRF   x66
1482:  CLRF   x65
1484:  CALL   057C
1488:  BNZ   14AA
148A:  MOVFF  3C,64
148E:  MOVFF  3B,63
1492:  MOVFF  3A,62
1496:  MOVFF  39,61
149A:  CLRF   x68
149C:  CLRF   x67
149E:  CLRF   x66
14A0:  CLRF   x65
14A2:  CALL   057C
14A6:  BC    14AA
14A8:  BNZ   1514
....................          return (exp(log(x) * y)); 
14AA:  MOVFF  38,44
14AE:  MOVFF  37,43
14B2:  MOVFF  36,42
14B6:  MOVFF  35,41
14BA:  CALL   063A
14BE:  MOVFF  03,40
14C2:  MOVFF  02,3F
14C6:  MOVFF  01,3E
14CA:  MOVFF  00,3D
14CE:  MOVFF  03,64
14D2:  MOVFF  02,63
14D6:  MOVFF  01,62
14DA:  MOVFF  00,61
14DE:  MOVFF  3C,68
14E2:  MOVFF  3B,67
14E6:  MOVFF  3A,66
14EA:  MOVFF  39,65
14EE:  CALL   00C6
14F2:  MOVFF  03,40
14F6:  MOVFF  02,3F
14FA:  MOVFF  01,3E
14FE:  MOVFF  00,3D
1502:  MOVFF  03,44
1506:  MOVFF  02,43
150A:  MOVFF  01,42
150E:  MOVFF  00,41
1512:  RCALL  0E70
....................       } 
....................    } 
1514:  GOTO   16B4 (RETURN)
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #fuses HS,NOWDT,PUT,NOBROWNOUT,NOLVP   // configuração dos fuses do pic  
....................  
.................... #use   delay(clock=20000000)// Informa a função delay, o clock utilizado 
*
0020:  CLRF   FEA
0022:  MOVLW  36
0024:  MOVWF  FE9
0026:  MOVF   FEF,W
0028:  BZ    0044
002A:  MOVLW  06
002C:  MOVWF  01
002E:  CLRF   00
0030:  DECFSZ 00,F
0032:  BRA    0030
0034:  DECFSZ 01,F
0036:  BRA    002E
0038:  MOVLW  7B
003A:  MOVWF  00
003C:  DECFSZ 00,F
003E:  BRA    003C
0040:  DECFSZ FEF,F
0042:  BRA    002A
0044:  RETURN 0
.................... #BIT Data_Pin = 0x06.7                       // Pin mapped to PORTB.7 
.................... #BIT Data_Pin_Direction = 0x86.7             // Pin direction mapped to TRISB.7 
.................... #use   fast_io(a)//modo rápido de inicialização das portas 
.................... #use   fast_io(b)//modo rápido de inicialização das portas 
.................... #use   fast_io(d)//modo rápido de inicialização das portas 
.................... #use   fast_io(e)//modo rápido de inicialização das portas 
....................  
.................... #byte   porta = 0xf80 // atribui o nome "porta" ao registrador do port 0xf80 
.................... #byte   portb = 0xf81  
.................... #byte   portd = 0xf83 
.................... #byte   porte = 0xf84 
.................... #byte   portc = 0xf82 
.................... // pinos de entrada e saida  
.................... #bit NTC = porta.0    //  Pino de leitura do NTC  
.................... #bit PIN_COOLER = portc.0  //  Pino de leitura do DHT11 
.................... #bit POT_SET_TEMP = porta.1 //Pino de leitura do potenciometro de set da temperatura  
.................... #bit POT_SET_UMI = porta.2 //Pino de leitura do potenciometro de set da umidade  
.................... #bit BOT_BLK_LTH = portb.0 // Pino do botao paraligar a luz do lcd 
.................... #bit BOT_MORE_INF = portb.1 // botao para mais informaçoes no lcd 
.................... // pinos de saida 
....................  
.................... #bit RELE_LAMP = portb.2  //  pino que acionamento do relé da lampada/aquecedor 
.................... #bit PIN_IN1_MOTPAS = portb.3 //  pino de controle do motor de paso via modulo  
.................... #bit PIN_IN2_MOTPAS = portb.4 //  pino de controle do motor de paso via modulo  
.................... #bit PIN_IN3_MOTPAS = portb.5 //  pino de controle do motor de paso via modulo  
.................... #bit PIN_IN4_MOTPAS = portb.6 //  pino de controle do motor de paso via modulo  
.................... #bit DHT11 = portb.7 // Pino de acionamento do cooler via transistor  
.................... #bit rs =porte.0 //  via do lcd que sinaliza recepção de dados ou comando  
.................... #bit enable = porte.1 // habilita o lcd 
.................... #byte DISPLAY = portd //  seleciona o port no qual o lcd esta ligado ( o mesmo valor que esta no arquivo.h) 
.................... #INCLUDE <lcd.h> // inclui a biblioteca do modulo lcd 
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *      Rotina que envia um COMANDO para o LCD                 * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void comando_lcd(int caracter) 
.................... { 
....................    rs = 0;               // seleciona o envio de um caracter 
*
0004:  BCF    F84.0
....................    portd = caracter;         // carrega o portc com o caracter 
0006:  MOVFF  35,F83
....................    enable = 1 ;            // gera pulso no enable 
000A:  BSF    F84.1
....................    delay_us(1);            // espera 1 microsegundos 
000C:  BRA    000E
000E:  BRA    0010
0010:  NOP   
....................    enable = 0;            // desce o pino de enable 
0012:  BCF    F84.1
....................  
....................    delay_us(40);            // espera mínimo 40 microsegundos 
0014:  MOVLW  42
0016:  MOVWF  00
0018:  DECFSZ 00,F
001A:  BRA    0018
001C:  NOP   
....................     
....................    return;               // retorna 
001E:  RETURN 0
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *      Rotina que envia um DADO a ser escrito no LCD              * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void escreve_lcd(int caracter) 
.................... { 
....................    rs = 1;               // seleciona o envio de um comando 
*
1A3A:  BSF    F84.0
....................    portd = caracter;         // carrega o portc com o valor do comando 
1A3C:  MOVFF  42,F83
....................    enable = 1;            // gera pulso no enable 
1A40:  BSF    F84.1
....................    delay_us(1);            // espera 3 microsegundos 
1A42:  BRA    1A44
1A44:  BRA    1A46
1A46:  NOP   
....................    enable = 0;            // desce o pino de enable 
1A48:  BCF    F84.1
....................  
....................    delay_us(40);            // espera mínimo 40 microsegundos 
1A4A:  MOVLW  42
1A4C:  MOVWF  00
1A4E:  DECFSZ 00,F
1A50:  BRA    1A4E
1A52:  NOP   
....................     
....................    return;               // retorna 
1A54:  RETURN 0
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *              Função para limpar o LCD                 * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void limpa_lcd() 
.................... { 
....................    comando_lcd(0x01);         // limpa lcd    
*
0046:  MOVLW  01
0048:  MOVWF  35
004A:  RCALL  0004
....................    delay_ms (2); 
004C:  MOVLW  02
004E:  MOVWF  36
0050:  RCALL  0020
....................    return; 
0052:  GOTO   0080 (RETURN)
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *           Inicialização do Display de LCD                 * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void inicializa_lcd() 
.................... { 
....................    comando_lcd(0x30);         // envia comando para inicializar display 
0056:  MOVLW  30
0058:  MOVWF  35
005A:  RCALL  0004
....................    delay_ms(4);            // espera 4 milisengundos 
005C:  MOVLW  04
005E:  MOVWF  36
0060:  RCALL  0020
....................  
....................    comando_lcd(0x30);         // envia comando para inicializar display 
0062:  MOVLW  30
0064:  MOVWF  35
0066:  RCALL  0004
....................    delay_us(100);            // espera 100 microsengundos 
0068:  MOVLW  A6
006A:  MOVWF  00
006C:  DECFSZ 00,F
006E:  BRA    006C
0070:  NOP   
....................  
....................    comando_lcd(0x30);         // envia comando para inicializar display 
0072:  MOVLW  30
0074:  MOVWF  35
0076:  RCALL  0004
....................  
....................    comando_lcd(0x38);         // liga o display, sem cursor e sem blink 
0078:  MOVLW  38
007A:  MOVWF  35
007C:  RCALL  0004
....................  
....................    limpa_lcd();            // limpa lcd 
007E:  BRA    0046
....................  
....................    comando_lcd(0x0c);         // display sem cursor 
0080:  MOVLW  0C
0082:  MOVWF  35
0084:  RCALL  0004
....................  
....................    comando_lcd(0x06);         // desloca cursor para a direita 
0086:  MOVLW  06
0088:  MOVWF  35
008A:  RCALL  0004
....................  
....................    return;               // retorna 
008C:  GOTO   1C70 (RETURN)
.................... }    
....................  
....................  
....................  
.................... char message2[] = "RH   = 00.0 %"; //  vetor de mensagem para a umidade  
.................... short Time_out; //  variavel para as funçoes referentes ao sensor de umidade dht11 
.................... unsigned  int8 RH_byte1, RH_byte2, CheckSum; //  variaveis para as funçoes do dht11 
....................  
.................... double ntc_val = 0; // variavel responsavel por receber o valor digital do ntc 
.................... double rntc = 0; //  valor da resistencia do divisor de tensao do ntc  
.................... double b1=0;  //  variavel auxiliar para função do ntc 
.................... double c1=0;//  variavel auxiliar para função do ntc 
.................... double temp=0;//  variavel auxiliar para função do ntc 
.................... double temperatura=0;//  variavel auxiliar para função do ntc 
.................... char umidade;//  variavel auxiliar para função do ntc 
.................... const double a = 0.0011303; //  constantes fisicas do sensor ntc 10k 
.................... const double b = 0.0002339; //  constantes fisicas do sensor ntc 10k 
.................... const double c = 0.00000008863; //  constantes fisicas do sensor ntc 10k 
....................  
....................  
....................  
.................... // FUNÇÃO POR INICIAR A DHT11 
....................  
.................... void start_signal(){ 
....................   Data_Pin_Direction = 0;              // Configure connection pin as output 
*
17EC:  BCF    x86.7
....................   Data_Pin = 0;                        // Connection pin output low 
17EE:  BCF    06.7
....................   delay_ms(25); 
17F0:  MOVLW  19
17F2:  MOVWF  36
17F4:  CALL   0020
....................   Data_Pin = 1;                        // Connection pin output high 
17F8:  BSF    06.7
....................   delay_us(30); 
17FA:  MOVLW  31
17FC:  MOVWF  00
17FE:  DECFSZ 00,F
1800:  BRA    17FE
1802:  BRA    1804
....................   Data_Pin_Direction = 1;              // Configure connection pin as input 
1804:  BSF    x86.7
1806:  GOTO   1910 (RETURN)
.................... } 
....................  
.................... // FUNÇAÕ POR VERIFICAR SE O SENSOR ESTA RESPONDENDO  
....................  
....................   short check_response(){ 
....................   delay_us(40); 
180A:  MOVLW  42
180C:  MOVWF  00
180E:  DECFSZ 00,F
1810:  BRA    180E
1812:  NOP   
....................   if(!Data_Pin){                     // Read and test if connection pin is low 
1814:  BTFSC  06.7
1816:  BRA    1838
....................     delay_us(80); 
1818:  MOVLW  84
181A:  MOVWF  00
181C:  DECFSZ 00,F
181E:  BRA    181C
1820:  BRA    1822
1822:  NOP   
....................     if(Data_Pin){                    // Read and test if connection pin is high 
1824:  BTFSS  06.7
1826:  BRA    1838
....................       delay_us(50); 
1828:  MOVLW  52
182A:  MOVWF  00
182C:  DECFSZ 00,F
182E:  BRA    182C
1830:  BRA    1832
1832:  NOP   
....................       return 1;} 
1834:  MOVLW  01
1836:  MOVWF  01
....................     } 
1838:  GOTO   1912 (RETURN)
.................... } 
....................  
....................  
.................... // FUNÇÃO PARA A OBTENÇÃO DO VALOR DE HUMIDADE 
.................... unsigned int8 Read_Data(){ 
183C:  CLRF   37
....................   unsigned int8 i, k, _data = 0;     // k is used to count 1 bit reading duration 
....................   if(Time_out) 
183E:  BTFSS  18.0
1840:  BRA    1842
....................     break; 
....................   for(i = 0; i < 8; i++){ 
1842:  CLRF   35
1844:  MOVF   35,W
1846:  SUBLW  07
1848:  BNC   18CE
....................     k = 0; 
184A:  CLRF   36
....................     while(!Data_Pin){                          // Wait until pin goes high 
184C:  BTFSC  06.7
184E:  BRA    1864
....................       k++; 
1850:  INCF   36,F
....................       if (k > 100) {Time_out = 1; break;} 
1852:  MOVF   36,W
1854:  SUBLW  64
1856:  BC    185C
1858:  BSF    18.0
185A:  BRA    1864
....................       delay_us(1);} 
185C:  BRA    185E
185E:  BRA    1860
1860:  NOP   
1862:  BRA    184C
....................     delay_us(30); 
1864:  MOVLW  31
1866:  MOVWF  00
1868:  DECFSZ 00,F
186A:  BRA    1868
186C:  BRA    186E
....................     if(!Data_Pin) 
186E:  BTFSC  06.7
1870:  BRA    1894
....................       bit_clear(_data, (7 - i));               // Clear bit (7 - i) 
1872:  MOVLW  07
1874:  BSF    FD8.0
1876:  SUBFWB 35,W
1878:  MOVWF  38
187A:  MOVLW  01
187C:  MOVWF  00
187E:  MOVF   38,W
1880:  MOVWF  01
1882:  BZ    188C
1884:  BCF    FD8.0
1886:  RLCF   00,F
1888:  DECFSZ 01,F
188A:  BRA    1884
188C:  MOVF   00,W
188E:  XORLW  FF
1890:  ANDWF  37,F
1892:  BRA    18CA
....................     else{ 
....................       bit_set(_data, (7 - i));                 // Set bit (7 - i) 
1894:  MOVLW  07
1896:  BSF    FD8.0
1898:  SUBFWB 35,W
189A:  MOVWF  38
189C:  MOVLW  01
189E:  MOVWF  00
18A0:  MOVF   38,W
18A2:  MOVWF  01
18A4:  BZ    18AE
18A6:  BCF    FD8.0
18A8:  RLCF   00,F
18AA:  DECFSZ 01,F
18AC:  BRA    18A6
18AE:  MOVF   00,W
18B0:  IORWF  37,F
....................       while(Data_Pin){                         // Wait until pin goes low 
18B2:  BTFSS  06.7
18B4:  BRA    18CA
....................       k++; 
18B6:  INCF   36,F
....................       if (k > 100) {Time_out = 1; break;} 
18B8:  MOVF   36,W
18BA:  SUBLW  64
18BC:  BC    18C2
18BE:  BSF    18.0
18C0:  BRA    18CA
....................       delay_us(1);} 
18C2:  BRA    18C4
18C4:  BRA    18C6
18C6:  NOP   
18C8:  BRA    18B2
....................     } 
18CA:  INCF   35,F
18CC:  BRA    1844
....................   } 
....................   return _data; 
18CE:  MOVFF  37,01
18D2:  RETURN 0
.................... } 
....................  
.................... // FUNÇÃO PRINCIPAL QUE RETORNARA A UMIDADE  
....................  
.................... char dht11(){ 
....................    delay_ms(1000); 
*
18FC:  MOVLW  04
18FE:  MOVWF  35
1900:  MOVLW  FA
1902:  MOVWF  36
1904:  CALL   0020
1908:  DECFSZ 35,F
190A:  BRA    1900
....................    Time_out = 0; 
190C:  BCF    18.0
....................    Start_signal(); 
190E:  BRA    17EC
....................    if(check_response()){// If there is response from sensor 
1910:  BRA    180A
1912:  MOVF   01,F
1914:  BZ    1960
....................    RH_byte1=Read_Data();// read RH byte1 
1916:  RCALL  183C
1918:  MOVFF  01,19
....................    RH_byte2=Read_Data();// read RH byte2 
191C:  RCALL  183C
191E:  MOVFF  01,1A
....................    Checksum=Read_Data();// read checksum                    
1922:  RCALL  183C
1924:  MOVFF  01,1B
....................       if(CheckSum==((RH_Byte1+RH_Byte2)& 0xFF)){ 
1928:  MOVF   1A,W
192A:  ADDWF  19,W
192C:  SUBWF  1B,W
192E:  BNZ   1960
....................       message2[7]=RH_Byte1/10+48; 
1930:  MOVFF  19,35
1934:  MOVLW  0A
1936:  MOVWF  36
1938:  RCALL  18D4
193A:  MOVLW  30
193C:  ADDWF  01,W
193E:  MOVWF  11
....................              message2[8]= RH_Byte1%10+48; 
1940:  MOVFF  19,35
1944:  MOVLW  0A
1946:  MOVWF  36
1948:  RCALL  18D4
194A:  MOVLW  30
194C:  ADDWF  00,W
194E:  MOVWF  12
....................              message2[10] = RH_Byte2/10+48;                             
1950:  MOVFF  1A,35
1954:  MOVLW  0A
1956:  MOVWF  36
1958:  RCALL  18D4
195A:  MOVLW  30
195C:  ADDWF  01,W
195E:  MOVWF  14
....................        } 
....................    }  
....................    return message2; 
1960:  MOVLW  0A
1962:  MOVWF  01
1964:  MOVLW  00
1966:  MOVWF  02
1968:  GOTO   1C84 (RETURN)
.................... } 
....................  
....................  
....................  
....................  
.................... float ntc(){ 
.................... set_adc_channel(0); //  escolhe o pino analogico para ler   
*
1518:  MOVLW  00
151A:  MOVWF  01
151C:  MOVF   FC2,W
151E:  ANDLW  C3
1520:  IORWF  01,W
1522:  MOVWF  FC2
.................... delay_us(10); // delay para começar a conversão  
1524:  MOVLW  10
1526:  MOVWF  00
1528:  DECFSZ 00,F
152A:  BRA    1528
152C:  NOP   
.................... ntc_val = read_adc(); // le o valor na porta analogica 
152E:  BSF    FC2.1
1530:  BTFSC  FC2.1
1532:  BRA    1530
1534:  MOVFF  FC4,03
1538:  MOVFF  FC3,65
153C:  MOVFF  FC4,66
1540:  CALL   0090
1544:  MOVFF  03,1F
1548:  MOVFF  02,1E
154C:  MOVFF  01,1D
1550:  MOVFF  00,1C
.................... ADC_done(); 
.................... ntc_val *=5; // multiplica o valor digitalizado pelo valor de tensão de alimentação 
1554:  MOVFF  1F,64
1558:  MOVFF  1E,63
155C:  MOVFF  1D,62
1560:  MOVFF  1C,61
1564:  CLRF   x68
1566:  CLRF   x67
1568:  MOVLW  20
156A:  MOVWF  x66
156C:  MOVLW  81
156E:  MOVWF  x65
1570:  CALL   00C6
1574:  MOVFF  03,1F
1578:  MOVFF  02,1E
157C:  MOVFF  01,1D
1580:  MOVFF  00,1C
.................... ntc_val/=1023;  // divide  o valor acima por 1023 
1584:  MOVFF  1F,5D
1588:  MOVFF  1E,5C
158C:  MOVFF  1D,5B
1590:  MOVFF  1C,5A
1594:  CLRF   x61
1596:  MOVLW  C0
1598:  MOVWF  x60
159A:  MOVLW  7F
159C:  MOVWF  5F
159E:  MOVLW  88
15A0:  MOVWF  5E
15A2:  CALL   01B8
15A6:  MOVFF  03,1F
15AA:  MOVFF  02,1E
15AE:  MOVFF  01,1D
15B2:  MOVFF  00,1C
.................... // Inicio calculo de equação de  Steinhart & Hart  
.................... rntc=33000/ntc_val;      
15B6:  CLRF   5D
15B8:  MOVLW  E8
15BA:  MOVWF  5C
15BC:  CLRF   5B
15BE:  MOVLW  8E
15C0:  MOVWF  5A
15C2:  MOVFF  1F,61
15C6:  MOVFF  1E,60
15CA:  MOVFF  1D,5F
15CE:  MOVFF  1C,5E
15D2:  CALL   01B8
15D6:  MOVFF  03,23
15DA:  MOVFF  02,22
15DE:  MOVFF  01,21
15E2:  MOVFF  00,20
....................        rntc=rntc-10000;       
15E6:  BSF    FD8.1
15E8:  MOVFF  23,68
15EC:  MOVFF  22,67
15F0:  MOVFF  21,66
15F4:  MOVFF  20,65
15F8:  CLRF   x6C
15FA:  MOVLW  40
15FC:  MOVWF  x6B
15FE:  MOVLW  1C
1600:  MOVWF  x6A
1602:  MOVLW  8C
1604:  MOVWF  x69
1606:  CALL   0312
160A:  MOVFF  03,23
160E:  MOVFF  02,22
1612:  MOVFF  01,21
1616:  MOVFF  00,20
....................        b1=log(rntc);           
161A:  MOVFF  23,44
161E:  MOVFF  22,43
1622:  MOVFF  21,42
1626:  MOVFF  20,41
162A:  CALL   063A
162E:  MOVFF  03,27
1632:  MOVFF  02,26
1636:  MOVFF  01,25
163A:  MOVFF  00,24
....................        b1=b1*b;                
163E:  MOVFF  27,64
1642:  MOVFF  26,63
1646:  MOVFF  25,62
164A:  MOVFF  24,61
164E:  MOVLW  0E
1650:  MOVWF  x68
1652:  MOVLW  43
1654:  MOVWF  x67
1656:  MOVLW  75
1658:  MOVWF  x66
165A:  MOVLW  72
165C:  MOVWF  x65
165E:  CALL   00C6
1662:  MOVFF  03,27
1666:  MOVFF  02,26
166A:  MOVFF  01,25
166E:  MOVFF  00,24
....................        c1=log(rntc);           
1672:  MOVFF  23,44
1676:  MOVFF  22,43
167A:  MOVFF  21,42
167E:  MOVFF  20,41
1682:  CALL   063A
1686:  MOVFF  03,2B
168A:  MOVFF  02,2A
168E:  MOVFF  01,29
1692:  MOVFF  00,28
....................        c1=pow(c1,3);           
1696:  MOVFF  2B,38
169A:  MOVFF  2A,37
169E:  MOVFF  29,36
16A2:  MOVFF  28,35
16A6:  CLRF   3C
16A8:  CLRF   3B
16AA:  MOVLW  40
16AC:  MOVWF  3A
16AE:  MOVLW  80
16B0:  MOVWF  39
16B2:  BRA    1242
16B4:  MOVFF  03,2B
16B8:  MOVFF  02,2A
16BC:  MOVFF  01,29
16C0:  MOVFF  00,28
....................        c1=c1*c;                
16C4:  MOVFF  2B,64
16C8:  MOVFF  2A,63
16CC:  MOVFF  29,62
16D0:  MOVFF  28,61
16D4:  MOVLW  DC
16D6:  MOVWF  x68
16D8:  MOVLW  54
16DA:  MOVWF  x67
16DC:  MOVLW  3E
16DE:  MOVWF  x66
16E0:  MOVLW  67
16E2:  MOVWF  x65
16E4:  CALL   00C6
16E8:  MOVFF  03,2B
16EC:  MOVFF  02,2A
16F0:  MOVFF  01,29
16F4:  MOVFF  00,28
....................        temp=a+b1+c1;           
16F8:  BCF    FD8.1
16FA:  MOVLW  93
16FC:  MOVWF  x68
16FE:  MOVLW  26
1700:  MOVWF  x67
1702:  MOVLW  14
1704:  MOVWF  x66
1706:  MOVLW  75
1708:  MOVWF  x65
170A:  MOVFF  27,6C
170E:  MOVFF  26,6B
1712:  MOVFF  25,6A
1716:  MOVFF  24,69
171A:  CALL   0312
171E:  MOVFF  03,38
1722:  MOVFF  02,37
1726:  MOVFF  01,36
172A:  MOVFF  00,35
172E:  BCF    FD8.1
1730:  MOVFF  03,68
1734:  MOVFF  02,67
1738:  MOVFF  01,66
173C:  MOVFF  00,65
1740:  MOVFF  2B,6C
1744:  MOVFF  2A,6B
1748:  MOVFF  29,6A
174C:  MOVFF  28,69
1750:  CALL   0312
1754:  MOVFF  03,2F
1758:  MOVFF  02,2E
175C:  MOVFF  01,2D
1760:  MOVFF  00,2C
....................        temp=1/temp;            
1764:  CLRF   5D
1766:  CLRF   5C
1768:  CLRF   5B
176A:  MOVLW  7F
176C:  MOVWF  5A
176E:  MOVFF  2F,61
1772:  MOVFF  2E,60
1776:  MOVFF  2D,5F
177A:  MOVFF  2C,5E
177E:  CALL   01B8
1782:  MOVFF  03,2F
1786:  MOVFF  02,2E
178A:  MOVFF  01,2D
178E:  MOVFF  00,2C
....................        temp=temp-273.15; 
1792:  BSF    FD8.1
1794:  MOVFF  2F,68
1798:  MOVFF  2E,67
179C:  MOVFF  2D,66
17A0:  MOVFF  2C,65
17A4:  MOVLW  33
17A6:  MOVWF  x6C
17A8:  MOVLW  93
17AA:  MOVWF  x6B
17AC:  MOVLW  08
17AE:  MOVWF  x6A
17B0:  MOVLW  87
17B2:  MOVWF  x69
17B4:  CALL   0312
17B8:  MOVFF  03,2F
17BC:  MOVFF  02,2E
17C0:  MOVFF  01,2D
17C4:  MOVFF  00,2C
....................        delay_ms(500); 
17C8:  MOVLW  02
17CA:  MOVWF  35
17CC:  MOVLW  FA
17CE:  MOVWF  36
17D0:  CALL   0020
17D4:  DECFSZ 35,F
17D6:  BRA    17CC
....................        return temp; 
17D8:  MOVFF  2C,00
17DC:  MOVFF  2D,01
17E0:  MOVFF  2E,02
17E4:  MOVFF  2F,03
17E8:  GOTO   1C72 (RETURN)
.................... // Fim do calculo de equação de  Steinhart & Hart 
.................... } 
....................  
....................  
.................... int tratamento_de_bouncing() { 
....................  
....................  
....................  
....................  
.................... //  Aqui será implementada uma função para o tratamento de bouncing de todos os botoes da aplicação  
....................  
....................  
....................  
....................  
....................  
....................  
.................... } 
....................  
....................  
.................... void aciona_stepper_motor() { 
....................  
....................  
.................... // Aqui será implementada a função responsavel por acionar o stepper motor  
....................  
....................  
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... void main (void){ 
*
1BD2:  CLRF   FF8
1BD4:  BCF    FD0.7
1BD6:  CLRF   1F
1BD8:  CLRF   1E
1BDA:  CLRF   1D
1BDC:  CLRF   1C
1BDE:  CLRF   23
1BE0:  CLRF   22
1BE2:  CLRF   21
1BE4:  CLRF   20
1BE6:  CLRF   27
1BE8:  CLRF   26
1BEA:  CLRF   25
1BEC:  CLRF   24
1BEE:  CLRF   2B
1BF0:  CLRF   2A
1BF2:  CLRF   29
1BF4:  CLRF   28
1BF6:  CLRF   2F
1BF8:  CLRF   2E
1BFA:  CLRF   2D
1BFC:  CLRF   2C
1BFE:  CLRF   33
1C00:  CLRF   32
1C02:  CLRF   31
1C04:  CLRF   30
1C06:  MOVF   FC1,W
1C08:  ANDLW  C0
1C0A:  IORLW  0F
1C0C:  MOVWF  FC1
1C0E:  MOVLW  07
1C10:  MOVWF  FB4
1C12:  CLRF   04
1C14:  CLRF   05
1C16:  MOVLW  52
1C18:  MOVWF  0A
1C1A:  MOVLW  48
1C1C:  MOVWF  0B
1C1E:  MOVLW  A0
1C20:  MOVWF  0C
1C22:  MOVWF  0D
1C24:  MOVWF  0E
1C26:  MOVLW  3D
1C28:  MOVWF  0F
1C2A:  MOVLW  A0
1C2C:  MOVWF  10
1C2E:  MOVLW  30
1C30:  MOVWF  11
1C32:  MOVWF  12
1C34:  MOVLW  2E
1C36:  MOVWF  13
1C38:  MOVLW  30
1C3A:  MOVWF  14
1C3C:  MOVLW  A0
1C3E:  MOVWF  15
1C40:  MOVLW  25
1C42:  MOVWF  16
1C44:  CLRF   17
....................  
.................... setup_adc(ADC_CLOCK_DIV_8); //  configura o clock utilizado para o conversor ad e o pior clock ele usa a malha RC é lenta  
1C46:  MOVF   FC0,W
1C48:  ANDLW  C0
1C4A:  IORLW  01
1C4C:  MOVWF  FC0
1C4E:  BSF    FC0.7
1C50:  BSF    FC2.0
.................... setup_adc_ports( AN0_TO_AN2 ); // selecionaos pinos A0 a A2 como pinos de sinais analogicos  
1C52:  MOVF   FC1,W
1C54:  ANDLW  C0
1C56:  IORLW  0C
1C58:  MOVWF  FC1
.................... set_tris_a(0b00001111); // verificar se pinos analogicos necessitam de definição de tris 
1C5A:  MOVLW  0F
1C5C:  MOVWF  F92
.................... set_tris_b(0b11000000);   
1C5E:  MOVLW  C0
1C60:  MOVWF  F93
.................... set_tris_c(0b00000000);// define os pinos RB0 E RB1 como entrada e os demais como saida 
1C62:  MOVLW  00
1C64:  MOVWF  F94
.................... set_tris_d(0b00000000);  //  Idem como supracitado acima  
1C66:  MOVWF  F95
.................... set_tris_e(0b00000100); 
1C68:  MOVLW  04
1C6A:  MOVWF  F96
.................... inicializa_lcd(); // função responsavel por inicializar o modulo lcd 
1C6C:  GOTO   0056
....................   while(true){ 
....................    
....................   temperatura = ntc(); //  le o valor  de temperatura em graus celsius que a função do ntc retorna  
1C70:  BRA    1518
1C72:  MOVFF  03,33
1C76:  MOVFF  02,32
1C7A:  MOVFF  01,31
1C7E:  MOVFF  00,30
....................   umidade = dht11(); 
1C82:  BRA    18FC
1C84:  MOVFF  01,34
....................   comando_lcd(0x83); //  posiciona o cursor no endereço 0x83 
1C88:  MOVLW  83
1C8A:  MOVWF  35
1C8C:  CALL   0004
....................   printf(escreve_lcd,"%f\n", temperatura ); 
1C90:  MOVLW  89
1C92:  MOVWF  FE9
1C94:  MOVFF  33,38
1C98:  MOVFF  32,37
1C9C:  MOVFF  31,36
1CA0:  MOVFF  30,35
1CA4:  MOVLW  02
1CA6:  MOVWF  39
1CA8:  BRA    1A56
1CAA:  MOVLW  0A
1CAC:  MOVWF  42
1CAE:  RCALL  1A3A
....................     // implementação da rotina de controle de  temperatura  
....................     if(temperatura<=38){   //  verifica se da temperatura de menor que 38 graus e faz  a rotina  
1CB0:  MOVFF  33,64
1CB4:  MOVFF  32,63
1CB8:  MOVFF  31,62
1CBC:  MOVFF  30,61
1CC0:  CLRF   x68
1CC2:  CLRF   x67
1CC4:  MOVLW  18
1CC6:  MOVWF  x66
1CC8:  MOVLW  84
1CCA:  MOVWF  x65
1CCC:  CALL   057C
1CD0:  BC    1CD4
1CD2:  BNZ   1CD8
....................      PIN_COOLER =0 ; 
1CD4:  BCF    F82.0
....................      RELE_LAMP = 1 ; 
1CD6:  BSF    F81.2
....................     } 
....................     if(temperatura>38){ 
1CD8:  CLRF   x64
1CDA:  CLRF   x63
1CDC:  MOVLW  18
1CDE:  MOVWF  x62
1CE0:  MOVLW  84
1CE2:  MOVWF  x61
1CE4:  MOVFF  33,68
1CE8:  MOVFF  32,67
1CEC:  MOVFF  31,66
1CF0:  MOVFF  30,65
1CF4:  CALL   057C
1CF8:  BNC   1CFE
....................     PIN_COOLER =1 ; 
1CFA:  BSF    F82.0
....................     RELE_LAMP = 0 ;  
1CFC:  BCF    F81.2
....................     } 
1CFE:  BRA    1C70
....................     //delay_ms(2000);    
....................   } 
....................    
....................    
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... } 
1D00:  SLEEP 

Configuration Fuses:
   Word  1: CC3F   PLL12 CPUDIV4 USBDIV HS FCMEN IESO
   Word  2: 1E38   PUT NOBROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
