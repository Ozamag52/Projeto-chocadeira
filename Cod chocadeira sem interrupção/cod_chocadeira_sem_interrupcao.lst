CCS PCH C Compiler, Version 5.015, 5967               28-jun-17 22:18

               Filename:   C:\Users\henri\Documents\GitHub\Projeto-chocadeira\Cod chocadeira sem interrupção\cod_chocadeira_sem_interrupcao.lst

               ROM used:   7340 bytes (22%)
                           Largest free fragment is 25424
               RAM used:   87 (4%) at main() level
                           153 (7%) worst case
               Stack used: 7 locations (6 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   1B40
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  FF2.5
004A:  GOTO   0054
004E:  BTFSC  FF2.2
0050:  GOTO   0096
0054:  MOVFF  0E,00
0058:  MOVFF  0F,01
005C:  MOVFF  10,02
0060:  MOVFF  11,03
0064:  MOVFF  0C,FE9
0068:  MOVFF  07,FEA
006C:  BSF    07.7
006E:  MOVFF  08,FE1
0072:  MOVFF  09,FE2
0076:  MOVFF  0A,FD9
007A:  MOVFF  0B,FDA
007E:  MOVFF  12,FF3
0082:  MOVFF  13,FF4
0086:  MOVFF  14,FFA
008A:  MOVF   04,W
008C:  MOVFF  06,FE0
0090:  MOVFF  05,FD8
0094:  RETFIE 0
....................  
.................... #INCLUDE<18F4550.h>//   Inclui a biblioteca resposável por estabelecer os parametros do pic utilizado no projeto 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
*
00B6:  DATA 4D,45
00B8:  DATA 58,45
00BA:  DATA 4E,44
00BC:  DATA 4F,00
*
0148:  MOVLW  8E
014A:  MOVWF  00
014C:  MOVFF  88,01
0150:  MOVFF  87,02
0154:  CLRF   03
0156:  MOVF   01,F
0158:  BNZ   016C
015A:  MOVFF  02,01
015E:  CLRF   02
0160:  MOVLW  08
0162:  SUBWF  00,F
0164:  MOVF   01,F
0166:  BNZ   016C
0168:  CLRF   00
016A:  BRA    017C
016C:  BCF    FD8.0
016E:  BTFSC  01.7
0170:  BRA    017A
0172:  RLCF   02,F
0174:  RLCF   01,F
0176:  DECF   00,F
0178:  BRA    016C
017A:  BCF    01.7
017C:  RETURN 0
017E:  MOVF   x83,W
0180:  BTFSC  FD8.2
0182:  BRA    0266
0184:  MOVWF  00
0186:  MOVF   x87,W
0188:  BTFSC  FD8.2
018A:  BRA    0266
018C:  ADDWF  00,F
018E:  BNC   0198
0190:  MOVLW  81
0192:  ADDWF  00,F
0194:  BC    0266
0196:  BRA    01A0
0198:  MOVLW  7F
019A:  SUBWF  00,F
019C:  BNC   0266
019E:  BZ    0266
01A0:  MOVFF  84,8B
01A4:  MOVF   x88,W
01A6:  XORWF  x8B,F
01A8:  BSF    x84.7
01AA:  BSF    x88.7
01AC:  MOVF   x86,W
01AE:  MULWF  x8A
01B0:  MOVFF  FF4,8D
01B4:  MOVF   x85,W
01B6:  MULWF  x89
01B8:  MOVFF  FF4,03
01BC:  MOVFF  FF3,8C
01C0:  MULWF  x8A
01C2:  MOVF   FF3,W
01C4:  ADDWF  x8D,F
01C6:  MOVF   FF4,W
01C8:  ADDWFC x8C,F
01CA:  MOVLW  00
01CC:  ADDWFC 03,F
01CE:  MOVF   x86,W
01D0:  MULWF  x89
01D2:  MOVF   FF3,W
01D4:  ADDWF  x8D,F
01D6:  MOVF   FF4,W
01D8:  ADDWFC x8C,F
01DA:  MOVLW  00
01DC:  CLRF   02
01DE:  ADDWFC 03,F
01E0:  ADDWFC 02,F
01E2:  MOVF   x84,W
01E4:  MULWF  x8A
01E6:  MOVF   FF3,W
01E8:  ADDWF  x8C,F
01EA:  MOVF   FF4,W
01EC:  ADDWFC 03,F
01EE:  MOVLW  00
01F0:  ADDWFC 02,F
01F2:  MOVF   x84,W
01F4:  MULWF  x89
01F6:  MOVF   FF3,W
01F8:  ADDWF  03,F
01FA:  MOVF   FF4,W
01FC:  ADDWFC 02,F
01FE:  MOVLW  00
0200:  CLRF   01
0202:  ADDWFC 01,F
0204:  MOVF   x86,W
0206:  MULWF  x88
0208:  MOVF   FF3,W
020A:  ADDWF  x8C,F
020C:  MOVF   FF4,W
020E:  ADDWFC 03,F
0210:  MOVLW  00
0212:  ADDWFC 02,F
0214:  ADDWFC 01,F
0216:  MOVF   x85,W
0218:  MULWF  x88
021A:  MOVF   FF3,W
021C:  ADDWF  03,F
021E:  MOVF   FF4,W
0220:  ADDWFC 02,F
0222:  MOVLW  00
0224:  ADDWFC 01,F
0226:  MOVF   x84,W
0228:  MULWF  x88
022A:  MOVF   FF3,W
022C:  ADDWF  02,F
022E:  MOVF   FF4,W
0230:  ADDWFC 01,F
0232:  INCF   00,F
0234:  BTFSC  01.7
0236:  BRA    0242
0238:  RLCF   x8C,F
023A:  RLCF   03,F
023C:  RLCF   02,F
023E:  RLCF   01,F
0240:  DECF   00,F
0242:  MOVLW  00
0244:  BTFSS  x8C.7
0246:  BRA    025C
0248:  INCF   03,F
024A:  ADDWFC 02,F
024C:  ADDWFC 01,F
024E:  MOVF   01,W
0250:  BNZ   025C
0252:  MOVF   02,W
0254:  BNZ   025C
0256:  MOVF   03,W
0258:  BNZ   025C
025A:  INCF   00,F
025C:  BTFSC  x8B.7
025E:  BSF    01.7
0260:  BTFSS  x8B.7
0262:  BCF    01.7
0264:  BRA    026E
0266:  CLRF   00
0268:  CLRF   01
026A:  CLRF   02
026C:  CLRF   03
026E:  RETURN 0
0270:  MOVF   x7C,W
0272:  BTFSC  FD8.2
0274:  BRA    03C0
0276:  MOVWF  x88
0278:  MOVF   x80,W
027A:  BTFSC  FD8.2
027C:  BRA    03C0
027E:  SUBWF  x88,F
0280:  BNC   028C
0282:  MOVLW  7F
0284:  ADDWF  x88,F
0286:  BTFSC  FD8.0
0288:  BRA    03C0
028A:  BRA    0298
028C:  MOVLW  81
028E:  SUBWF  x88,F
0290:  BTFSS  FD8.0
0292:  BRA    03C0
0294:  BTFSC  FD8.2
0296:  BRA    03C0
0298:  MOVFF  88,00
029C:  CLRF   01
029E:  CLRF   02
02A0:  CLRF   03
02A2:  CLRF   x87
02A4:  MOVFF  7D,86
02A8:  BSF    x86.7
02AA:  MOVFF  7E,85
02AE:  MOVFF  7F,84
02B2:  MOVLW  19
02B4:  MOVWF  x88
02B6:  MOVF   x83,W
02B8:  SUBWF  x84,F
02BA:  BC    02D6
02BC:  MOVLW  01
02BE:  SUBWF  x85,F
02C0:  BC    02D6
02C2:  SUBWF  x86,F
02C4:  BC    02D6
02C6:  SUBWF  x87,F
02C8:  BC    02D6
02CA:  INCF   x87,F
02CC:  INCF   x86,F
02CE:  INCF   x85,F
02D0:  MOVF   x83,W
02D2:  ADDWF  x84,F
02D4:  BRA    0326
02D6:  MOVF   x82,W
02D8:  SUBWF  x85,F
02DA:  BC    0300
02DC:  MOVLW  01
02DE:  SUBWF  x86,F
02E0:  BC    0300
02E2:  SUBWF  x87,F
02E4:  BC    0300
02E6:  INCF   x87,F
02E8:  INCF   x86,F
02EA:  MOVF   x82,W
02EC:  ADDWF  x85,F
02EE:  MOVF   x83,W
02F0:  ADDWF  x84,F
02F2:  BNC   0326
02F4:  INCF   x85,F
02F6:  BNZ   0326
02F8:  INCF   x86,F
02FA:  BNZ   0326
02FC:  INCF   x87,F
02FE:  BRA    0326
0300:  MOVF   x81,W
0302:  IORLW  80
0304:  SUBWF  x86,F
0306:  BC    0324
0308:  MOVLW  01
030A:  SUBWF  x87,F
030C:  BC    0324
030E:  INCF   x87,F
0310:  MOVF   x81,W
0312:  IORLW  80
0314:  ADDWF  x86,F
0316:  MOVF   x82,W
0318:  ADDWF  x85,F
031A:  BNC   02EE
031C:  INCF   x86,F
031E:  BNZ   02EE
0320:  INCF   x87,F
0322:  BRA    02EE
0324:  BSF    03.0
0326:  DECFSZ x88,F
0328:  BRA    032C
032A:  BRA    0342
032C:  BCF    FD8.0
032E:  RLCF   x84,F
0330:  RLCF   x85,F
0332:  RLCF   x86,F
0334:  RLCF   x87,F
0336:  BCF    FD8.0
0338:  RLCF   03,F
033A:  RLCF   02,F
033C:  RLCF   01,F
033E:  RLCF   x89,F
0340:  BRA    02B6
0342:  BTFSS  x89.0
0344:  BRA    0352
0346:  BCF    FD8.0
0348:  RRCF   01,F
034A:  RRCF   02,F
034C:  RRCF   03,F
034E:  RRCF   x89,F
0350:  BRA    0356
0352:  DECF   00,F
0354:  BZ    03C0
0356:  BTFSC  x89.7
0358:  BRA    0396
035A:  BCF    FD8.0
035C:  RLCF   x84,F
035E:  RLCF   x85,F
0360:  RLCF   x86,F
0362:  RLCF   x87,F
0364:  MOVF   x83,W
0366:  SUBWF  x84,F
0368:  BC    0378
036A:  MOVLW  01
036C:  SUBWF  x85,F
036E:  BC    0378
0370:  SUBWF  x86,F
0372:  BC    0378
0374:  SUBWF  x87,F
0376:  BNC   03AC
0378:  MOVF   x82,W
037A:  SUBWF  x85,F
037C:  BC    0388
037E:  MOVLW  01
0380:  SUBWF  x86,F
0382:  BC    0388
0384:  SUBWF  x87,F
0386:  BNC   03AC
0388:  MOVF   x81,W
038A:  IORLW  80
038C:  SUBWF  x86,F
038E:  BC    0396
0390:  MOVLW  01
0392:  SUBWF  x87,F
0394:  BNC   03AC
0396:  INCF   03,F
0398:  BNZ   03AC
039A:  INCF   02,F
039C:  BNZ   03AC
039E:  INCF   01,F
03A0:  BNZ   03AC
03A2:  INCF   00,F
03A4:  BZ    03C0
03A6:  RRCF   01,F
03A8:  RRCF   02,F
03AA:  RRCF   03,F
03AC:  MOVFF  7D,88
03B0:  MOVF   x81,W
03B2:  XORWF  x88,F
03B4:  BTFSS  x88.7
03B6:  BRA    03BC
03B8:  BSF    01.7
03BA:  BRA    03C8
03BC:  BCF    01.7
03BE:  BRA    03C8
03C0:  CLRF   00
03C2:  CLRF   01
03C4:  CLRF   02
03C6:  CLRF   03
03C8:  RETURN 0
03CA:  MOVLW  80
03CC:  BTFSC  FD8.1
03CE:  XORWF  x8C,F
03D0:  CLRF   x91
03D2:  CLRF   x92
03D4:  MOVFF  88,90
03D8:  MOVF   x8C,W
03DA:  XORWF  x90,F
03DC:  MOVF   x87,W
03DE:  BTFSC  FD8.2
03E0:  BRA    059A
03E2:  MOVWF  x8F
03E4:  MOVWF  00
03E6:  MOVF   x8B,W
03E8:  BTFSC  FD8.2
03EA:  BRA    05AC
03EC:  SUBWF  x8F,F
03EE:  BTFSC  FD8.2
03F0:  BRA    04F4
03F2:  BNC   046E
03F4:  MOVFF  8C,95
03F8:  BSF    x95.7
03FA:  MOVFF  8D,94
03FE:  MOVFF  8E,93
0402:  CLRF   x92
0404:  BCF    FD8.0
0406:  RRCF   x95,F
0408:  RRCF   x94,F
040A:  RRCF   x93,F
040C:  RRCF   x92,F
040E:  DECFSZ x8F,F
0410:  BRA    0402
0412:  BTFSS  x90.7
0414:  BRA    041C
0416:  BSF    x91.0
0418:  BRA    05D4
041A:  BCF    x91.0
041C:  BCF    x8F.0
041E:  BSF    x91.4
0420:  CLRF   FEA
0422:  MOVLW  8A
0424:  MOVWF  FE9
0426:  BRA    05FA
0428:  BCF    x91.4
042A:  BTFSC  x90.7
042C:  BRA    0442
042E:  BTFSS  x8F.0
0430:  BRA    0458
0432:  RRCF   x95,F
0434:  RRCF   x94,F
0436:  RRCF   x93,F
0438:  RRCF   x92,F
043A:  INCF   00,F
043C:  BTFSC  FD8.2
043E:  BRA    05CA
0440:  BRA    0458
0442:  BTFSC  x95.7
0444:  BRA    045E
0446:  BCF    FD8.0
0448:  RLCF   x92,F
044A:  RLCF   x93,F
044C:  RLCF   x94,F
044E:  RLCF   x95,F
0450:  DECF   00,F
0452:  BTFSC  FD8.2
0454:  BRA    05CA
0456:  BRA    0442
0458:  BSF    x91.6
045A:  BRA    0532
045C:  BCF    x91.6
045E:  MOVFF  88,90
0462:  BTFSS  x88.7
0464:  BRA    046A
0466:  BSF    x95.7
0468:  BRA    05BC
046A:  BCF    x95.7
046C:  BRA    05BC
046E:  MOVFF  8B,8F
0472:  MOVFF  8B,00
0476:  MOVF   x87,W
0478:  SUBWF  x8F,F
047A:  MOVFF  88,95
047E:  BSF    x95.7
0480:  MOVFF  89,94
0484:  MOVFF  8A,93
0488:  CLRF   x92
048A:  BCF    FD8.0
048C:  RRCF   x95,F
048E:  RRCF   x94,F
0490:  RRCF   x93,F
0492:  RRCF   x92,F
0494:  DECFSZ x8F,F
0496:  BRA    0488
0498:  BTFSS  x90.7
049A:  BRA    04A2
049C:  BSF    x91.1
049E:  BRA    05D4
04A0:  BCF    x91.1
04A2:  BCF    x8F.0
04A4:  BSF    x91.5
04A6:  CLRF   FEA
04A8:  MOVLW  8E
04AA:  MOVWF  FE9
04AC:  BRA    05FA
04AE:  BCF    x91.5
04B0:  BTFSC  x90.7
04B2:  BRA    04C8
04B4:  BTFSS  x8F.0
04B6:  BRA    04DE
04B8:  RRCF   x95,F
04BA:  RRCF   x94,F
04BC:  RRCF   x93,F
04BE:  RRCF   x92,F
04C0:  INCF   00,F
04C2:  BTFSC  FD8.2
04C4:  BRA    05CA
04C6:  BRA    04DE
04C8:  BTFSC  x95.7
04CA:  BRA    04E4
04CC:  BCF    FD8.0
04CE:  RLCF   x92,F
04D0:  RLCF   x93,F
04D2:  RLCF   x94,F
04D4:  RLCF   x95,F
04D6:  DECF   00,F
04D8:  BTFSC  FD8.2
04DA:  BRA    05CA
04DC:  BRA    04C8
04DE:  BSF    x91.7
04E0:  BRA    0532
04E2:  BCF    x91.7
04E4:  MOVFF  8C,90
04E8:  BTFSS  x8C.7
04EA:  BRA    04F0
04EC:  BSF    x95.7
04EE:  BRA    05BC
04F0:  BCF    x95.7
04F2:  BRA    05BC
04F4:  MOVFF  8C,95
04F8:  BSF    x95.7
04FA:  MOVFF  8D,94
04FE:  MOVFF  8E,93
0502:  BTFSS  x90.7
0504:  BRA    050E
0506:  BCF    x95.7
0508:  BSF    x91.2
050A:  BRA    05D4
050C:  BCF    x91.2
050E:  CLRF   x92
0510:  BCF    x8F.0
0512:  CLRF   FEA
0514:  MOVLW  8A
0516:  MOVWF  FE9
0518:  BRA    05FA
051A:  BTFSC  x90.7
051C:  BRA    0556
051E:  MOVFF  88,90
0522:  BTFSS  x8F.0
0524:  BRA    0532
0526:  RRCF   x95,F
0528:  RRCF   x94,F
052A:  RRCF   x93,F
052C:  RRCF   x92,F
052E:  INCF   00,F
0530:  BZ    05CA
0532:  BTFSS  x92.7
0534:  BRA    054C
0536:  INCF   x93,F
0538:  BNZ   054C
053A:  INCF   x94,F
053C:  BNZ   054C
053E:  INCF   x95,F
0540:  BNZ   054C
0542:  RRCF   x95,F
0544:  RRCF   x94,F
0546:  RRCF   x93,F
0548:  INCF   00,F
054A:  BZ    05CA
054C:  BTFSC  x91.6
054E:  BRA    045C
0550:  BTFSC  x91.7
0552:  BRA    04E2
0554:  BRA    058E
0556:  MOVLW  80
0558:  XORWF  x95,F
055A:  BTFSS  x95.7
055C:  BRA    0566
055E:  BRA    05D4
0560:  MOVFF  8C,90
0564:  BRA    057A
0566:  MOVFF  88,90
056A:  MOVF   x95,F
056C:  BNZ   057A
056E:  MOVF   x94,F
0570:  BNZ   057A
0572:  MOVF   x93,F
0574:  BNZ   057A
0576:  CLRF   00
0578:  BRA    05BC
057A:  BTFSC  x95.7
057C:  BRA    058E
057E:  BCF    FD8.0
0580:  RLCF   x92,F
0582:  RLCF   x93,F
0584:  RLCF   x94,F
0586:  RLCF   x95,F
0588:  DECFSZ 00,F
058A:  BRA    057A
058C:  BRA    05CA
058E:  BTFSS  x90.7
0590:  BRA    0596
0592:  BSF    x95.7
0594:  BRA    05BC
0596:  BCF    x95.7
0598:  BRA    05BC
059A:  MOVFF  8B,00
059E:  MOVFF  8C,95
05A2:  MOVFF  8D,94
05A6:  MOVFF  8E,93
05AA:  BRA    05BC
05AC:  MOVFF  87,00
05B0:  MOVFF  88,95
05B4:  MOVFF  89,94
05B8:  MOVFF  8A,93
05BC:  MOVFF  95,01
05C0:  MOVFF  94,02
05C4:  MOVFF  93,03
05C8:  BRA    0632
05CA:  CLRF   00
05CC:  CLRF   01
05CE:  CLRF   02
05D0:  CLRF   03
05D2:  BRA    0632
05D4:  CLRF   x92
05D6:  COMF   x93,F
05D8:  COMF   x94,F
05DA:  COMF   x95,F
05DC:  COMF   x92,F
05DE:  INCF   x92,F
05E0:  BNZ   05EC
05E2:  INCF   x93,F
05E4:  BNZ   05EC
05E6:  INCF   x94,F
05E8:  BNZ   05EC
05EA:  INCF   x95,F
05EC:  BTFSC  x91.0
05EE:  BRA    041A
05F0:  BTFSC  x91.1
05F2:  BRA    04A0
05F4:  BTFSC  x91.2
05F6:  BRA    050C
05F8:  BRA    0560
05FA:  MOVF   FEF,W
05FC:  ADDWF  x93,F
05FE:  BNC   060A
0600:  INCF   x94,F
0602:  BNZ   060A
0604:  INCF   x95,F
0606:  BTFSC  FD8.2
0608:  BSF    x8F.0
060A:  MOVF   FED,F
060C:  MOVF   FEF,W
060E:  ADDWF  x94,F
0610:  BNC   0618
0612:  INCF   x95,F
0614:  BTFSC  FD8.2
0616:  BSF    x8F.0
0618:  MOVF   FED,F
061A:  MOVF   FEF,W
061C:  BTFSC  FEF.7
061E:  BRA    0622
0620:  XORLW  80
0622:  ADDWF  x95,F
0624:  BTFSC  FD8.0
0626:  BSF    x8F.0
0628:  BTFSC  x91.4
062A:  BRA    0428
062C:  BTFSC  x91.5
062E:  BRA    04AE
0630:  BRA    051A
0632:  RETURN 0
0634:  MOVFF  84,8B
0638:  MOVF   x88,W
063A:  XORWF  x8B,F
063C:  BTFSS  x8B.7
063E:  BRA    064A
0640:  BCF    FD8.2
0642:  BCF    FD8.0
0644:  BTFSC  x84.7
0646:  BSF    FD8.0
0648:  BRA    06A8
064A:  MOVFF  84,8B
064E:  MOVFF  87,8C
0652:  MOVF   x83,W
0654:  SUBWF  x8C,F
0656:  BZ    0664
0658:  BTFSS  x8B.7
065A:  BRA    06A8
065C:  MOVF   FD8,W
065E:  XORLW  01
0660:  MOVWF  FD8
0662:  BRA    06A8
0664:  MOVFF  88,8C
0668:  MOVF   x84,W
066A:  SUBWF  x8C,F
066C:  BZ    067A
066E:  BTFSS  x8B.7
0670:  BRA    06A8
0672:  MOVF   FD8,W
0674:  XORLW  01
0676:  MOVWF  FD8
0678:  BRA    06A8
067A:  MOVFF  89,8C
067E:  MOVF   x85,W
0680:  SUBWF  x8C,F
0682:  BZ    0690
0684:  BTFSS  x8B.7
0686:  BRA    06A8
0688:  MOVF   FD8,W
068A:  XORLW  01
068C:  MOVWF  FD8
068E:  BRA    06A8
0690:  MOVFF  8A,8C
0694:  MOVF   x86,W
0696:  SUBWF  x8C,F
0698:  BZ    06A6
069A:  BTFSS  x8B.7
069C:  BRA    06A8
069E:  MOVF   FD8,W
06A0:  XORLW  01
06A2:  MOVWF  FD8
06A4:  BRA    06A8
06A6:  BCF    FD8.0
06A8:  RETURN 0
06AA:  MOVLW  8E
06AC:  MOVWF  00
06AE:  MOVFF  7A,01
06B2:  MOVFF  79,02
06B6:  CLRF   03
06B8:  BTFSS  x7A.7
06BA:  BRA    06C6
06BC:  COMF   01,F
06BE:  COMF   02,F
06C0:  INCF   02,F
06C2:  BNZ   06C6
06C4:  INCF   01,F
06C6:  MOVF   01,F
06C8:  BNZ   06DC
06CA:  MOVFF  02,01
06CE:  CLRF   02
06D0:  MOVLW  08
06D2:  SUBWF  00,F
06D4:  MOVF   01,F
06D6:  BNZ   06DC
06D8:  CLRF   00
06DA:  BRA    06F0
06DC:  BCF    FD8.0
06DE:  BTFSC  01.7
06E0:  BRA    06EA
06E2:  RLCF   02,F
06E4:  RLCF   01,F
06E6:  DECF   00,F
06E8:  BRA    06DC
06EA:  BTFSC  x7A.7
06EC:  BRA    06F0
06EE:  BCF    01.7
06F0:  RETURN 0
*
0A32:  MOVLW  8E
0A34:  MOVWF  00
0A36:  MOVF   x83,W
0A38:  SUBWF  00,F
0A3A:  MOVFF  84,02
0A3E:  MOVFF  85,01
0A42:  BSF    02.7
0A44:  MOVF   00,F
0A46:  BZ    0A5A
0A48:  BCF    FD8.0
0A4A:  MOVF   02,F
0A4C:  BNZ   0A52
0A4E:  MOVF   01,F
0A50:  BZ    0A5A
0A52:  RRCF   02,F
0A54:  RRCF   01,F
0A56:  DECFSZ 00,F
0A58:  BRA    0A48
0A5A:  BTFSS  x84.7
0A5C:  BRA    0A68
0A5E:  COMF   01,F
0A60:  COMF   02,F
0A62:  INCF   01,F
0A64:  BTFSC  FD8.2
0A66:  INCF   02,F
0A68:  RETURN 0
*
1988:  MOVF   58,W
198A:  CLRF   01
198C:  SUBWF  57,W
198E:  BC    1996
1990:  MOVFF  57,00
1994:  BRA    19AE
1996:  CLRF   00
1998:  MOVLW  08
199A:  MOVWF  59
199C:  RLCF   57,F
199E:  RLCF   00,F
19A0:  MOVF   58,W
19A2:  SUBWF  00,W
19A4:  BTFSC  FD8.0
19A6:  MOVWF  00
19A8:  RLCF   01,F
19AA:  DECFSZ 59,F
19AC:  BRA    199C
19AE:  RETURN 0
*
1A3C:  MOVF   FEF,F
1A3E:  BZ    1A5E
1A40:  MOVFF  FEA,58
1A44:  MOVFF  FE9,57
1A48:  MOVFF  FEF,5A
1A4C:  RCALL  1A20
1A4E:  MOVFF  58,FEA
1A52:  MOVFF  57,FE9
1A56:  INCF   FE9,F
1A58:  BTFSC  FD8.2
1A5A:  INCF   FEA,F
1A5C:  BRA    1A3C
1A5E:  GOTO   1C54 (RETURN)
1A62:  TBLRD*+
1A64:  MOVF   FF5,F
1A66:  BZ    1A80
1A68:  MOVFF  FF6,58
1A6C:  MOVFF  FF7,59
1A70:  MOVFF  FF5,5A
1A74:  RCALL  1A20
1A76:  MOVFF  58,FF6
1A7A:  MOVFF  59,FF7
1A7E:  BRA    1A62
1A80:  GOTO   1AB4 (RETURN)
....................  
.................... #list 
....................  
.................... #DEVICE ADC =10  // seleciona o conversor a/d com 10 bits 
.................... #INCLUDE <stdlib.h>   
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <math.h> //  Inclui a biblioteca responsavel por fornecer funções de calculos matematicos  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
0A6A:  BCF    x82.0
....................    y = x; 
0A6C:  MOVFF  76,7B
0A70:  MOVFF  75,7A
0A74:  MOVFF  74,79
0A78:  MOVFF  73,78
....................  
....................    if (x < 0) 
0A7C:  MOVFF  76,86
0A80:  MOVFF  75,85
0A84:  MOVFF  74,84
0A88:  MOVFF  73,83
0A8C:  CLRF   x8A
0A8E:  CLRF   x89
0A90:  CLRF   x88
0A92:  CLRF   x87
0A94:  RCALL  0634
0A96:  BNC   0AA0
....................    { 
....................       s = 1; 
0A98:  BSF    x82.0
....................       y = -y; 
0A9A:  MOVF   x79,W
0A9C:  XORLW  80
0A9E:  MOVWF  x79
....................    } 
....................  
....................    if (y <= 32768.0) 
0AA0:  MOVFF  7B,86
0AA4:  MOVFF  7A,85
0AA8:  MOVFF  79,84
0AAC:  MOVFF  78,83
0AB0:  CLRF   x8A
0AB2:  CLRF   x89
0AB4:  CLRF   x88
0AB6:  MOVLW  8E
0AB8:  MOVWF  x87
0ABA:  RCALL  0634
0ABC:  BC    0AC0
0ABE:  BNZ   0AF0
....................       res = (float32)(unsigned int16)y; 
0AC0:  MOVFF  7B,86
0AC4:  MOVFF  7A,85
0AC8:  MOVFF  79,84
0ACC:  MOVFF  78,83
0AD0:  RCALL  0A32
0AD2:  MOVFF  02,88
0AD6:  MOVFF  01,87
0ADA:  CALL   0148
0ADE:  MOVFF  03,7F
0AE2:  MOVFF  02,7E
0AE6:  MOVFF  01,7D
0AEA:  MOVFF  00,7C
0AEE:  BRA    0C7A
....................  
....................  else if (y < 10000000.0) 
0AF0:  MOVFF  7B,86
0AF4:  MOVFF  7A,85
0AF8:  MOVFF  79,84
0AFC:  MOVFF  78,83
0B00:  MOVLW  80
0B02:  MOVWF  x8A
0B04:  MOVLW  96
0B06:  MOVWF  x89
0B08:  MOVLW  18
0B0A:  MOVWF  x88
0B0C:  MOVLW  96
0B0E:  MOVWF  x87
0B10:  RCALL  0634
0B12:  BTFSS  FD8.0
0B14:  BRA    0C6A
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
0B16:  MOVFF  7B,86
0B1A:  MOVFF  7A,85
0B1E:  MOVFF  79,84
0B22:  MOVFF  78,83
0B26:  CLRF   x8A
0B28:  CLRF   x89
0B2A:  CLRF   x88
0B2C:  MOVLW  70
0B2E:  MOVWF  x87
0B30:  CALL   017E
0B34:  MOVFF  03,86
0B38:  MOVFF  02,85
0B3C:  MOVFF  01,84
0B40:  MOVFF  00,83
0B44:  RCALL  0A32
0B46:  MOVFF  02,81
0B4A:  MOVFF  01,80
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
0B4E:  MOVFF  7B,86
0B52:  MOVFF  7A,85
0B56:  MOVFF  79,84
0B5A:  MOVFF  78,83
0B5E:  CLRF   x8A
0B60:  CLRF   x89
0B62:  CLRF   x88
0B64:  MOVLW  70
0B66:  MOVWF  x87
0B68:  CALL   017E
0B6C:  MOVFF  03,86
0B70:  MOVFF  02,85
0B74:  MOVFF  01,84
0B78:  MOVFF  00,83
0B7C:  MOVFF  81,88
0B80:  MOVFF  80,87
0B84:  CALL   0148
0B88:  BSF    FD8.1
0B8A:  MOVFF  86,8A
0B8E:  MOVFF  85,89
0B92:  MOVFF  84,88
0B96:  MOVFF  83,87
0B9A:  MOVFF  03,8E
0B9E:  MOVFF  02,8D
0BA2:  MOVFF  01,8C
0BA6:  MOVFF  00,8B
0BAA:  RCALL  03CA
0BAC:  CLRF   x86
0BAE:  CLRF   x85
0BB0:  CLRF   x84
0BB2:  MOVLW  8E
0BB4:  MOVWF  x83
0BB6:  MOVFF  03,8A
0BBA:  MOVFF  02,89
0BBE:  MOVFF  01,88
0BC2:  MOVFF  00,87
0BC6:  CALL   017E
0BCA:  MOVFF  03,7B
0BCE:  MOVFF  02,7A
0BD2:  MOVFF  01,79
0BD6:  MOVFF  00,78
....................       res = 32768.0*(float32)l; 
0BDA:  MOVFF  81,88
0BDE:  MOVFF  80,87
0BE2:  CALL   0148
0BE6:  CLRF   x86
0BE8:  CLRF   x85
0BEA:  CLRF   x84
0BEC:  MOVLW  8E
0BEE:  MOVWF  x83
0BF0:  MOVFF  03,8A
0BF4:  MOVFF  02,89
0BF8:  MOVFF  01,88
0BFC:  MOVFF  00,87
0C00:  CALL   017E
0C04:  MOVFF  03,7F
0C08:  MOVFF  02,7E
0C0C:  MOVFF  01,7D
0C10:  MOVFF  00,7C
....................       res += (float32)(unsigned int16)y; 
0C14:  MOVFF  7B,86
0C18:  MOVFF  7A,85
0C1C:  MOVFF  79,84
0C20:  MOVFF  78,83
0C24:  RCALL  0A32
0C26:  MOVFF  02,88
0C2A:  MOVFF  01,87
0C2E:  CALL   0148
0C32:  BCF    FD8.1
0C34:  MOVFF  7F,8A
0C38:  MOVFF  7E,89
0C3C:  MOVFF  7D,88
0C40:  MOVFF  7C,87
0C44:  MOVFF  03,8E
0C48:  MOVFF  02,8D
0C4C:  MOVFF  01,8C
0C50:  MOVFF  00,8B
0C54:  CALL   03CA
0C58:  MOVFF  03,7F
0C5C:  MOVFF  02,7E
0C60:  MOVFF  01,7D
0C64:  MOVFF  00,7C
....................    } 
0C68:  BRA    0C7A
....................  
....................  else 
....................   res = y; 
0C6A:  MOVFF  7B,7F
0C6E:  MOVFF  7A,7E
0C72:  MOVFF  79,7D
0C76:  MOVFF  78,7C
....................  
....................  y = y - (float32)(unsigned int16)y; 
0C7A:  MOVFF  7B,86
0C7E:  MOVFF  7A,85
0C82:  MOVFF  79,84
0C86:  MOVFF  78,83
0C8A:  RCALL  0A32
0C8C:  MOVFF  02,88
0C90:  MOVFF  01,87
0C94:  CALL   0148
0C98:  BSF    FD8.1
0C9A:  MOVFF  7B,8A
0C9E:  MOVFF  7A,89
0CA2:  MOVFF  79,88
0CA6:  MOVFF  78,87
0CAA:  MOVFF  03,8E
0CAE:  MOVFF  02,8D
0CB2:  MOVFF  01,8C
0CB6:  MOVFF  00,8B
0CBA:  CALL   03CA
0CBE:  MOVFF  03,7B
0CC2:  MOVFF  02,7A
0CC6:  MOVFF  01,79
0CCA:  MOVFF  00,78
....................  
....................  if (s) 
0CCE:  BTFSS  x82.0
0CD0:  BRA    0CD8
....................   res = -res; 
0CD2:  MOVF   x7D,W
0CD4:  XORLW  80
0CD6:  MOVWF  x7D
....................  
....................  if (y != 0) 
0CD8:  MOVFF  7B,86
0CDC:  MOVFF  7A,85
0CE0:  MOVFF  79,84
0CE4:  MOVFF  78,83
0CE8:  CLRF   x8A
0CEA:  CLRF   x89
0CEC:  CLRF   x88
0CEE:  CLRF   x87
0CF0:  RCALL  0634
0CF2:  BZ    0D64
....................  { 
....................   if (s == 1 && n == 0) 
0CF4:  BTFSS  x82.0
0CF6:  BRA    0D2C
0CF8:  MOVF   x77,F
0CFA:  BNZ   0D2C
....................    res -= 1.0; 
0CFC:  BSF    FD8.1
0CFE:  MOVFF  7F,8A
0D02:  MOVFF  7E,89
0D06:  MOVFF  7D,88
0D0A:  MOVFF  7C,87
0D0E:  CLRF   x8E
0D10:  CLRF   x8D
0D12:  CLRF   x8C
0D14:  MOVLW  7F
0D16:  MOVWF  x8B
0D18:  CALL   03CA
0D1C:  MOVFF  03,7F
0D20:  MOVFF  02,7E
0D24:  MOVFF  01,7D
0D28:  MOVFF  00,7C
....................  
....................   if (s == 0 && n == 1) 
0D2C:  BTFSC  x82.0
0D2E:  BRA    0D64
0D30:  DECFSZ x77,W
0D32:  BRA    0D64
....................    res += 1.0; 
0D34:  BCF    FD8.1
0D36:  MOVFF  7F,8A
0D3A:  MOVFF  7E,89
0D3E:  MOVFF  7D,88
0D42:  MOVFF  7C,87
0D46:  CLRF   x8E
0D48:  CLRF   x8D
0D4A:  CLRF   x8C
0D4C:  MOVLW  7F
0D4E:  MOVWF  x8B
0D50:  CALL   03CA
0D54:  MOVFF  03,7F
0D58:  MOVFF  02,7E
0D5C:  MOVFF  01,7D
0D60:  MOVFF  00,7C
....................  } 
....................  if (x == 0) 
0D64:  MOVFF  76,86
0D68:  MOVFF  75,85
0D6C:  MOVFF  74,84
0D70:  MOVFF  73,83
0D74:  CLRF   x8A
0D76:  CLRF   x89
0D78:  CLRF   x88
0D7A:  CLRF   x87
0D7C:  RCALL  0634
0D7E:  BNZ   0D88
....................     res = 0; 
0D80:  CLRF   x7F
0D82:  CLRF   x7E
0D84:  CLRF   x7D
0D86:  CLRF   x7C
....................  
....................  return (res); 
0D88:  MOVFF  7C,00
0D8C:  MOVFF  7D,01
0D90:  MOVFF  7E,02
0D94:  MOVFF  7F,03
0D98:  RETURN 0
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
*
0DB4:  MOVFF  72,76
0DB8:  MOVFF  71,75
0DBC:  MOVFF  70,74
0DC0:  MOVFF  6F,73
0DC4:  CLRF   x77
0DC6:  RCALL  0A6A
0DC8:  GOTO   0ECA (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
0D9A:  MOVFF  72,76
0D9E:  MOVFF  71,75
0DA2:  MOVFF  70,74
0DA6:  MOVFF  6F,73
0DAA:  MOVLW  01
0DAC:  MOVWF  x77
0DAE:  RCALL  0A6A
0DB0:  GOTO   0E82 (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
*
0DCC:  MOVFF  66,86
0DD0:  MOVFF  65,85
0DD4:  MOVFF  64,84
0DD8:  MOVFF  63,83
0DDC:  CLRF   x8A
0DDE:  CLRF   x89
0DE0:  CLRF   x88
0DE2:  CLRF   x87
0DE4:  RCALL  0634
0DE6:  BTFSC  FD8.2
0DE8:  BRA    0F26
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
0DEA:  MOVFF  62,7F
0DEE:  MOVFF  61,7E
0DF2:  MOVFF  60,7D
0DF6:  MOVFF  5F,7C
0DFA:  MOVFF  66,83
0DFE:  MOVFF  65,82
0E02:  MOVFF  64,81
0E06:  MOVFF  63,80
0E0A:  CALL   0270
0E0E:  MOVFF  03,6E
0E12:  MOVFF  02,6D
0E16:  MOVFF  01,6C
0E1A:  MOVFF  00,6B
0E1E:  MOVFF  03,86
0E22:  MOVFF  02,85
0E26:  MOVFF  01,84
0E2A:  MOVFF  00,83
0E2E:  CLRF   x8A
0E30:  CLRF   x89
0E32:  CLRF   x88
0E34:  CLRF   x87
0E36:  CALL   0634
0E3A:  BNC   0E84
0E3C:  MOVFF  62,7F
0E40:  MOVFF  61,7E
0E44:  MOVFF  60,7D
0E48:  MOVFF  5F,7C
0E4C:  MOVFF  66,83
0E50:  MOVFF  65,82
0E54:  MOVFF  64,81
0E58:  MOVFF  63,80
0E5C:  CALL   0270
0E60:  MOVFF  03,6E
0E64:  MOVFF  02,6D
0E68:  MOVFF  01,6C
0E6C:  MOVFF  00,6B
0E70:  MOVFF  03,72
0E74:  MOVFF  02,71
0E78:  MOVFF  01,70
0E7C:  MOVFF  00,6F
0E80:  BRA    0D9A
0E82:  BRA    0ECA
0E84:  MOVFF  62,7F
0E88:  MOVFF  61,7E
0E8C:  MOVFF  60,7D
0E90:  MOVFF  5F,7C
0E94:  MOVFF  66,83
0E98:  MOVFF  65,82
0E9C:  MOVFF  64,81
0EA0:  MOVFF  63,80
0EA4:  CALL   0270
0EA8:  MOVFF  03,6E
0EAC:  MOVFF  02,6D
0EB0:  MOVFF  01,6C
0EB4:  MOVFF  00,6B
0EB8:  MOVFF  03,72
0EBC:  MOVFF  02,71
0EC0:  MOVFF  01,70
0EC4:  MOVFF  00,6F
0EC8:  BRA    0DB4
0ECA:  MOVFF  03,6A
0ECE:  MOVFF  02,69
0ED2:  MOVFF  01,68
0ED6:  MOVFF  00,67
....................       return(x-(i*y)); 
0EDA:  MOVFF  6A,86
0EDE:  MOVFF  69,85
0EE2:  MOVFF  68,84
0EE6:  MOVFF  67,83
0EEA:  MOVFF  66,8A
0EEE:  MOVFF  65,89
0EF2:  MOVFF  64,88
0EF6:  MOVFF  63,87
0EFA:  CALL   017E
0EFE:  BSF    FD8.1
0F00:  MOVFF  62,8A
0F04:  MOVFF  61,89
0F08:  MOVFF  60,88
0F0C:  MOVFF  5F,87
0F10:  MOVFF  03,8E
0F14:  MOVFF  02,8D
0F18:  MOVFF  01,8C
0F1C:  MOVFF  00,8B
0F20:  CALL   03CA
0F24:  BRA    0F26
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
0F26:  RETURN 0
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
0F28:  MOVFF  66,86
0F2C:  MOVFF  65,85
0F30:  MOVFF  64,84
0F34:  MOVFF  63,83
0F38:  MOVLW  3B
0F3A:  MOVWF  x8A
0F3C:  MOVLW  AA
0F3E:  MOVWF  x89
0F40:  MOVLW  38
0F42:  MOVWF  x88
0F44:  MOVLW  7F
0F46:  MOVWF  x87
0F48:  CALL   017E
0F4C:  MOVFF  03,86
0F50:  MOVFF  02,85
0F54:  MOVFF  01,84
0F58:  MOVFF  00,83
0F5C:  RCALL  0A32
0F5E:  MOVFF  01,73
....................    s = 0; 
0F62:  BCF    x74.0
....................    y = x; 
0F64:  MOVFF  66,6A
0F68:  MOVFF  65,69
0F6C:  MOVFF  64,68
0F70:  MOVFF  63,67
....................  
....................    if (x < 0) 
0F74:  MOVFF  66,86
0F78:  MOVFF  65,85
0F7C:  MOVFF  64,84
0F80:  MOVFF  63,83
0F84:  CLRF   x8A
0F86:  CLRF   x89
0F88:  CLRF   x88
0F8A:  CLRF   x87
0F8C:  CALL   0634
0F90:  BNC   0F9C
....................    { 
....................       s = 1; 
0F92:  BSF    x74.0
....................       n = -n; 
0F94:  NEGF   x73
....................       y = -y; 
0F96:  MOVF   x68,W
0F98:  XORLW  80
0F9A:  MOVWF  x68
....................    } 
....................  
....................    res = 0.0; 
0F9C:  CLRF   x6E
0F9E:  CLRF   x6D
0FA0:  CLRF   x6C
0FA2:  CLRF   x6B
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
0FA4:  CLRF   x76
0FA6:  MOVLW  6B
0FA8:  MOVWF  FE9
0FAA:  MOVFF  76,FEA
0FAE:  MOVLW  7F
0FB0:  ADDWF  x73,W
0FB2:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
0FB4:  MOVFF  6A,86
0FB8:  MOVFF  69,85
0FBC:  MOVFF  68,84
0FC0:  MOVFF  67,83
0FC4:  MOVLW  3B
0FC6:  MOVWF  x8A
0FC8:  MOVLW  AA
0FCA:  MOVWF  x89
0FCC:  MOVLW  38
0FCE:  MOVWF  x88
0FD0:  MOVLW  7F
0FD2:  MOVWF  x87
0FD4:  CALL   017E
0FD8:  MOVFF  03,78
0FDC:  MOVFF  02,77
0FE0:  MOVFF  01,76
0FE4:  MOVFF  00,75
0FE8:  CLRF   x7A
0FEA:  MOVFF  73,79
0FEE:  BTFSC  x79.7
0FF0:  DECF   x7A,F
0FF2:  CALL   06AA
0FF6:  BSF    FD8.1
0FF8:  MOVFF  78,8A
0FFC:  MOVFF  77,89
1000:  MOVFF  76,88
1004:  MOVFF  75,87
1008:  MOVFF  03,8E
100C:  MOVFF  02,8D
1010:  MOVFF  01,8C
1014:  MOVFF  00,8B
1018:  CALL   03CA
101C:  MOVFF  03,6A
1020:  MOVFF  02,69
1024:  MOVFF  01,68
1028:  MOVFF  00,67
....................  
....................    r = pe[0]*y + pe[1]; 
102C:  MOVLW  7C
102E:  MOVWF  x86
1030:  MOVLW  88
1032:  MOVWF  x85
1034:  MOVLW  59
1036:  MOVWF  x84
1038:  MOVLW  72
103A:  MOVWF  x83
103C:  MOVFF  6A,8A
1040:  MOVFF  69,89
1044:  MOVFF  68,88
1048:  MOVFF  67,87
104C:  CALL   017E
1050:  MOVFF  03,78
1054:  MOVFF  02,77
1058:  MOVFF  01,76
105C:  MOVFF  00,75
1060:  BCF    FD8.1
1062:  MOVFF  03,8A
1066:  MOVFF  02,89
106A:  MOVFF  01,88
106E:  MOVFF  00,87
1072:  MOVLW  E0
1074:  MOVWF  x8E
1076:  MOVLW  97
1078:  MOVWF  x8D
107A:  MOVLW  26
107C:  MOVWF  x8C
107E:  MOVLW  75
1080:  MOVWF  x8B
1082:  CALL   03CA
1086:  MOVFF  03,72
108A:  MOVFF  02,71
108E:  MOVFF  01,70
1092:  MOVFF  00,6F
....................    r = r*y + pe[2]; 
1096:  MOVFF  72,86
109A:  MOVFF  71,85
109E:  MOVFF  70,84
10A2:  MOVFF  6F,83
10A6:  MOVFF  6A,8A
10AA:  MOVFF  69,89
10AE:  MOVFF  68,88
10B2:  MOVFF  67,87
10B6:  CALL   017E
10BA:  MOVFF  03,78
10BE:  MOVFF  02,77
10C2:  MOVFF  01,76
10C6:  MOVFF  00,75
10CA:  BCF    FD8.1
10CC:  MOVFF  03,8A
10D0:  MOVFF  02,89
10D4:  MOVFF  01,88
10D8:  MOVFF  00,87
10DC:  MOVLW  C4
10DE:  MOVWF  x8E
10E0:  MOVLW  1D
10E2:  MOVWF  x8D
10E4:  MOVLW  1E
10E6:  MOVWF  x8C
10E8:  MOVLW  78
10EA:  MOVWF  x8B
10EC:  CALL   03CA
10F0:  MOVFF  03,72
10F4:  MOVFF  02,71
10F8:  MOVFF  01,70
10FC:  MOVFF  00,6F
....................    r = r*y + pe[3]; 
1100:  MOVFF  72,86
1104:  MOVFF  71,85
1108:  MOVFF  70,84
110C:  MOVFF  6F,83
1110:  MOVFF  6A,8A
1114:  MOVFF  69,89
1118:  MOVFF  68,88
111C:  MOVFF  67,87
1120:  CALL   017E
1124:  MOVFF  03,78
1128:  MOVFF  02,77
112C:  MOVFF  01,76
1130:  MOVFF  00,75
1134:  BCF    FD8.1
1136:  MOVFF  03,8A
113A:  MOVFF  02,89
113E:  MOVFF  01,88
1142:  MOVFF  00,87
1146:  MOVLW  5E
1148:  MOVWF  x8E
114A:  MOVLW  50
114C:  MOVWF  x8D
114E:  MOVLW  63
1150:  MOVWF  x8C
1152:  MOVLW  7A
1154:  MOVWF  x8B
1156:  CALL   03CA
115A:  MOVFF  03,72
115E:  MOVFF  02,71
1162:  MOVFF  01,70
1166:  MOVFF  00,6F
....................    r = r*y + pe[4]; 
116A:  MOVFF  72,86
116E:  MOVFF  71,85
1172:  MOVFF  70,84
1176:  MOVFF  6F,83
117A:  MOVFF  6A,8A
117E:  MOVFF  69,89
1182:  MOVFF  68,88
1186:  MOVFF  67,87
118A:  CALL   017E
118E:  MOVFF  03,78
1192:  MOVFF  02,77
1196:  MOVFF  01,76
119A:  MOVFF  00,75
119E:  BCF    FD8.1
11A0:  MOVFF  03,8A
11A4:  MOVFF  02,89
11A8:  MOVFF  01,88
11AC:  MOVFF  00,87
11B0:  MOVLW  1A
11B2:  MOVWF  x8E
11B4:  MOVLW  FE
11B6:  MOVWF  x8D
11B8:  MOVLW  75
11BA:  MOVWF  x8C
11BC:  MOVLW  7C
11BE:  MOVWF  x8B
11C0:  CALL   03CA
11C4:  MOVFF  03,72
11C8:  MOVFF  02,71
11CC:  MOVFF  01,70
11D0:  MOVFF  00,6F
....................    r = r*y + pe[5]; 
11D4:  MOVFF  72,86
11D8:  MOVFF  71,85
11DC:  MOVFF  70,84
11E0:  MOVFF  6F,83
11E4:  MOVFF  6A,8A
11E8:  MOVFF  69,89
11EC:  MOVFF  68,88
11F0:  MOVFF  67,87
11F4:  CALL   017E
11F8:  MOVFF  03,78
11FC:  MOVFF  02,77
1200:  MOVFF  01,76
1204:  MOVFF  00,75
1208:  BCF    FD8.1
120A:  MOVFF  03,8A
120E:  MOVFF  02,89
1212:  MOVFF  01,88
1216:  MOVFF  00,87
121A:  MOVLW  18
121C:  MOVWF  x8E
121E:  MOVLW  72
1220:  MOVWF  x8D
1222:  MOVLW  31
1224:  MOVWF  x8C
1226:  MOVLW  7E
1228:  MOVWF  x8B
122A:  CALL   03CA
122E:  MOVFF  03,72
1232:  MOVFF  02,71
1236:  MOVFF  01,70
123A:  MOVFF  00,6F
....................  
....................    res = res*(1.0 + y*r); 
123E:  MOVFF  6A,86
1242:  MOVFF  69,85
1246:  MOVFF  68,84
124A:  MOVFF  67,83
124E:  MOVFF  72,8A
1252:  MOVFF  71,89
1256:  MOVFF  70,88
125A:  MOVFF  6F,87
125E:  CALL   017E
1262:  BCF    FD8.1
1264:  CLRF   x8A
1266:  CLRF   x89
1268:  CLRF   x88
126A:  MOVLW  7F
126C:  MOVWF  x87
126E:  MOVFF  03,8E
1272:  MOVFF  02,8D
1276:  MOVFF  01,8C
127A:  MOVFF  00,8B
127E:  CALL   03CA
1282:  MOVFF  6E,86
1286:  MOVFF  6D,85
128A:  MOVFF  6C,84
128E:  MOVFF  6B,83
1292:  MOVFF  03,8A
1296:  MOVFF  02,89
129A:  MOVFF  01,88
129E:  MOVFF  00,87
12A2:  CALL   017E
12A6:  MOVFF  03,6E
12AA:  MOVFF  02,6D
12AE:  MOVFF  01,6C
12B2:  MOVFF  00,6B
....................  
....................    if (s) 
12B6:  BTFSS  x74.0
12B8:  BRA    12E8
....................       res = 1.0/res; 
12BA:  CLRF   x7F
12BC:  CLRF   x7E
12BE:  CLRF   x7D
12C0:  MOVLW  7F
12C2:  MOVWF  x7C
12C4:  MOVFF  6E,83
12C8:  MOVFF  6D,82
12CC:  MOVFF  6C,81
12D0:  MOVFF  6B,80
12D4:  CALL   0270
12D8:  MOVFF  03,6E
12DC:  MOVFF  02,6D
12E0:  MOVFF  01,6C
12E4:  MOVFF  00,6B
....................    return(res); 
12E8:  MOVFF  6B,00
12EC:  MOVFF  6C,01
12F0:  MOVFF  6D,02
12F4:  MOVFF  6E,03
12F8:  RETURN 0
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
*
06F2:  MOVFF  66,6A
06F6:  MOVFF  65,69
06FA:  MOVFF  64,68
06FE:  MOVFF  63,67
....................  
....................    if (y != 1.0) 
0702:  MOVFF  6A,86
0706:  MOVFF  69,85
070A:  MOVFF  68,84
070E:  MOVFF  67,83
0712:  CLRF   x8A
0714:  CLRF   x89
0716:  CLRF   x88
0718:  MOVLW  7F
071A:  MOVWF  x87
071C:  RCALL  0634
071E:  BTFSC  FD8.2
0720:  BRA    0A18
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
0722:  CLRF   x79
0724:  MOVLW  67
0726:  MOVWF  FE9
0728:  MOVFF  79,FEA
072C:  MOVLW  7E
072E:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
0730:  BSF    FD8.1
0732:  MOVFF  6A,8A
0736:  MOVFF  69,89
073A:  MOVFF  68,88
073E:  MOVFF  67,87
0742:  CLRF   x8E
0744:  CLRF   x8D
0746:  CLRF   x8C
0748:  MOVLW  7F
074A:  MOVWF  x8B
074C:  RCALL  03CA
074E:  MOVFF  03,7B
0752:  MOVFF  02,7A
0756:  MOVFF  01,79
075A:  MOVFF  00,78
075E:  BCF    FD8.1
0760:  MOVFF  6A,8A
0764:  MOVFF  69,89
0768:  MOVFF  68,88
076C:  MOVFF  67,87
0770:  CLRF   x8E
0772:  CLRF   x8D
0774:  CLRF   x8C
0776:  MOVLW  7F
0778:  MOVWF  x8B
077A:  RCALL  03CA
077C:  MOVFF  7B,7F
0780:  MOVFF  7A,7E
0784:  MOVFF  79,7D
0788:  MOVFF  78,7C
078C:  MOVFF  03,83
0790:  MOVFF  02,82
0794:  MOVFF  01,81
0798:  MOVFF  00,80
079C:  RCALL  0270
079E:  MOVFF  03,6A
07A2:  MOVFF  02,69
07A6:  MOVFF  01,68
07AA:  MOVFF  00,67
....................  
....................       y2=y*y; 
07AE:  MOVFF  6A,86
07B2:  MOVFF  69,85
07B6:  MOVFF  68,84
07BA:  MOVFF  67,83
07BE:  MOVFF  6A,8A
07C2:  MOVFF  69,89
07C6:  MOVFF  68,88
07CA:  MOVFF  67,87
07CE:  RCALL  017E
07D0:  MOVFF  03,76
07D4:  MOVFF  02,75
07D8:  MOVFF  01,74
07DC:  MOVFF  00,73
....................  
....................       res = pl[0]*y2 + pl[1]; 
07E0:  MOVLW  99
07E2:  MOVWF  x86
07E4:  MOVLW  47
07E6:  MOVWF  x85
07E8:  MOVLW  8A
07EA:  MOVWF  x84
07EC:  MOVLW  7F
07EE:  MOVWF  x83
07F0:  MOVFF  76,8A
07F4:  MOVFF  75,89
07F8:  MOVFF  74,88
07FC:  MOVFF  73,87
0800:  RCALL  017E
0802:  MOVFF  03,7B
0806:  MOVFF  02,7A
080A:  MOVFF  01,79
080E:  MOVFF  00,78
0812:  BCF    FD8.1
0814:  MOVFF  03,8A
0818:  MOVFF  02,89
081C:  MOVFF  01,88
0820:  MOVFF  00,87
0824:  CLRF   x8E
0826:  CLRF   x8D
0828:  CLRF   x8C
082A:  MOVLW  80
082C:  MOVWF  x8B
082E:  RCALL  03CA
0830:  MOVFF  03,6E
0834:  MOVFF  02,6D
0838:  MOVFF  01,6C
083C:  MOVFF  00,6B
....................  
....................       r = ql[0]*y2 + ql[1]; 
0840:  MOVLW  4C
0842:  MOVWF  x86
0844:  MOVLW  F3
0846:  MOVWF  x85
0848:  MOVLW  3A
084A:  MOVWF  x84
084C:  MOVLW  7B
084E:  MOVWF  x83
0850:  MOVFF  76,8A
0854:  MOVFF  75,89
0858:  MOVFF  74,88
085C:  MOVFF  73,87
0860:  RCALL  017E
0862:  MOVFF  03,7B
0866:  MOVFF  02,7A
086A:  MOVFF  01,79
086E:  MOVFF  00,78
0872:  BCF    FD8.1
0874:  MOVFF  03,8A
0878:  MOVFF  02,89
087C:  MOVFF  01,88
0880:  MOVFF  00,87
0884:  MOVLW  2B
0886:  MOVWF  x8E
0888:  MOVLW  9D
088A:  MOVWF  x8D
088C:  MOVLW  DF
088E:  MOVWF  x8C
0890:  MOVLW  7E
0892:  MOVWF  x8B
0894:  RCALL  03CA
0896:  MOVFF  03,72
089A:  MOVFF  02,71
089E:  MOVFF  01,70
08A2:  MOVFF  00,6F
....................       r = r*y2 + 1.0; 
08A6:  MOVFF  72,86
08AA:  MOVFF  71,85
08AE:  MOVFF  70,84
08B2:  MOVFF  6F,83
08B6:  MOVFF  76,8A
08BA:  MOVFF  75,89
08BE:  MOVFF  74,88
08C2:  MOVFF  73,87
08C6:  RCALL  017E
08C8:  MOVFF  03,7B
08CC:  MOVFF  02,7A
08D0:  MOVFF  01,79
08D4:  MOVFF  00,78
08D8:  BCF    FD8.1
08DA:  MOVFF  03,8A
08DE:  MOVFF  02,89
08E2:  MOVFF  01,88
08E6:  MOVFF  00,87
08EA:  CLRF   x8E
08EC:  CLRF   x8D
08EE:  CLRF   x8C
08F0:  MOVLW  7F
08F2:  MOVWF  x8B
08F4:  RCALL  03CA
08F6:  MOVFF  03,72
08FA:  MOVFF  02,71
08FE:  MOVFF  01,70
0902:  MOVFF  00,6F
....................  
....................       res = y*res/r; 
0906:  MOVFF  6A,86
090A:  MOVFF  69,85
090E:  MOVFF  68,84
0912:  MOVFF  67,83
0916:  MOVFF  6E,8A
091A:  MOVFF  6D,89
091E:  MOVFF  6C,88
0922:  MOVFF  6B,87
0926:  RCALL  017E
0928:  MOVFF  03,7B
092C:  MOVFF  02,7A
0930:  MOVFF  01,79
0934:  MOVFF  00,78
0938:  MOVFF  03,7F
093C:  MOVFF  02,7E
0940:  MOVFF  01,7D
0944:  MOVFF  00,7C
0948:  MOVFF  72,83
094C:  MOVFF  71,82
0950:  MOVFF  70,81
0954:  MOVFF  6F,80
0958:  RCALL  0270
095A:  MOVFF  03,6E
095E:  MOVFF  02,6D
0962:  MOVFF  01,6C
0966:  MOVFF  00,6B
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
096A:  CLRF   x79
096C:  MOVLW  63
096E:  MOVWF  FE9
0970:  MOVFF  79,FEA
0974:  MOVLW  7E
0976:  SUBWF  FEF,W
0978:  MOVWF  x77
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
097A:  BTFSS  x77.7
097C:  BRA    09A2
....................          r = -(float32)-n; 
097E:  MOVLW  00
0980:  BSF    FD8.0
0982:  SUBFWB x77,W
0984:  CLRF   x7A
0986:  MOVWF  x79
0988:  BTFSC  x79.7
098A:  DECF   x7A,F
098C:  RCALL  06AA
098E:  MOVFF  00,6F
0992:  MOVF   01,W
0994:  XORLW  80
0996:  MOVWF  x70
0998:  MOVFF  02,71
099C:  MOVFF  03,72
09A0:  BRA    09BE
....................       else 
....................          r = (float32)n; 
09A2:  CLRF   x7A
09A4:  MOVFF  77,79
09A8:  BTFSC  x79.7
09AA:  DECF   x7A,F
09AC:  RCALL  06AA
09AE:  MOVFF  03,72
09B2:  MOVFF  02,71
09B6:  MOVFF  01,70
09BA:  MOVFF  00,6F
....................  
....................       res += r*LN2; 
09BE:  MOVFF  72,86
09C2:  MOVFF  71,85
09C6:  MOVFF  70,84
09CA:  MOVFF  6F,83
09CE:  MOVLW  18
09D0:  MOVWF  x8A
09D2:  MOVLW  72
09D4:  MOVWF  x89
09D6:  MOVLW  31
09D8:  MOVWF  x88
09DA:  MOVLW  7E
09DC:  MOVWF  x87
09DE:  CALL   017E
09E2:  BCF    FD8.1
09E4:  MOVFF  6E,8A
09E8:  MOVFF  6D,89
09EC:  MOVFF  6C,88
09F0:  MOVFF  6B,87
09F4:  MOVFF  03,8E
09F8:  MOVFF  02,8D
09FC:  MOVFF  01,8C
0A00:  MOVFF  00,8B
0A04:  RCALL  03CA
0A06:  MOVFF  03,6E
0A0A:  MOVFF  02,6D
0A0E:  MOVFF  01,6C
0A12:  MOVFF  00,6B
....................    } 
0A16:  BRA    0A20
....................  
....................    else 
....................       res = 0.0; 
0A18:  CLRF   x6E
0A1A:  CLRF   x6D
0A1C:  CLRF   x6C
0A1E:  CLRF   x6B
....................  
....................    return(res); 
0A20:  MOVFF  6B,00
0A24:  MOVFF  6C,01
0A28:  MOVFF  6D,02
0A2C:  MOVFF  6E,03
0A30:  RETURN 0
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
*
12FA:  MOVFF  5A,86
12FE:  MOVFF  59,85
1302:  MOVFF  58,84
1306:  MOVFF  57,83
130A:  CLRF   x8A
130C:  CLRF   x89
130E:  CLRF   x88
1310:  CLRF   x87
1312:  CALL   0634
1316:  BTFSS  FD8.0
1318:  BRA    14B0
131A:  MOVFF  5E,62
131E:  MOVFF  5D,61
1322:  MOVFF  5C,60
1326:  MOVFF  5B,5F
132A:  CLRF   x66
132C:  CLRF   x65
132E:  CLRF   x64
1330:  MOVLW  7F
1332:  MOVWF  x63
1334:  RCALL  0DCC
1336:  MOVFF  03,62
133A:  MOVFF  02,61
133E:  MOVFF  01,60
1342:  MOVFF  00,5F
1346:  MOVFF  03,86
134A:  MOVFF  02,85
134E:  MOVFF  01,84
1352:  MOVFF  00,83
1356:  CLRF   x8A
1358:  CLRF   x89
135A:  CLRF   x88
135C:  CLRF   x87
135E:  CALL   0634
1362:  BTFSS  FD8.2
1364:  BRA    14B0
....................       if(fmod(y, 2) == 0) { 
1366:  MOVFF  5E,62
136A:  MOVFF  5D,61
136E:  MOVFF  5C,60
1372:  MOVFF  5B,5F
1376:  CLRF   x66
1378:  CLRF   x65
137A:  CLRF   x64
137C:  MOVLW  80
137E:  MOVWF  x63
1380:  RCALL  0DCC
1382:  MOVFF  03,62
1386:  MOVFF  02,61
138A:  MOVFF  01,60
138E:  MOVFF  00,5F
1392:  MOVFF  03,86
1396:  MOVFF  02,85
139A:  MOVFF  01,84
139E:  MOVFF  00,83
13A2:  CLRF   x8A
13A4:  CLRF   x89
13A6:  CLRF   x88
13A8:  CLRF   x87
13AA:  CALL   0634
13AE:  BNZ   142E
....................          return (exp(log(-x) * y)); 
13B0:  MOVFF  57,5F
13B4:  MOVF   58,W
13B6:  XORLW  80
13B8:  MOVWF  x60
13BA:  MOVFF  59,61
13BE:  MOVFF  5A,62
13C2:  MOVFF  5A,66
13C6:  MOVFF  59,65
13CA:  MOVWF  x64
13CC:  MOVFF  57,63
13D0:  CALL   06F2
13D4:  MOVFF  03,62
13D8:  MOVFF  02,61
13DC:  MOVFF  01,60
13E0:  MOVFF  00,5F
13E4:  MOVFF  03,86
13E8:  MOVFF  02,85
13EC:  MOVFF  01,84
13F0:  MOVFF  00,83
13F4:  MOVFF  5E,8A
13F8:  MOVFF  5D,89
13FC:  MOVFF  5C,88
1400:  MOVFF  5B,87
1404:  CALL   017E
1408:  MOVFF  03,62
140C:  MOVFF  02,61
1410:  MOVFF  01,60
1414:  MOVFF  00,5F
1418:  MOVFF  03,66
141C:  MOVFF  02,65
1420:  MOVFF  01,64
1424:  MOVFF  00,63
1428:  RCALL  0F28
142A:  BRA    15CC
....................       } else { 
142C:  BRA    14AE
....................          return (-exp(log(-x) * y)); 
142E:  MOVFF  57,5F
1432:  MOVF   58,W
1434:  XORLW  80
1436:  MOVWF  x60
1438:  MOVFF  59,61
143C:  MOVFF  5A,62
1440:  MOVFF  5A,66
1444:  MOVFF  59,65
1448:  MOVWF  x64
144A:  MOVFF  57,63
144E:  CALL   06F2
1452:  MOVFF  03,62
1456:  MOVFF  02,61
145A:  MOVFF  01,60
145E:  MOVFF  00,5F
1462:  MOVFF  03,86
1466:  MOVFF  02,85
146A:  MOVFF  01,84
146E:  MOVFF  00,83
1472:  MOVFF  5E,8A
1476:  MOVFF  5D,89
147A:  MOVFF  5C,88
147E:  MOVFF  5B,87
1482:  CALL   017E
1486:  MOVFF  03,62
148A:  MOVFF  02,61
148E:  MOVFF  01,60
1492:  MOVFF  00,5F
1496:  MOVFF  03,66
149A:  MOVFF  02,65
149E:  MOVFF  01,64
14A2:  MOVFF  00,63
14A6:  RCALL  0F28
14A8:  MOVLW  80
14AA:  XORWF  01,F
14AC:  BRA    15CC
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
14AE:  BRA    15CC
14B0:  MOVFF  5A,86
14B4:  MOVFF  59,85
14B8:  MOVFF  58,84
14BC:  MOVFF  57,83
14C0:  CLRF   x8A
14C2:  CLRF   x89
14C4:  CLRF   x88
14C6:  CLRF   x87
14C8:  CALL   0634
14CC:  BNC   1524
14CE:  MOVFF  5E,62
14D2:  MOVFF  5D,61
14D6:  MOVFF  5C,60
14DA:  MOVFF  5B,5F
14DE:  CLRF   x66
14E0:  CLRF   x65
14E2:  CLRF   x64
14E4:  MOVLW  7F
14E6:  MOVWF  x63
14E8:  RCALL  0DCC
14EA:  MOVFF  03,62
14EE:  MOVFF  02,61
14F2:  MOVFF  01,60
14F6:  MOVFF  00,5F
14FA:  MOVFF  03,86
14FE:  MOVFF  02,85
1502:  MOVFF  01,84
1506:  MOVFF  00,83
150A:  CLRF   x8A
150C:  CLRF   x89
150E:  CLRF   x88
1510:  CLRF   x87
1512:  CALL   0634
1516:  BZ    1524
....................       return 0; 
1518:  CLRF   00
151A:  CLRF   01
151C:  CLRF   02
151E:  CLRF   03
1520:  BRA    15CC
....................    } else { 
1522:  BRA    15CC
....................       if(x != 0 || 0 >= y) { 
1524:  MOVFF  5A,86
1528:  MOVFF  59,85
152C:  MOVFF  58,84
1530:  MOVFF  57,83
1534:  CLRF   x8A
1536:  CLRF   x89
1538:  CLRF   x88
153A:  CLRF   x87
153C:  CALL   0634
1540:  BNZ   1562
1542:  MOVFF  5E,86
1546:  MOVFF  5D,85
154A:  MOVFF  5C,84
154E:  MOVFF  5B,83
1552:  CLRF   x8A
1554:  CLRF   x89
1556:  CLRF   x88
1558:  CLRF   x87
155A:  CALL   0634
155E:  BC    1562
1560:  BNZ   15CC
....................          return (exp(log(x) * y)); 
1562:  MOVFF  5A,66
1566:  MOVFF  59,65
156A:  MOVFF  58,64
156E:  MOVFF  57,63
1572:  CALL   06F2
1576:  MOVFF  03,62
157A:  MOVFF  02,61
157E:  MOVFF  01,60
1582:  MOVFF  00,5F
1586:  MOVFF  03,86
158A:  MOVFF  02,85
158E:  MOVFF  01,84
1592:  MOVFF  00,83
1596:  MOVFF  5E,8A
159A:  MOVFF  5D,89
159E:  MOVFF  5C,88
15A2:  MOVFF  5B,87
15A6:  CALL   017E
15AA:  MOVFF  03,62
15AE:  MOVFF  02,61
15B2:  MOVFF  01,60
15B6:  MOVFF  00,5F
15BA:  MOVFF  03,66
15BE:  MOVFF  02,65
15C2:  MOVFF  01,64
15C6:  MOVFF  00,63
15CA:  RCALL  0F28
....................       } 
....................    } 
15CC:  GOTO   1774 (RETURN)
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #fuses HS,NOWDT,PUT,NOBROWNOUT,NOLVP   // configuração dos fuses do pic  
.................... #use   delay(clock=20000000)// Informa a função delay, o clock utilizado 
*
00DA:  CLRF   FEA
00DC:  MOVLW  59
00DE:  MOVWF  FE9
00E0:  MOVF   FEF,W
00E2:  BZ    00FE
00E4:  MOVLW  06
00E6:  MOVWF  01
00E8:  CLRF   00
00EA:  DECFSZ 00,F
00EC:  BRA    00EA
00EE:  DECFSZ 01,F
00F0:  BRA    00E8
00F2:  MOVLW  7B
00F4:  MOVWF  00
00F6:  DECFSZ 00,F
00F8:  BRA    00F6
00FA:  DECFSZ FEF,F
00FC:  BRA    00E4
00FE:  RETURN 0
*
1A84:  MOVLW  03
1A86:  SUBWF  59,F
1A88:  BNC   1A9C
1A8A:  CLRF   FEA
1A8C:  MOVLW  59
1A8E:  MOVWF  FE9
1A90:  MOVF   FEF,W
1A92:  BZ    1A9C
1A94:  BRA    1A98
1A96:  BRA    1A98
1A98:  DECFSZ FEF,F
1A9A:  BRA    1A96
1A9C:  RETURN 0
....................  
.................... //#BIT Data_Pin_Direction = 0xf93.7             // Pin direction mapped to TRISB.7 
.................... #use   fast_io(a)//modo rápido de inicialização das portas 
.................... #use   fast_io(b)//modo rápido de inicialização das portas 
.................... #use   fast_io(d)//modo rápido de inicialização das portas 
.................... #use   fast_io(e)//modo rápido de inicialização das portas 
....................  
.................... #byte   porta = 0xf80 // atribui o nome "porta" ao registrador do port 0xf80 
.................... #byte   portb = 0xf81  
.................... #byte   portd = 0xf83 
.................... #byte   porte = 0xf84 
.................... #byte   portc = 0xf82 
.................... // pinos de entrada e saida  
.................... #bit NTC = porta.0    //  Pino de leitura do NTC  
.................... #bit PIN_COOLER = portc.0  //  Pino de leitura do DHT11 
.................... #bit POT_SET_TEMP = porta.1 //Pino de leitura do potenciometro de set da temperatura  
.................... #bit POT_SET_UMI = porta.2 //Pino de leitura do potenciometro de set da umidade  
.................... #bit BOT_BLK_LTH = portb.0 // Pino do botao paraligar a luz do lcd 
.................... #bit BOT_MORE_INF = portb.1 // botao para mais informaçoes no lcd 
.................... #BIT Data_Pin = portb.7                       // Pin mapped to PORTB.7 
.................... // pinos de saida 
.................... #bit PIN_SERV = portb.3 
.................... #bit RELE_LAMP = portb.2  //  pino que acionamento do relé da lampada/aquecedor 
.................... //#bit DHT11 = portb.7  
.................... #bit rs =porte.0 //  via do lcd que sinaliza recepção de dados ou comando  
.................... #bit enable = porte.1 // habilita o lcd 
.................... #byte DISPLAY = portd //  seleciona o port no qual o lcd esta ligado ( o mesmo valor que esta no arquivo.h) 
.................... #INCLUDE <lcd.h> // inclui a biblioteca do modulo lcd 
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *      Rotina que envia um COMANDO para o LCD                 * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void comando_lcd(int caracter) 
.................... { 
....................    rs = 0;               // seleciona o envio de um caracter 
*
00BE:  BCF    F84.0
....................    portd = caracter;         // carrega o portc com o caracter 
00C0:  MOVFF  58,F83
....................    enable = 1 ;            // gera pulso no enable 
00C4:  BSF    F84.1
....................    delay_us(1);            // espera 1 microsegundos 
00C6:  BRA    00C8
00C8:  BRA    00CA
00CA:  NOP   
....................    enable = 0;            // desce o pino de enable 
00CC:  BCF    F84.1
....................  
....................    delay_us(40);            // espera mínimo 40 microsegundos 
00CE:  MOVLW  42
00D0:  MOVWF  00
00D2:  DECFSZ 00,F
00D4:  BRA    00D2
00D6:  NOP   
....................     
....................    return;               // retorna 
00D8:  RETURN 0
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *      Rotina que envia um DADO a ser escrito no LCD              * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void escreve_lcd(int caracter) 
.................... { 
....................    rs = 1;               // seleciona o envio de um comando 
*
1A20:  BSF    F84.0
....................    portd = caracter;         // carrega o portc com o valor do comando 
1A22:  MOVFF  5A,F83
....................    enable = 1;            // gera pulso no enable 
1A26:  BSF    F84.1
....................    delay_us(1);            // espera 3 microsegundos 
1A28:  BRA    1A2A
1A2A:  BRA    1A2C
1A2C:  NOP   
....................    enable = 0;            // desce o pino de enable 
1A2E:  BCF    F84.1
....................  
....................    delay_us(40);            // espera mínimo 40 microsegundos 
1A30:  MOVLW  42
1A32:  MOVWF  00
1A34:  DECFSZ 00,F
1A36:  BRA    1A34
1A38:  NOP   
....................     
....................    return;               // retorna 
1A3A:  RETURN 0
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *              Função para limpar o LCD                 * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void limpa_lcd() 
.................... { 
....................    comando_lcd(0x01);         // limpa lcd    
*
0100:  MOVLW  01
0102:  MOVWF  58
0104:  RCALL  00BE
....................    delay_ms (2); 
0106:  MOVLW  02
0108:  MOVWF  59
010A:  RCALL  00DA
....................    return; 
010C:  RETURN 0
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *           Inicialização do Display de LCD                 * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void inicializa_lcd() 
.................... { 
....................    comando_lcd(0x30);         // envia comando para inicializar display 
010E:  MOVLW  30
0110:  MOVWF  58
0112:  RCALL  00BE
....................    delay_ms(4);            // espera 4 milisengundos 
0114:  MOVLW  04
0116:  MOVWF  59
0118:  RCALL  00DA
....................  
....................    comando_lcd(0x30);         // envia comando para inicializar display 
011A:  MOVLW  30
011C:  MOVWF  58
011E:  RCALL  00BE
....................    delay_us(100);            // espera 100 microsengundos 
0120:  MOVLW  A6
0122:  MOVWF  00
0124:  DECFSZ 00,F
0126:  BRA    0124
0128:  NOP   
....................  
....................    comando_lcd(0x30);         // envia comando para inicializar display 
012A:  MOVLW  30
012C:  MOVWF  58
012E:  RCALL  00BE
....................  
....................    comando_lcd(0x38);         // liga o display, sem cursor e sem blink 
0130:  MOVLW  38
0132:  MOVWF  58
0134:  RCALL  00BE
....................  
....................    limpa_lcd();            // limpa lcd 
0136:  RCALL  0100
....................  
....................    comando_lcd(0x0c);         // display sem cursor 
0138:  MOVLW  0C
013A:  MOVWF  58
013C:  RCALL  00BE
....................  
....................    comando_lcd(0x06);         // desloca cursor para a direita 
013E:  MOVLW  06
0140:  MOVWF  58
0142:  RCALL  00BE
....................  
....................    return;               // retorna 
0144:  GOTO   1C18 (RETURN)
.................... }    
....................  
....................  
....................  
.................... char message2[] = "RH   = 00.0 %"; //  vetor de mensagem para a umidade  
.................... short Time_out; //  variavel para as funçoes referentes ao sensor de umidade dht11 
.................... unsigned  int8 RH_byte1, RH_byte2, CheckSum; //  variaveis para as funçoes do dht11 
....................  
.................... float ntc_val = 0; // variavel responsavel por receber o valor digital do ntc 
.................... float rntc = 0; //  valor da resistencia do divisor de tensao do ntc  
.................... float b1=0;  //  variavel auxiliar para função do ntc 
.................... float c1=0;//  variavel auxiliar para função do ntc 
.................... float temp=0;//  variavel auxiliar para função do ntc 
.................... float temperatura=0;//  variavel auxiliar para função do ntc 
.................... char umidade;//  variavel auxiliar para função do ntc 
....................  double a = 0.0011303; //  constantes fisicas do sensor ntc 10k 
....................  double b = 0.0002339; //  constantes fisicas do sensor ntc 10k 
....................  double c = 0.00000008863; //  constantes fisicas do sensor ntc 10k 
.................... int cont=0; 
.................... long int cont_int = 0; 
.................... int horas=0; 
.................... #int_timer0 
.................... void trata_tmr0 () 
.................... { 
....................    set_timer0(131 + get_timer0()); 
*
0096:  MOVF   FD6,W
0098:  MOVFF  FD7,03
009C:  ADDLW  83
009E:  MOVWF  x97
00A0:  MOVLW  00
00A2:  ADDWFC FD7,W
00A4:  MOVWF  FD7
00A6:  MOVFF  97,FD6
....................    cont_int++; 
00AA:  INCF   54,F
00AC:  BTFSC  FD8.2
00AE:  INCF   55,F
....................    if(cont_int > 2246400)  
....................    { 
....................       cont_int = 0; 
....................       horas++;       
....................    } 
....................     
....................   
00B0:  BCF    FF2.2
00B2:  GOTO   0054
.................... } 
....................  
....................  
....................  
.................... // FUNÇÃO POR INICIAR A DHT11 
....................  
.................... void start_signal(){ 
....................   set_tris_b(0b01000000);//Data_Pin_Direction = 0;              // Configure connection pin as output 
*
189C:  MOVLW  40
189E:  MOVWF  F93
....................   Data_Pin = 0;                        // Connection pin output low 
18A0:  BCF    F81.7
....................   delay_ms(25); 
18A2:  MOVLW  19
18A4:  MOVWF  59
18A6:  CALL   00DA
....................   Data_Pin = 1;                        // Connection pin output high 
18AA:  BSF    F81.7
....................   delay_us(30); 
18AC:  MOVLW  31
18AE:  MOVWF  00
18B0:  DECFSZ 00,F
18B2:  BRA    18B0
18B4:  BRA    18B6
....................   set_tris_b(0b11000000);//Data_Pin_Direction = 1;              // Configure connection pin as input 
18B6:  MOVLW  C0
18B8:  MOVWF  F93
18BA:  GOTO   19C4 (RETURN)
.................... } 
....................  
.................... // FUNÇAÕ POR VERIFICAR SE O SENSOR ESTA RESPONDENDO  
....................  
....................   short check_response(){ 
....................   delay_us(40); 
18BE:  MOVLW  42
18C0:  MOVWF  00
18C2:  DECFSZ 00,F
18C4:  BRA    18C2
18C6:  NOP   
....................   if(!Data_Pin){                     // Read and test if connection pin is low 
18C8:  BTFSC  F81.7
18CA:  BRA    18EC
....................     delay_us(80); 
18CC:  MOVLW  84
18CE:  MOVWF  00
18D0:  DECFSZ 00,F
18D2:  BRA    18D0
18D4:  BRA    18D6
18D6:  NOP   
....................     if(Data_Pin){                    // Read and test if connection pin is high 
18D8:  BTFSS  F81.7
18DA:  BRA    18EC
....................       delay_us(50); 
18DC:  MOVLW  52
18DE:  MOVWF  00
18E0:  DECFSZ 00,F
18E2:  BRA    18E0
18E4:  BRA    18E6
18E6:  NOP   
....................       return 1;} 
18E8:  MOVLW  01
18EA:  MOVWF  01
....................     } 
18EC:  GOTO   19C6 (RETURN)
.................... } 
....................  
....................  
.................... // FUNÇÃO PARA A OBTENÇÃO DO VALOR DE HUMIDADE 
.................... unsigned int8 Read_Data(){ 
18F0:  CLRF   59
....................   unsigned int8 i, k, _data = 0;     // k is used to count 1 bit reading duration 
....................   if(Time_out) 
18F2:  BTFSS  2A.0
18F4:  BRA    18F6
....................     break; 
....................   for(i = 0; i < 8; i++){ 
18F6:  CLRF   57
18F8:  MOVF   57,W
18FA:  SUBLW  07
18FC:  BNC   1982
....................     k = 0; 
18FE:  CLRF   58
....................     while(!Data_Pin){                          // Wait until pin goes high 
1900:  BTFSC  F81.7
1902:  BRA    1918
....................       k++; 
1904:  INCF   58,F
....................       if (k > 100) {Time_out = 1; break;} 
1906:  MOVF   58,W
1908:  SUBLW  64
190A:  BC    1910
190C:  BSF    2A.0
190E:  BRA    1918
....................       delay_us(1);} 
1910:  BRA    1912
1912:  BRA    1914
1914:  NOP   
1916:  BRA    1900
....................     delay_us(30); 
1918:  MOVLW  31
191A:  MOVWF  00
191C:  DECFSZ 00,F
191E:  BRA    191C
1920:  BRA    1922
....................     if(!Data_Pin) 
1922:  BTFSC  F81.7
1924:  BRA    1948
....................       bit_clear(_data, (7 - i));               // Clear bit (7 - i) 
1926:  MOVLW  07
1928:  BSF    FD8.0
192A:  SUBFWB 57,W
192C:  MOVWF  5A
192E:  MOVLW  01
1930:  MOVWF  00
1932:  MOVF   5A,W
1934:  MOVWF  01
1936:  BZ    1940
1938:  BCF    FD8.0
193A:  RLCF   00,F
193C:  DECFSZ 01,F
193E:  BRA    1938
1940:  MOVF   00,W
1942:  XORLW  FF
1944:  ANDWF  59,F
1946:  BRA    197E
....................     else{ 
....................       bit_set(_data, (7 - i));                 // Set bit (7 - i) 
1948:  MOVLW  07
194A:  BSF    FD8.0
194C:  SUBFWB 57,W
194E:  MOVWF  5A
1950:  MOVLW  01
1952:  MOVWF  00
1954:  MOVF   5A,W
1956:  MOVWF  01
1958:  BZ    1962
195A:  BCF    FD8.0
195C:  RLCF   00,F
195E:  DECFSZ 01,F
1960:  BRA    195A
1962:  MOVF   00,W
1964:  IORWF  59,F
....................       while(Data_Pin){                         // Wait until pin goes low 
1966:  BTFSS  F81.7
1968:  BRA    197E
....................       k++; 
196A:  INCF   58,F
....................       if (k > 100) {Time_out = 1; break;} 
196C:  MOVF   58,W
196E:  SUBLW  64
1970:  BC    1976
1972:  BSF    2A.0
1974:  BRA    197E
....................       delay_us(1);} 
1976:  BRA    1978
1978:  BRA    197A
197A:  NOP   
197C:  BRA    1966
....................     } 
197E:  INCF   57,F
1980:  BRA    18F8
....................   } 
....................   return _data; 
1982:  MOVFF  59,01
1986:  RETURN 0
.................... } 
....................  
.................... // FUNÇÃO PRINCIPAL QUE RETORNARA A UMIDADE  
....................  
.................... char dht11(){ 
....................    delay_ms(1000); 
*
19B0:  MOVLW  04
19B2:  MOVWF  57
19B4:  MOVLW  FA
19B6:  MOVWF  59
19B8:  CALL   00DA
19BC:  DECFSZ 57,F
19BE:  BRA    19B4
....................    Time_out = 0; 
19C0:  BCF    2A.0
....................    Start_signal(); 
19C2:  BRA    189C
....................    if(check_response()){// If there is response from sensor 
19C4:  BRA    18BE
19C6:  MOVF   01,F
19C8:  BZ    1A14
....................    RH_byte1=Read_Data();// read RH byte1 
19CA:  RCALL  18F0
19CC:  MOVFF  01,2B
....................    RH_byte2=Read_Data();// read RH byte2 
19D0:  RCALL  18F0
19D2:  MOVFF  01,2C
....................    Checksum=Read_Data();// read checksum                    
19D6:  RCALL  18F0
19D8:  MOVFF  01,2D
....................       if(CheckSum==((RH_Byte1+RH_Byte2)& 0xFF)){ 
19DC:  MOVF   2C,W
19DE:  ADDWF  2B,W
19E0:  SUBWF  2D,W
19E2:  BNZ   1A14
....................               message2[7]=RH_Byte1/10+48; 
19E4:  MOVFF  2B,57
19E8:  MOVLW  0A
19EA:  MOVWF  58
19EC:  RCALL  1988
19EE:  MOVLW  30
19F0:  ADDWF  01,W
19F2:  MOVWF  23
....................              message2[8]= RH_Byte1%10+48; 
19F4:  MOVFF  2B,57
19F8:  MOVLW  0A
19FA:  MOVWF  58
19FC:  RCALL  1988
19FE:  MOVLW  30
1A00:  ADDWF  00,W
1A02:  MOVWF  24
....................              message2[10] = RH_Byte2/10+48;   
1A04:  MOVFF  2C,57
1A08:  MOVLW  0A
1A0A:  MOVWF  58
1A0C:  RCALL  1988
1A0E:  MOVLW  30
1A10:  ADDWF  01,W
1A12:  MOVWF  26
....................               
....................        } 
....................    }  
....................    return message2; 
1A14:  MOVLW  1C
1A16:  MOVWF  01
1A18:  MOVLW  00
1A1A:  MOVWF  02
1A1C:  GOTO   1C3C (RETURN)
.................... } 
....................  
....................  
....................  
....................  
.................... float ntc(){ 
.................... set_adc_channel(0); //  escolhe o pino analogico para ler   
*
15D0:  MOVLW  00
15D2:  MOVWF  01
15D4:  MOVF   FC2,W
15D6:  ANDLW  C3
15D8:  IORWF  01,W
15DA:  MOVWF  FC2
.................... delay_us(10); // delay para começar a conversão 
15DC:  MOVLW  10
15DE:  MOVWF  00
15E0:  DECFSZ 00,F
15E2:  BRA    15E0
15E4:  NOP   
.................... read_adc(ADC_START_ONLY ); 
15E6:  BSF    FC2.1
.................... while(!adc_done()){ 
15E8:  BTFSS  FC2.1
15EA:  BRA    15EE
15EC:  BRA    15E8
.................... } 
.................... ntc_val = read_adc(ADC_READ_ONLY ); // le o valor na porta analogica 
15EE:  BTFSC  FC2.1
15F0:  BRA    15EE
15F2:  MOVFF  FC4,03
15F6:  MOVFF  FC3,87
15FA:  MOVFF  FC4,88
15FE:  CALL   0148
1602:  MOVFF  03,31
1606:  MOVFF  02,30
160A:  MOVFF  01,2F
160E:  MOVFF  00,2E
.................... ntc_val *=5; // multiplica o valor digitalizado pelo valor de tensão de alimentação 
1612:  MOVFF  31,86
1616:  MOVFF  30,85
161A:  MOVFF  2F,84
161E:  MOVFF  2E,83
1622:  CLRF   x8A
1624:  CLRF   x89
1626:  MOVLW  20
1628:  MOVWF  x88
162A:  MOVLW  81
162C:  MOVWF  x87
162E:  CALL   017E
1632:  MOVFF  03,31
1636:  MOVFF  02,30
163A:  MOVFF  01,2F
163E:  MOVFF  00,2E
.................... ntc_val/=1023;  // divide  o valor acima por 1023 
1642:  MOVFF  31,7F
1646:  MOVFF  30,7E
164A:  MOVFF  2F,7D
164E:  MOVFF  2E,7C
1652:  CLRF   x83
1654:  MOVLW  C0
1656:  MOVWF  x82
1658:  MOVLW  7F
165A:  MOVWF  x81
165C:  MOVLW  88
165E:  MOVWF  x80
1660:  CALL   0270
1664:  MOVFF  03,31
1668:  MOVFF  02,30
166C:  MOVFF  01,2F
1670:  MOVFF  00,2E
.................... // Inicio calculo de equação de  Steinhart & Hart  
.................... rntc=50000/ntc_val;      
1674:  CLRF   x7F
1676:  MOVLW  50
1678:  MOVWF  x7E
167A:  MOVLW  43
167C:  MOVWF  x7D
167E:  MOVLW  8E
1680:  MOVWF  x7C
1682:  MOVFF  31,83
1686:  MOVFF  30,82
168A:  MOVFF  2F,81
168E:  MOVFF  2E,80
1692:  CALL   0270
1696:  MOVFF  03,35
169A:  MOVFF  02,34
169E:  MOVFF  01,33
16A2:  MOVFF  00,32
....................        rntc=rntc-10000;       
16A6:  BSF    FD8.1
16A8:  MOVFF  35,8A
16AC:  MOVFF  34,89
16B0:  MOVFF  33,88
16B4:  MOVFF  32,87
16B8:  CLRF   x8E
16BA:  MOVLW  40
16BC:  MOVWF  x8D
16BE:  MOVLW  1C
16C0:  MOVWF  x8C
16C2:  MOVLW  8C
16C4:  MOVWF  x8B
16C6:  CALL   03CA
16CA:  MOVFF  03,35
16CE:  MOVFF  02,34
16D2:  MOVFF  01,33
16D6:  MOVFF  00,32
....................        b1=log(rntc);           
16DA:  MOVFF  35,66
16DE:  MOVFF  34,65
16E2:  MOVFF  33,64
16E6:  MOVFF  32,63
16EA:  CALL   06F2
16EE:  MOVFF  03,39
16F2:  MOVFF  02,38
16F6:  MOVFF  01,37
16FA:  MOVFF  00,36
....................        b1=b1*b;                
16FE:  MOVFF  39,86
1702:  MOVFF  38,85
1706:  MOVFF  37,84
170A:  MOVFF  36,83
170E:  MOVFF  4E,8A
1712:  MOVFF  4D,89
1716:  MOVFF  4C,88
171A:  MOVFF  4B,87
171E:  CALL   017E
1722:  MOVFF  03,39
1726:  MOVFF  02,38
172A:  MOVFF  01,37
172E:  MOVFF  00,36
....................        c1=log(rntc);           
1732:  MOVFF  35,66
1736:  MOVFF  34,65
173A:  MOVFF  33,64
173E:  MOVFF  32,63
1742:  CALL   06F2
1746:  MOVFF  03,3D
174A:  MOVFF  02,3C
174E:  MOVFF  01,3B
1752:  MOVFF  00,3A
....................        c1=pow(c1,3);           
1756:  MOVFF  3D,5A
175A:  MOVFF  3C,59
175E:  MOVFF  3B,58
1762:  MOVFF  3A,57
1766:  CLRF   5E
1768:  CLRF   5D
176A:  MOVLW  40
176C:  MOVWF  5C
176E:  MOVLW  80
1770:  MOVWF  5B
1772:  BRA    12FA
1774:  MOVFF  03,3D
1778:  MOVFF  02,3C
177C:  MOVFF  01,3B
1780:  MOVFF  00,3A
....................        c1=c1*c;                
1784:  MOVFF  3D,86
1788:  MOVFF  3C,85
178C:  MOVFF  3B,84
1790:  MOVFF  3A,83
1794:  MOVFF  52,8A
1798:  MOVFF  51,89
179C:  MOVFF  50,88
17A0:  MOVFF  4F,87
17A4:  CALL   017E
17A8:  MOVFF  03,3D
17AC:  MOVFF  02,3C
17B0:  MOVFF  01,3B
17B4:  MOVFF  00,3A
....................        temp=a+b1+c1;           
17B8:  BCF    FD8.1
17BA:  MOVFF  4A,8A
17BE:  MOVFF  49,89
17C2:  MOVFF  48,88
17C6:  MOVFF  47,87
17CA:  MOVFF  39,8E
17CE:  MOVFF  38,8D
17D2:  MOVFF  37,8C
17D6:  MOVFF  36,8B
17DA:  CALL   03CA
17DE:  MOVFF  03,5A
17E2:  MOVFF  02,59
17E6:  MOVFF  01,58
17EA:  MOVFF  00,57
17EE:  BCF    FD8.1
17F0:  MOVFF  03,8A
17F4:  MOVFF  02,89
17F8:  MOVFF  01,88
17FC:  MOVFF  00,87
1800:  MOVFF  3D,8E
1804:  MOVFF  3C,8D
1808:  MOVFF  3B,8C
180C:  MOVFF  3A,8B
1810:  CALL   03CA
1814:  MOVFF  03,41
1818:  MOVFF  02,40
181C:  MOVFF  01,3F
1820:  MOVFF  00,3E
....................        temp=1/temp;            
1824:  CLRF   x7F
1826:  CLRF   x7E
1828:  CLRF   x7D
182A:  MOVLW  7F
182C:  MOVWF  x7C
182E:  MOVFF  41,83
1832:  MOVFF  40,82
1836:  MOVFF  3F,81
183A:  MOVFF  3E,80
183E:  CALL   0270
1842:  MOVFF  03,41
1846:  MOVFF  02,40
184A:  MOVFF  01,3F
184E:  MOVFF  00,3E
....................        temp=temp-273.15; 
1852:  BSF    FD8.1
1854:  MOVFF  41,8A
1858:  MOVFF  40,89
185C:  MOVFF  3F,88
1860:  MOVFF  3E,87
1864:  MOVLW  33
1866:  MOVWF  x8E
1868:  MOVLW  93
186A:  MOVWF  x8D
186C:  MOVLW  08
186E:  MOVWF  x8C
1870:  MOVLW  87
1872:  MOVWF  x8B
1874:  CALL   03CA
1878:  MOVFF  03,41
187C:  MOVFF  02,40
1880:  MOVFF  01,3F
1884:  MOVFF  00,3E
....................        return temp; 
1888:  MOVFF  3E,00
188C:  MOVFF  3F,01
1890:  MOVFF  40,02
1894:  MOVFF  41,03
1898:  GOTO   1C2A (RETURN)
.................... // Fim do calculo de equação de  Steinhart & Hart 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... void mexeovos () {  
....................    limpa_lcd(); 
*
1A9E:  CALL   0100
....................    comando_lcd(0x83); //  posiciona o cursor no endereço 0x83 
1AA2:  MOVLW  83
1AA4:  MOVWF  58
1AA6:  CALL   00BE
....................    printf(escreve_lcd,"MEXENDO" ); 
1AAA:  MOVLW  B6
1AAC:  MOVWF  FF6
1AAE:  MOVLW  00
1AB0:  MOVWF  FF7
1AB2:  BRA    1A62
....................       for(int i=0;  i<50; i++){                       
1AB4:  CLRF   57
1AB6:  MOVF   57,W
1AB8:  SUBLW  31
1ABA:  BNC   1AE0
....................       PIN_SERV=1; 
1ABC:  BSF    F81.3
....................       delay_us(800); 
1ABE:  MOVLW  04
1AC0:  MOVWF  58
1AC2:  MOVLW  C7
1AC4:  MOVWF  59
1AC6:  RCALL  1A84
1AC8:  DECFSZ 58,F
1ACA:  BRA    1AC2
....................       PIN_SERV=0; 
1ACC:  BCF    F81.3
....................       delay_us(19200); 
1ACE:  MOVLW  13
1AD0:  MOVWF  59
1AD2:  CALL   00DA
1AD6:  MOVLW  C8
1AD8:  MOVWF  59
1ADA:  RCALL  1A84
1ADC:  INCF   57,F
1ADE:  BRA    1AB6
....................       } 
....................       delay_ms(2000); 
1AE0:  MOVLW  08
1AE2:  MOVWF  58
1AE4:  MOVLW  FA
1AE6:  MOVWF  59
1AE8:  CALL   00DA
1AEC:  DECFSZ 58,F
1AEE:  BRA    1AE4
....................       for(i=0;  i<50; i++){ 
1AF0:  CLRF   57
1AF2:  MOVF   57,W
1AF4:  SUBLW  31
1AF6:  BNC   1B2C
....................       PIN_SERV=1; 
1AF8:  BSF    F81.3
....................       delay_us(1500); 
1AFA:  MOVLW  01
1AFC:  MOVWF  59
1AFE:  CALL   00DA
1B02:  MOVLW  02
1B04:  MOVWF  58
1B06:  MOVLW  F9
1B08:  MOVWF  59
1B0A:  RCALL  1A84
1B0C:  DECFSZ 58,F
1B0E:  BRA    1B06
....................       PIN_SERV=0; 
1B10:  BCF    F81.3
....................       delay_us(18500); 
1B12:  MOVLW  12
1B14:  MOVWF  59
1B16:  CALL   00DA
1B1A:  MOVLW  02
1B1C:  MOVWF  58
1B1E:  MOVLW  F9
1B20:  MOVWF  59
1B22:  RCALL  1A84
1B24:  DECFSZ 58,F
1B26:  BRA    1B1E
1B28:  INCF   57,F
1B2A:  BRA    1AF2
....................       } 
....................       delay_ms(2000); 
1B2C:  MOVLW  08
1B2E:  MOVWF  58
1B30:  MOVLW  FA
1B32:  MOVWF  59
1B34:  CALL   00DA
1B38:  DECFSZ 58,F
1B3A:  BRA    1B30
1B3C:  GOTO   1C5C (RETURN)
....................     
.................... } 
....................  
.................... void main (void){ 
1B40:  CLRF   FF8
1B42:  BCF    FD0.7
1B44:  BSF    07.7
1B46:  CLRF   31
1B48:  CLRF   30
1B4A:  CLRF   2F
1B4C:  CLRF   2E
1B4E:  CLRF   35
1B50:  CLRF   34
1B52:  CLRF   33
1B54:  CLRF   32
1B56:  CLRF   39
1B58:  CLRF   38
1B5A:  CLRF   37
1B5C:  CLRF   36
1B5E:  CLRF   3D
1B60:  CLRF   3C
1B62:  CLRF   3B
1B64:  CLRF   3A
1B66:  CLRF   41
1B68:  CLRF   40
1B6A:  CLRF   3F
1B6C:  CLRF   3E
1B6E:  CLRF   45
1B70:  CLRF   44
1B72:  CLRF   43
1B74:  CLRF   42
1B76:  MOVLW  93
1B78:  MOVWF  4A
1B7A:  MOVLW  26
1B7C:  MOVWF  49
1B7E:  MOVLW  14
1B80:  MOVWF  48
1B82:  MOVLW  75
1B84:  MOVWF  47
1B86:  MOVLW  0E
1B88:  MOVWF  4E
1B8A:  MOVLW  43
1B8C:  MOVWF  4D
1B8E:  MOVLW  75
1B90:  MOVWF  4C
1B92:  MOVLW  72
1B94:  MOVWF  4B
1B96:  MOVLW  DC
1B98:  MOVWF  52
1B9A:  MOVLW  54
1B9C:  MOVWF  51
1B9E:  MOVLW  3E
1BA0:  MOVWF  50
1BA2:  MOVLW  67
1BA4:  MOVWF  4F
1BA6:  CLRF   53
1BA8:  CLRF   55
1BAA:  CLRF   54
1BAC:  CLRF   56
1BAE:  MOVF   FC1,W
1BB0:  ANDLW  C0
1BB2:  IORLW  0F
1BB4:  MOVWF  FC1
1BB6:  MOVLW  07
1BB8:  MOVWF  FB4
1BBA:  CLRF   16
1BBC:  CLRF   17
1BBE:  MOVLW  52
1BC0:  MOVWF  1C
1BC2:  MOVLW  48
1BC4:  MOVWF  1D
1BC6:  MOVLW  A0
1BC8:  MOVWF  1E
1BCA:  MOVWF  1F
1BCC:  MOVWF  20
1BCE:  MOVLW  3D
1BD0:  MOVWF  21
1BD2:  MOVLW  A0
1BD4:  MOVWF  22
1BD6:  MOVLW  30
1BD8:  MOVWF  23
1BDA:  MOVWF  24
1BDC:  MOVLW  2E
1BDE:  MOVWF  25
1BE0:  MOVLW  30
1BE2:  MOVWF  26
1BE4:  MOVLW  A0
1BE6:  MOVWF  27
1BE8:  MOVLW  25
1BEA:  MOVWF  28
1BEC:  CLRF   29
.................... setup_adc(ADC_CLOCK_DIV_32); //  configura o clock utilizado para o conversor ad e o pior clock ele usa a malha RC é lenta  
1BEE:  MOVF   FC0,W
1BF0:  ANDLW  C0
1BF2:  IORLW  02
1BF4:  MOVWF  FC0
1BF6:  BSF    FC0.7
1BF8:  BSF    FC2.0
.................... setup_adc_ports( AN0_TO_AN2 ); // selecionaos pinos A0 a A2 como pinos de sinais analogicos  
1BFA:  MOVF   FC1,W
1BFC:  ANDLW  C0
1BFE:  IORLW  0C
1C00:  MOVWF  FC1
.................... set_tris_a(0b00001111); // verificar se pinos analogicos necessitam de definição de tris 
1C02:  MOVLW  0F
1C04:  MOVWF  F92
.................... set_tris_b(0b11000000);   
1C06:  MOVLW  C0
1C08:  MOVWF  F93
.................... set_tris_c(0b00000000);// define os pinos RB0 E RB1 como entrada e os demais como saida 
1C0A:  MOVLW  00
1C0C:  MOVWF  F94
.................... set_tris_d(0b00000000);  //  Idem como supracitado acima  
1C0E:  MOVWF  F95
.................... set_tris_e(0b00000100); 
1C10:  MOVLW  04
1C12:  MOVWF  F96
.................... inicializa_lcd(); // função responsavel por inicializar o modulo lcd 
1C14:  GOTO   010E
.................... // CONFIGURA?+O DO TIMER0 
....................    setup_timer_0 (RTCC_INTERNAL | RTCC_8_BIT | RTCC_DIV_64); 
1C18:  MOVLW  C5
1C1A:  MOVWF  FD5
....................    set_timer0(131); 
1C1C:  CLRF   FD7
1C1E:  MOVLW  83
1C20:  MOVWF  FD6
....................    enable_interrupts(GLOBAL);//chave principal das interrup??es 
1C22:  MOVLW  C0
1C24:  IORWF  FF2,F
....................    enable_interrupts(int_timer0); // interrup??o do TIMER 0 
1C26:  BSF    FF2.5
....................    
....................   while(true){ 
....................   temperatura = ntc(); //  le o valor  de temperatura em graus celsius que a função do ntc retorna  
1C28:  BRA    15D0
1C2A:  MOVFF  03,45
1C2E:  MOVFF  02,44
1C32:  MOVFF  01,43
1C36:  MOVFF  00,42
....................   umidade = dht11(); 
1C3A:  BRA    19B0
1C3C:  MOVFF  01,46
.................... limpa_lcd(); 
1C40:  CALL   0100
....................  comando_lcd(0x83); //  posiciona o cursor no endereço 0x83 
1C44:  MOVLW  83
1C46:  MOVWF  58
1C48:  CALL   00BE
.................... printf(escreve_lcd,"%s",message2); 
1C4C:  CLRF   FEA
1C4E:  MOVLW  1C
1C50:  MOVWF  FE9
1C52:  BRA    1A3C
....................  
....................    if(horas == 3){ 
1C54:  MOVF   56,W
1C56:  SUBLW  03
1C58:  BNZ   1C5E
....................     mexeovos(); 
1C5A:  BRA    1A9E
....................     horas=0; 
1C5C:  CLRF   56
....................     } 
....................     
....................     // implementação da rotina de controle de  temperatura  
....................    if(temperatura<=38){   //  verifica se da temperatura de menor que 38 graus e faz  a rotina  
1C5E:  MOVFF  45,86
1C62:  MOVFF  44,85
1C66:  MOVFF  43,84
1C6A:  MOVFF  42,83
1C6E:  CLRF   x8A
1C70:  CLRF   x89
1C72:  MOVLW  18
1C74:  MOVWF  x88
1C76:  MOVLW  84
1C78:  MOVWF  x87
1C7A:  CALL   0634
1C7E:  BC    1C82
1C80:  BNZ   1C86
....................      PIN_COOLER =0 ; 
1C82:  BCF    F82.0
....................      RELE_LAMP = 1 ; 
1C84:  BSF    F81.2
....................     } 
....................     if(temperatura>38){ 
1C86:  CLRF   x86
1C88:  CLRF   x85
1C8A:  MOVLW  18
1C8C:  MOVWF  x84
1C8E:  MOVLW  84
1C90:  MOVWF  x83
1C92:  MOVFF  45,8A
1C96:  MOVFF  44,89
1C9A:  MOVFF  43,88
1C9E:  MOVFF  42,87
1CA2:  CALL   0634
1CA6:  BNC   1CAC
....................     PIN_COOLER =1 ; 
1CA8:  BSF    F82.0
....................     RELE_LAMP = 0 ;  
1CAA:  BCF    F81.2
....................     } 
1CAC:  BRA    1C28
....................     //delay_ms(2000);    
....................   } 
....................    
....................    
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... } 
1CAE:  SLEEP 

Configuration Fuses:
   Word  1: CC3F   PLL12 CPUDIV4 USBDIV HS FCMEN IESO
   Word  2: 1E38   PUT NOBROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
