CCS PCH C Compiler, Version 5.015, 5967               20-jun-17 20:32

               Filename:   C:\Users\henri\Documents\GitHub\Projeto-chocadeira\Cod chocadeira sem interrupção\cod_chocadeira_sem_interrupcao.lst

               ROM used:   6218 bytes (19%)
                           Largest free fragment is 26550
               RAM used:   75 (4%) at main() level
                           139 (7%) worst case
               Stack used: 6 locations
               Stack size: 31

*
0000:  GOTO   174A
.................... #include<18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
0004:  MOVLW  8E
0006:  MOVWF  00
0008:  MOVFF  7C,01
000C:  MOVFF  7B,02
0010:  CLRF   03
0012:  MOVF   01,F
0014:  BNZ   0028
0016:  MOVFF  02,01
001A:  CLRF   02
001C:  MOVLW  08
001E:  SUBWF  00,F
0020:  MOVF   01,F
0022:  BNZ   0028
0024:  CLRF   00
0026:  BRA    0038
0028:  BCF    FD8.0
002A:  BTFSC  01.7
002C:  BRA    0036
002E:  RLCF   02,F
0030:  RLCF   01,F
0032:  DECF   00,F
0034:  BRA    0028
0036:  BCF    01.7
0038:  RETURN 0
003A:  MOVF   x77,W
003C:  BTFSC  FD8.2
003E:  BRA    0122
0040:  MOVWF  00
0042:  MOVF   x7B,W
0044:  BTFSC  FD8.2
0046:  BRA    0122
0048:  ADDWF  00,F
004A:  BNC   0054
004C:  MOVLW  81
004E:  ADDWF  00,F
0050:  BC    0122
0052:  BRA    005C
0054:  MOVLW  7F
0056:  SUBWF  00,F
0058:  BNC   0122
005A:  BZ    0122
005C:  MOVFF  78,7F
0060:  MOVF   x7C,W
0062:  XORWF  x7F,F
0064:  BSF    x78.7
0066:  BSF    x7C.7
0068:  MOVF   x7A,W
006A:  MULWF  x7E
006C:  MOVFF  FF4,81
0070:  MOVF   x79,W
0072:  MULWF  x7D
0074:  MOVFF  FF4,03
0078:  MOVFF  FF3,80
007C:  MULWF  x7E
007E:  MOVF   FF3,W
0080:  ADDWF  x81,F
0082:  MOVF   FF4,W
0084:  ADDWFC x80,F
0086:  MOVLW  00
0088:  ADDWFC 03,F
008A:  MOVF   x7A,W
008C:  MULWF  x7D
008E:  MOVF   FF3,W
0090:  ADDWF  x81,F
0092:  MOVF   FF4,W
0094:  ADDWFC x80,F
0096:  MOVLW  00
0098:  CLRF   02
009A:  ADDWFC 03,F
009C:  ADDWFC 02,F
009E:  MOVF   x78,W
00A0:  MULWF  x7E
00A2:  MOVF   FF3,W
00A4:  ADDWF  x80,F
00A6:  MOVF   FF4,W
00A8:  ADDWFC 03,F
00AA:  MOVLW  00
00AC:  ADDWFC 02,F
00AE:  MOVF   x78,W
00B0:  MULWF  x7D
00B2:  MOVF   FF3,W
00B4:  ADDWF  03,F
00B6:  MOVF   FF4,W
00B8:  ADDWFC 02,F
00BA:  MOVLW  00
00BC:  CLRF   01
00BE:  ADDWFC 01,F
00C0:  MOVF   x7A,W
00C2:  MULWF  x7C
00C4:  MOVF   FF3,W
00C6:  ADDWF  x80,F
00C8:  MOVF   FF4,W
00CA:  ADDWFC 03,F
00CC:  MOVLW  00
00CE:  ADDWFC 02,F
00D0:  ADDWFC 01,F
00D2:  MOVF   x79,W
00D4:  MULWF  x7C
00D6:  MOVF   FF3,W
00D8:  ADDWF  03,F
00DA:  MOVF   FF4,W
00DC:  ADDWFC 02,F
00DE:  MOVLW  00
00E0:  ADDWFC 01,F
00E2:  MOVF   x78,W
00E4:  MULWF  x7C
00E6:  MOVF   FF3,W
00E8:  ADDWF  02,F
00EA:  MOVF   FF4,W
00EC:  ADDWFC 01,F
00EE:  INCF   00,F
00F0:  BTFSC  01.7
00F2:  BRA    00FE
00F4:  RLCF   x80,F
00F6:  RLCF   03,F
00F8:  RLCF   02,F
00FA:  RLCF   01,F
00FC:  DECF   00,F
00FE:  MOVLW  00
0100:  BTFSS  x80.7
0102:  BRA    0118
0104:  INCF   03,F
0106:  ADDWFC 02,F
0108:  ADDWFC 01,F
010A:  MOVF   01,W
010C:  BNZ   0118
010E:  MOVF   02,W
0110:  BNZ   0118
0112:  MOVF   03,W
0114:  BNZ   0118
0116:  INCF   00,F
0118:  BTFSC  x7F.7
011A:  BSF    01.7
011C:  BTFSS  x7F.7
011E:  BCF    01.7
0120:  BRA    012A
0122:  CLRF   00
0124:  CLRF   01
0126:  CLRF   02
0128:  CLRF   03
012A:  RETURN 0
012C:  MOVF   x70,W
012E:  BTFSC  FD8.2
0130:  BRA    027C
0132:  MOVWF  x7C
0134:  MOVF   x74,W
0136:  BTFSC  FD8.2
0138:  BRA    027C
013A:  SUBWF  x7C,F
013C:  BNC   0148
013E:  MOVLW  7F
0140:  ADDWF  x7C,F
0142:  BTFSC  FD8.0
0144:  BRA    027C
0146:  BRA    0154
0148:  MOVLW  81
014A:  SUBWF  x7C,F
014C:  BTFSS  FD8.0
014E:  BRA    027C
0150:  BTFSC  FD8.2
0152:  BRA    027C
0154:  MOVFF  7C,00
0158:  CLRF   01
015A:  CLRF   02
015C:  CLRF   03
015E:  CLRF   x7B
0160:  MOVFF  71,7A
0164:  BSF    x7A.7
0166:  MOVFF  72,79
016A:  MOVFF  73,78
016E:  MOVLW  19
0170:  MOVWF  x7C
0172:  MOVF   x77,W
0174:  SUBWF  x78,F
0176:  BC    0192
0178:  MOVLW  01
017A:  SUBWF  x79,F
017C:  BC    0192
017E:  SUBWF  x7A,F
0180:  BC    0192
0182:  SUBWF  x7B,F
0184:  BC    0192
0186:  INCF   x7B,F
0188:  INCF   x7A,F
018A:  INCF   x79,F
018C:  MOVF   x77,W
018E:  ADDWF  x78,F
0190:  BRA    01E2
0192:  MOVF   x76,W
0194:  SUBWF  x79,F
0196:  BC    01BC
0198:  MOVLW  01
019A:  SUBWF  x7A,F
019C:  BC    01BC
019E:  SUBWF  x7B,F
01A0:  BC    01BC
01A2:  INCF   x7B,F
01A4:  INCF   x7A,F
01A6:  MOVF   x76,W
01A8:  ADDWF  x79,F
01AA:  MOVF   x77,W
01AC:  ADDWF  x78,F
01AE:  BNC   01E2
01B0:  INCF   x79,F
01B2:  BNZ   01E2
01B4:  INCF   x7A,F
01B6:  BNZ   01E2
01B8:  INCF   x7B,F
01BA:  BRA    01E2
01BC:  MOVF   x75,W
01BE:  IORLW  80
01C0:  SUBWF  x7A,F
01C2:  BC    01E0
01C4:  MOVLW  01
01C6:  SUBWF  x7B,F
01C8:  BC    01E0
01CA:  INCF   x7B,F
01CC:  MOVF   x75,W
01CE:  IORLW  80
01D0:  ADDWF  x7A,F
01D2:  MOVF   x76,W
01D4:  ADDWF  x79,F
01D6:  BNC   01AA
01D8:  INCF   x7A,F
01DA:  BNZ   01AA
01DC:  INCF   x7B,F
01DE:  BRA    01AA
01E0:  BSF    03.0
01E2:  DECFSZ x7C,F
01E4:  BRA    01E8
01E6:  BRA    01FE
01E8:  BCF    FD8.0
01EA:  RLCF   x78,F
01EC:  RLCF   x79,F
01EE:  RLCF   x7A,F
01F0:  RLCF   x7B,F
01F2:  BCF    FD8.0
01F4:  RLCF   03,F
01F6:  RLCF   02,F
01F8:  RLCF   01,F
01FA:  RLCF   x7D,F
01FC:  BRA    0172
01FE:  BTFSS  x7D.0
0200:  BRA    020E
0202:  BCF    FD8.0
0204:  RRCF   01,F
0206:  RRCF   02,F
0208:  RRCF   03,F
020A:  RRCF   x7D,F
020C:  BRA    0212
020E:  DECF   00,F
0210:  BZ    027C
0212:  BTFSC  x7D.7
0214:  BRA    0252
0216:  BCF    FD8.0
0218:  RLCF   x78,F
021A:  RLCF   x79,F
021C:  RLCF   x7A,F
021E:  RLCF   x7B,F
0220:  MOVF   x77,W
0222:  SUBWF  x78,F
0224:  BC    0234
0226:  MOVLW  01
0228:  SUBWF  x79,F
022A:  BC    0234
022C:  SUBWF  x7A,F
022E:  BC    0234
0230:  SUBWF  x7B,F
0232:  BNC   0268
0234:  MOVF   x76,W
0236:  SUBWF  x79,F
0238:  BC    0244
023A:  MOVLW  01
023C:  SUBWF  x7A,F
023E:  BC    0244
0240:  SUBWF  x7B,F
0242:  BNC   0268
0244:  MOVF   x75,W
0246:  IORLW  80
0248:  SUBWF  x7A,F
024A:  BC    0252
024C:  MOVLW  01
024E:  SUBWF  x7B,F
0250:  BNC   0268
0252:  INCF   03,F
0254:  BNZ   0268
0256:  INCF   02,F
0258:  BNZ   0268
025A:  INCF   01,F
025C:  BNZ   0268
025E:  INCF   00,F
0260:  BZ    027C
0262:  RRCF   01,F
0264:  RRCF   02,F
0266:  RRCF   03,F
0268:  MOVFF  71,7C
026C:  MOVF   x75,W
026E:  XORWF  x7C,F
0270:  BTFSS  x7C.7
0272:  BRA    0278
0274:  BSF    01.7
0276:  BRA    0284
0278:  BCF    01.7
027A:  BRA    0284
027C:  CLRF   00
027E:  CLRF   01
0280:  CLRF   02
0282:  CLRF   03
0284:  RETURN 0
0286:  MOVLW  80
0288:  BTFSC  FD8.1
028A:  XORWF  x80,F
028C:  CLRF   x85
028E:  CLRF   x86
0290:  MOVFF  7C,84
0294:  MOVF   x80,W
0296:  XORWF  x84,F
0298:  MOVF   x7B,W
029A:  BTFSC  FD8.2
029C:  BRA    0456
029E:  MOVWF  x83
02A0:  MOVWF  00
02A2:  MOVF   x7F,W
02A4:  BTFSC  FD8.2
02A6:  BRA    0468
02A8:  SUBWF  x83,F
02AA:  BTFSC  FD8.2
02AC:  BRA    03B0
02AE:  BNC   032A
02B0:  MOVFF  80,89
02B4:  BSF    x89.7
02B6:  MOVFF  81,88
02BA:  MOVFF  82,87
02BE:  CLRF   x86
02C0:  BCF    FD8.0
02C2:  RRCF   x89,F
02C4:  RRCF   x88,F
02C6:  RRCF   x87,F
02C8:  RRCF   x86,F
02CA:  DECFSZ x83,F
02CC:  BRA    02BE
02CE:  BTFSS  x84.7
02D0:  BRA    02D8
02D2:  BSF    x85.0
02D4:  BRA    0490
02D6:  BCF    x85.0
02D8:  BCF    x83.0
02DA:  BSF    x85.4
02DC:  CLRF   FEA
02DE:  MOVLW  7E
02E0:  MOVWF  FE9
02E2:  BRA    04B6
02E4:  BCF    x85.4
02E6:  BTFSC  x84.7
02E8:  BRA    02FE
02EA:  BTFSS  x83.0
02EC:  BRA    0314
02EE:  RRCF   x89,F
02F0:  RRCF   x88,F
02F2:  RRCF   x87,F
02F4:  RRCF   x86,F
02F6:  INCF   00,F
02F8:  BTFSC  FD8.2
02FA:  BRA    0486
02FC:  BRA    0314
02FE:  BTFSC  x89.7
0300:  BRA    031A
0302:  BCF    FD8.0
0304:  RLCF   x86,F
0306:  RLCF   x87,F
0308:  RLCF   x88,F
030A:  RLCF   x89,F
030C:  DECF   00,F
030E:  BTFSC  FD8.2
0310:  BRA    0486
0312:  BRA    02FE
0314:  BSF    x85.6
0316:  BRA    03EE
0318:  BCF    x85.6
031A:  MOVFF  7C,84
031E:  BTFSS  x7C.7
0320:  BRA    0326
0322:  BSF    x89.7
0324:  BRA    0478
0326:  BCF    x89.7
0328:  BRA    0478
032A:  MOVFF  7F,83
032E:  MOVFF  7F,00
0332:  MOVF   x7B,W
0334:  SUBWF  x83,F
0336:  MOVFF  7C,89
033A:  BSF    x89.7
033C:  MOVFF  7D,88
0340:  MOVFF  7E,87
0344:  CLRF   x86
0346:  BCF    FD8.0
0348:  RRCF   x89,F
034A:  RRCF   x88,F
034C:  RRCF   x87,F
034E:  RRCF   x86,F
0350:  DECFSZ x83,F
0352:  BRA    0344
0354:  BTFSS  x84.7
0356:  BRA    035E
0358:  BSF    x85.1
035A:  BRA    0490
035C:  BCF    x85.1
035E:  BCF    x83.0
0360:  BSF    x85.5
0362:  CLRF   FEA
0364:  MOVLW  82
0366:  MOVWF  FE9
0368:  BRA    04B6
036A:  BCF    x85.5
036C:  BTFSC  x84.7
036E:  BRA    0384
0370:  BTFSS  x83.0
0372:  BRA    039A
0374:  RRCF   x89,F
0376:  RRCF   x88,F
0378:  RRCF   x87,F
037A:  RRCF   x86,F
037C:  INCF   00,F
037E:  BTFSC  FD8.2
0380:  BRA    0486
0382:  BRA    039A
0384:  BTFSC  x89.7
0386:  BRA    03A0
0388:  BCF    FD8.0
038A:  RLCF   x86,F
038C:  RLCF   x87,F
038E:  RLCF   x88,F
0390:  RLCF   x89,F
0392:  DECF   00,F
0394:  BTFSC  FD8.2
0396:  BRA    0486
0398:  BRA    0384
039A:  BSF    x85.7
039C:  BRA    03EE
039E:  BCF    x85.7
03A0:  MOVFF  80,84
03A4:  BTFSS  x80.7
03A6:  BRA    03AC
03A8:  BSF    x89.7
03AA:  BRA    0478
03AC:  BCF    x89.7
03AE:  BRA    0478
03B0:  MOVFF  80,89
03B4:  BSF    x89.7
03B6:  MOVFF  81,88
03BA:  MOVFF  82,87
03BE:  BTFSS  x84.7
03C0:  BRA    03CA
03C2:  BCF    x89.7
03C4:  BSF    x85.2
03C6:  BRA    0490
03C8:  BCF    x85.2
03CA:  CLRF   x86
03CC:  BCF    x83.0
03CE:  CLRF   FEA
03D0:  MOVLW  7E
03D2:  MOVWF  FE9
03D4:  BRA    04B6
03D6:  BTFSC  x84.7
03D8:  BRA    0412
03DA:  MOVFF  7C,84
03DE:  BTFSS  x83.0
03E0:  BRA    03EE
03E2:  RRCF   x89,F
03E4:  RRCF   x88,F
03E6:  RRCF   x87,F
03E8:  RRCF   x86,F
03EA:  INCF   00,F
03EC:  BZ    0486
03EE:  BTFSS  x86.7
03F0:  BRA    0408
03F2:  INCF   x87,F
03F4:  BNZ   0408
03F6:  INCF   x88,F
03F8:  BNZ   0408
03FA:  INCF   x89,F
03FC:  BNZ   0408
03FE:  RRCF   x89,F
0400:  RRCF   x88,F
0402:  RRCF   x87,F
0404:  INCF   00,F
0406:  BZ    0486
0408:  BTFSC  x85.6
040A:  BRA    0318
040C:  BTFSC  x85.7
040E:  BRA    039E
0410:  BRA    044A
0412:  MOVLW  80
0414:  XORWF  x89,F
0416:  BTFSS  x89.7
0418:  BRA    0422
041A:  BRA    0490
041C:  MOVFF  80,84
0420:  BRA    0436
0422:  MOVFF  7C,84
0426:  MOVF   x89,F
0428:  BNZ   0436
042A:  MOVF   x88,F
042C:  BNZ   0436
042E:  MOVF   x87,F
0430:  BNZ   0436
0432:  CLRF   00
0434:  BRA    0478
0436:  BTFSC  x89.7
0438:  BRA    044A
043A:  BCF    FD8.0
043C:  RLCF   x86,F
043E:  RLCF   x87,F
0440:  RLCF   x88,F
0442:  RLCF   x89,F
0444:  DECFSZ 00,F
0446:  BRA    0436
0448:  BRA    0486
044A:  BTFSS  x84.7
044C:  BRA    0452
044E:  BSF    x89.7
0450:  BRA    0478
0452:  BCF    x89.7
0454:  BRA    0478
0456:  MOVFF  7F,00
045A:  MOVFF  80,89
045E:  MOVFF  81,88
0462:  MOVFF  82,87
0466:  BRA    0478
0468:  MOVFF  7B,00
046C:  MOVFF  7C,89
0470:  MOVFF  7D,88
0474:  MOVFF  7E,87
0478:  MOVFF  89,01
047C:  MOVFF  88,02
0480:  MOVFF  87,03
0484:  BRA    04EE
0486:  CLRF   00
0488:  CLRF   01
048A:  CLRF   02
048C:  CLRF   03
048E:  BRA    04EE
0490:  CLRF   x86
0492:  COMF   x87,F
0494:  COMF   x88,F
0496:  COMF   x89,F
0498:  COMF   x86,F
049A:  INCF   x86,F
049C:  BNZ   04A8
049E:  INCF   x87,F
04A0:  BNZ   04A8
04A2:  INCF   x88,F
04A4:  BNZ   04A8
04A6:  INCF   x89,F
04A8:  BTFSC  x85.0
04AA:  BRA    02D6
04AC:  BTFSC  x85.1
04AE:  BRA    035C
04B0:  BTFSC  x85.2
04B2:  BRA    03C8
04B4:  BRA    041C
04B6:  MOVF   FEF,W
04B8:  ADDWF  x87,F
04BA:  BNC   04C6
04BC:  INCF   x88,F
04BE:  BNZ   04C6
04C0:  INCF   x89,F
04C2:  BTFSC  FD8.2
04C4:  BSF    x83.0
04C6:  MOVF   FED,F
04C8:  MOVF   FEF,W
04CA:  ADDWF  x88,F
04CC:  BNC   04D4
04CE:  INCF   x89,F
04D0:  BTFSC  FD8.2
04D2:  BSF    x83.0
04D4:  MOVF   FED,F
04D6:  MOVF   FEF,W
04D8:  BTFSC  FEF.7
04DA:  BRA    04DE
04DC:  XORLW  80
04DE:  ADDWF  x89,F
04E0:  BTFSC  FD8.0
04E2:  BSF    x83.0
04E4:  BTFSC  x85.4
04E6:  BRA    02E4
04E8:  BTFSC  x85.5
04EA:  BRA    036A
04EC:  BRA    03D6
04EE:  RETURN 0
04F0:  MOVFF  78,7F
04F4:  MOVF   x7C,W
04F6:  XORWF  x7F,F
04F8:  BTFSS  x7F.7
04FA:  BRA    0506
04FC:  BCF    FD8.2
04FE:  BCF    FD8.0
0500:  BTFSC  x78.7
0502:  BSF    FD8.0
0504:  BRA    0564
0506:  MOVFF  78,7F
050A:  MOVFF  7B,80
050E:  MOVF   x77,W
0510:  SUBWF  x80,F
0512:  BZ    0520
0514:  BTFSS  x7F.7
0516:  BRA    0564
0518:  MOVF   FD8,W
051A:  XORLW  01
051C:  MOVWF  FD8
051E:  BRA    0564
0520:  MOVFF  7C,80
0524:  MOVF   x78,W
0526:  SUBWF  x80,F
0528:  BZ    0536
052A:  BTFSS  x7F.7
052C:  BRA    0564
052E:  MOVF   FD8,W
0530:  XORLW  01
0532:  MOVWF  FD8
0534:  BRA    0564
0536:  MOVFF  7D,80
053A:  MOVF   x79,W
053C:  SUBWF  x80,F
053E:  BZ    054C
0540:  BTFSS  x7F.7
0542:  BRA    0564
0544:  MOVF   FD8,W
0546:  XORLW  01
0548:  MOVWF  FD8
054A:  BRA    0564
054C:  MOVFF  7E,80
0550:  MOVF   x7A,W
0552:  SUBWF  x80,F
0554:  BZ    0562
0556:  BTFSS  x7F.7
0558:  BRA    0564
055A:  MOVF   FD8,W
055C:  XORLW  01
055E:  MOVWF  FD8
0560:  BRA    0564
0562:  BCF    FD8.0
0564:  RETURN 0
0566:  MOVLW  8E
0568:  MOVWF  00
056A:  MOVFF  6E,01
056E:  MOVFF  6D,02
0572:  CLRF   03
0574:  BTFSS  x6E.7
0576:  BRA    0582
0578:  COMF   01,F
057A:  COMF   02,F
057C:  INCF   02,F
057E:  BNZ   0582
0580:  INCF   01,F
0582:  MOVF   01,F
0584:  BNZ   0598
0586:  MOVFF  02,01
058A:  CLRF   02
058C:  MOVLW  08
058E:  SUBWF  00,F
0590:  MOVF   01,F
0592:  BNZ   0598
0594:  CLRF   00
0596:  BRA    05AC
0598:  BCF    FD8.0
059A:  BTFSC  01.7
059C:  BRA    05A6
059E:  RLCF   02,F
05A0:  RLCF   01,F
05A2:  DECF   00,F
05A4:  BRA    0598
05A6:  BTFSC  x6E.7
05A8:  BRA    05AC
05AA:  BCF    01.7
05AC:  RETURN 0
*
08EE:  MOVLW  8E
08F0:  MOVWF  00
08F2:  MOVF   x77,W
08F4:  SUBWF  00,F
08F6:  MOVFF  78,02
08FA:  MOVFF  79,01
08FE:  BSF    02.7
0900:  MOVF   00,F
0902:  BZ    0916
0904:  BCF    FD8.0
0906:  MOVF   02,F
0908:  BNZ   090E
090A:  MOVF   01,F
090C:  BZ    0916
090E:  RRCF   02,F
0910:  RRCF   01,F
0912:  DECFSZ 00,F
0914:  BRA    0904
0916:  BTFSS  x78.7
0918:  BRA    0924
091A:  COMF   01,F
091C:  COMF   02,F
091E:  INCF   01,F
0920:  BTFSC  FD8.2
0922:  INCF   02,F
0924:  RETURN 0
....................  
.................... #list 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
0926:  BCF    x76.0
....................    y = x; 
0928:  MOVFF  6A,6F
092C:  MOVFF  69,6E
0930:  MOVFF  68,6D
0934:  MOVFF  67,6C
....................  
....................    if (x < 0) 
0938:  MOVFF  6A,7A
093C:  MOVFF  69,79
0940:  MOVFF  68,78
0944:  MOVFF  67,77
0948:  CLRF   x7E
094A:  CLRF   x7D
094C:  CLRF   x7C
094E:  CLRF   x7B
0950:  RCALL  04F0
0952:  BNC   095C
....................    { 
....................       s = 1; 
0954:  BSF    x76.0
....................       y = -y; 
0956:  MOVF   x6D,W
0958:  XORLW  80
095A:  MOVWF  x6D
....................    } 
....................  
....................    if (y <= 32768.0) 
095C:  MOVFF  6F,7A
0960:  MOVFF  6E,79
0964:  MOVFF  6D,78
0968:  MOVFF  6C,77
096C:  CLRF   x7E
096E:  CLRF   x7D
0970:  CLRF   x7C
0972:  MOVLW  8E
0974:  MOVWF  x7B
0976:  RCALL  04F0
0978:  BC    097C
097A:  BNZ   09AC
....................       res = (float32)(unsigned int16)y; 
097C:  MOVFF  6F,7A
0980:  MOVFF  6E,79
0984:  MOVFF  6D,78
0988:  MOVFF  6C,77
098C:  RCALL  08EE
098E:  MOVFF  02,7C
0992:  MOVFF  01,7B
0996:  CALL   0004
099A:  MOVFF  03,73
099E:  MOVFF  02,72
09A2:  MOVFF  01,71
09A6:  MOVFF  00,70
09AA:  BRA    0B36
....................  
....................  else if (y < 10000000.0) 
09AC:  MOVFF  6F,7A
09B0:  MOVFF  6E,79
09B4:  MOVFF  6D,78
09B8:  MOVFF  6C,77
09BC:  MOVLW  80
09BE:  MOVWF  x7E
09C0:  MOVLW  96
09C2:  MOVWF  x7D
09C4:  MOVLW  18
09C6:  MOVWF  x7C
09C8:  MOVLW  96
09CA:  MOVWF  x7B
09CC:  RCALL  04F0
09CE:  BTFSS  FD8.0
09D0:  BRA    0B26
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
09D2:  MOVFF  6F,7A
09D6:  MOVFF  6E,79
09DA:  MOVFF  6D,78
09DE:  MOVFF  6C,77
09E2:  CLRF   x7E
09E4:  CLRF   x7D
09E6:  CLRF   x7C
09E8:  MOVLW  70
09EA:  MOVWF  x7B
09EC:  CALL   003A
09F0:  MOVFF  03,7A
09F4:  MOVFF  02,79
09F8:  MOVFF  01,78
09FC:  MOVFF  00,77
0A00:  RCALL  08EE
0A02:  MOVFF  02,75
0A06:  MOVFF  01,74
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
0A0A:  MOVFF  6F,7A
0A0E:  MOVFF  6E,79
0A12:  MOVFF  6D,78
0A16:  MOVFF  6C,77
0A1A:  CLRF   x7E
0A1C:  CLRF   x7D
0A1E:  CLRF   x7C
0A20:  MOVLW  70
0A22:  MOVWF  x7B
0A24:  CALL   003A
0A28:  MOVFF  03,7A
0A2C:  MOVFF  02,79
0A30:  MOVFF  01,78
0A34:  MOVFF  00,77
0A38:  MOVFF  75,7C
0A3C:  MOVFF  74,7B
0A40:  CALL   0004
0A44:  BSF    FD8.1
0A46:  MOVFF  7A,7E
0A4A:  MOVFF  79,7D
0A4E:  MOVFF  78,7C
0A52:  MOVFF  77,7B
0A56:  MOVFF  03,82
0A5A:  MOVFF  02,81
0A5E:  MOVFF  01,80
0A62:  MOVFF  00,7F
0A66:  RCALL  0286
0A68:  CLRF   x7A
0A6A:  CLRF   x79
0A6C:  CLRF   x78
0A6E:  MOVLW  8E
0A70:  MOVWF  x77
0A72:  MOVFF  03,7E
0A76:  MOVFF  02,7D
0A7A:  MOVFF  01,7C
0A7E:  MOVFF  00,7B
0A82:  CALL   003A
0A86:  MOVFF  03,6F
0A8A:  MOVFF  02,6E
0A8E:  MOVFF  01,6D
0A92:  MOVFF  00,6C
....................       res = 32768.0*(float32)l; 
0A96:  MOVFF  75,7C
0A9A:  MOVFF  74,7B
0A9E:  CALL   0004
0AA2:  CLRF   x7A
0AA4:  CLRF   x79
0AA6:  CLRF   x78
0AA8:  MOVLW  8E
0AAA:  MOVWF  x77
0AAC:  MOVFF  03,7E
0AB0:  MOVFF  02,7D
0AB4:  MOVFF  01,7C
0AB8:  MOVFF  00,7B
0ABC:  CALL   003A
0AC0:  MOVFF  03,73
0AC4:  MOVFF  02,72
0AC8:  MOVFF  01,71
0ACC:  MOVFF  00,70
....................       res += (float32)(unsigned int16)y; 
0AD0:  MOVFF  6F,7A
0AD4:  MOVFF  6E,79
0AD8:  MOVFF  6D,78
0ADC:  MOVFF  6C,77
0AE0:  RCALL  08EE
0AE2:  MOVFF  02,7C
0AE6:  MOVFF  01,7B
0AEA:  CALL   0004
0AEE:  BCF    FD8.1
0AF0:  MOVFF  73,7E
0AF4:  MOVFF  72,7D
0AF8:  MOVFF  71,7C
0AFC:  MOVFF  70,7B
0B00:  MOVFF  03,82
0B04:  MOVFF  02,81
0B08:  MOVFF  01,80
0B0C:  MOVFF  00,7F
0B10:  CALL   0286
0B14:  MOVFF  03,73
0B18:  MOVFF  02,72
0B1C:  MOVFF  01,71
0B20:  MOVFF  00,70
....................    } 
0B24:  BRA    0B36
....................  
....................  else 
....................   res = y; 
0B26:  MOVFF  6F,73
0B2A:  MOVFF  6E,72
0B2E:  MOVFF  6D,71
0B32:  MOVFF  6C,70
....................  
....................  y = y - (float32)(unsigned int16)y; 
0B36:  MOVFF  6F,7A
0B3A:  MOVFF  6E,79
0B3E:  MOVFF  6D,78
0B42:  MOVFF  6C,77
0B46:  RCALL  08EE
0B48:  MOVFF  02,7C
0B4C:  MOVFF  01,7B
0B50:  CALL   0004
0B54:  BSF    FD8.1
0B56:  MOVFF  6F,7E
0B5A:  MOVFF  6E,7D
0B5E:  MOVFF  6D,7C
0B62:  MOVFF  6C,7B
0B66:  MOVFF  03,82
0B6A:  MOVFF  02,81
0B6E:  MOVFF  01,80
0B72:  MOVFF  00,7F
0B76:  CALL   0286
0B7A:  MOVFF  03,6F
0B7E:  MOVFF  02,6E
0B82:  MOVFF  01,6D
0B86:  MOVFF  00,6C
....................  
....................  if (s) 
0B8A:  BTFSS  x76.0
0B8C:  BRA    0B94
....................   res = -res; 
0B8E:  MOVF   x71,W
0B90:  XORLW  80
0B92:  MOVWF  x71
....................  
....................  if (y != 0) 
0B94:  MOVFF  6F,7A
0B98:  MOVFF  6E,79
0B9C:  MOVFF  6D,78
0BA0:  MOVFF  6C,77
0BA4:  CLRF   x7E
0BA6:  CLRF   x7D
0BA8:  CLRF   x7C
0BAA:  CLRF   x7B
0BAC:  RCALL  04F0
0BAE:  BZ    0C20
....................  { 
....................   if (s == 1 && n == 0) 
0BB0:  BTFSS  x76.0
0BB2:  BRA    0BE8
0BB4:  MOVF   x6B,F
0BB6:  BNZ   0BE8
....................    res -= 1.0; 
0BB8:  BSF    FD8.1
0BBA:  MOVFF  73,7E
0BBE:  MOVFF  72,7D
0BC2:  MOVFF  71,7C
0BC6:  MOVFF  70,7B
0BCA:  CLRF   x82
0BCC:  CLRF   x81
0BCE:  CLRF   x80
0BD0:  MOVLW  7F
0BD2:  MOVWF  x7F
0BD4:  CALL   0286
0BD8:  MOVFF  03,73
0BDC:  MOVFF  02,72
0BE0:  MOVFF  01,71
0BE4:  MOVFF  00,70
....................  
....................   if (s == 0 && n == 1) 
0BE8:  BTFSC  x76.0
0BEA:  BRA    0C20
0BEC:  DECFSZ x6B,W
0BEE:  BRA    0C20
....................    res += 1.0; 
0BF0:  BCF    FD8.1
0BF2:  MOVFF  73,7E
0BF6:  MOVFF  72,7D
0BFA:  MOVFF  71,7C
0BFE:  MOVFF  70,7B
0C02:  CLRF   x82
0C04:  CLRF   x81
0C06:  CLRF   x80
0C08:  MOVLW  7F
0C0A:  MOVWF  x7F
0C0C:  CALL   0286
0C10:  MOVFF  03,73
0C14:  MOVFF  02,72
0C18:  MOVFF  01,71
0C1C:  MOVFF  00,70
....................  } 
....................  if (x == 0) 
0C20:  MOVFF  6A,7A
0C24:  MOVFF  69,79
0C28:  MOVFF  68,78
0C2C:  MOVFF  67,77
0C30:  CLRF   x7E
0C32:  CLRF   x7D
0C34:  CLRF   x7C
0C36:  CLRF   x7B
0C38:  RCALL  04F0
0C3A:  BNZ   0C44
....................     res = 0; 
0C3C:  CLRF   x73
0C3E:  CLRF   x72
0C40:  CLRF   x71
0C42:  CLRF   x70
....................  
....................  return (res); 
0C44:  MOVFF  70,00
0C48:  MOVFF  71,01
0C4C:  MOVFF  72,02
0C50:  MOVFF  73,03
0C54:  RETURN 0
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
*
0C70:  MOVFF  66,6A
0C74:  MOVFF  65,69
0C78:  MOVFF  64,68
0C7C:  MOVFF  63,67
0C80:  CLRF   x6B
0C82:  RCALL  0926
0C84:  GOTO   0D86 (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
0C56:  MOVFF  66,6A
0C5A:  MOVFF  65,69
0C5E:  MOVFF  64,68
0C62:  MOVFF  63,67
0C66:  MOVLW  01
0C68:  MOVWF  x6B
0C6A:  RCALL  0926
0C6C:  GOTO   0D3E (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
*
0C88:  MOVFF  5A,7A
0C8C:  MOVFF  59,79
0C90:  MOVFF  58,78
0C94:  MOVFF  57,77
0C98:  CLRF   x7E
0C9A:  CLRF   x7D
0C9C:  CLRF   x7C
0C9E:  CLRF   x7B
0CA0:  RCALL  04F0
0CA2:  BTFSC  FD8.2
0CA4:  BRA    0DE2
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
0CA6:  MOVFF  56,73
0CAA:  MOVFF  55,72
0CAE:  MOVFF  54,71
0CB2:  MOVFF  53,70
0CB6:  MOVFF  5A,77
0CBA:  MOVFF  59,76
0CBE:  MOVFF  58,75
0CC2:  MOVFF  57,74
0CC6:  CALL   012C
0CCA:  MOVFF  03,62
0CCE:  MOVFF  02,61
0CD2:  MOVFF  01,60
0CD6:  MOVFF  00,5F
0CDA:  MOVFF  03,7A
0CDE:  MOVFF  02,79
0CE2:  MOVFF  01,78
0CE6:  MOVFF  00,77
0CEA:  CLRF   x7E
0CEC:  CLRF   x7D
0CEE:  CLRF   x7C
0CF0:  CLRF   x7B
0CF2:  CALL   04F0
0CF6:  BNC   0D40
0CF8:  MOVFF  56,73
0CFC:  MOVFF  55,72
0D00:  MOVFF  54,71
0D04:  MOVFF  53,70
0D08:  MOVFF  5A,77
0D0C:  MOVFF  59,76
0D10:  MOVFF  58,75
0D14:  MOVFF  57,74
0D18:  CALL   012C
0D1C:  MOVFF  03,62
0D20:  MOVFF  02,61
0D24:  MOVFF  01,60
0D28:  MOVFF  00,5F
0D2C:  MOVFF  03,66
0D30:  MOVFF  02,65
0D34:  MOVFF  01,64
0D38:  MOVFF  00,63
0D3C:  BRA    0C56
0D3E:  BRA    0D86
0D40:  MOVFF  56,73
0D44:  MOVFF  55,72
0D48:  MOVFF  54,71
0D4C:  MOVFF  53,70
0D50:  MOVFF  5A,77
0D54:  MOVFF  59,76
0D58:  MOVFF  58,75
0D5C:  MOVFF  57,74
0D60:  CALL   012C
0D64:  MOVFF  03,62
0D68:  MOVFF  02,61
0D6C:  MOVFF  01,60
0D70:  MOVFF  00,5F
0D74:  MOVFF  03,66
0D78:  MOVFF  02,65
0D7C:  MOVFF  01,64
0D80:  MOVFF  00,63
0D84:  BRA    0C70
0D86:  MOVFF  03,5E
0D8A:  MOVFF  02,5D
0D8E:  MOVFF  01,5C
0D92:  MOVFF  00,5B
....................       return(x-(i*y)); 
0D96:  MOVFF  5E,7A
0D9A:  MOVFF  5D,79
0D9E:  MOVFF  5C,78
0DA2:  MOVFF  5B,77
0DA6:  MOVFF  5A,7E
0DAA:  MOVFF  59,7D
0DAE:  MOVFF  58,7C
0DB2:  MOVFF  57,7B
0DB6:  CALL   003A
0DBA:  BSF    FD8.1
0DBC:  MOVFF  56,7E
0DC0:  MOVFF  55,7D
0DC4:  MOVFF  54,7C
0DC8:  MOVFF  53,7B
0DCC:  MOVFF  03,82
0DD0:  MOVFF  02,81
0DD4:  MOVFF  01,80
0DD8:  MOVFF  00,7F
0DDC:  CALL   0286
0DE0:  BRA    0DE2
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
0DE2:  RETURN 0
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
0DE4:  MOVFF  5A,7A
0DE8:  MOVFF  59,79
0DEC:  MOVFF  58,78
0DF0:  MOVFF  57,77
0DF4:  MOVLW  3B
0DF6:  MOVWF  x7E
0DF8:  MOVLW  AA
0DFA:  MOVWF  x7D
0DFC:  MOVLW  38
0DFE:  MOVWF  x7C
0E00:  MOVLW  7F
0E02:  MOVWF  x7B
0E04:  CALL   003A
0E08:  MOVFF  03,7A
0E0C:  MOVFF  02,79
0E10:  MOVFF  01,78
0E14:  MOVFF  00,77
0E18:  RCALL  08EE
0E1A:  MOVFF  01,67
....................    s = 0; 
0E1E:  BCF    x68.0
....................    y = x; 
0E20:  MOVFF  5A,5E
0E24:  MOVFF  59,5D
0E28:  MOVFF  58,5C
0E2C:  MOVFF  57,5B
....................  
....................    if (x < 0) 
0E30:  MOVFF  5A,7A
0E34:  MOVFF  59,79
0E38:  MOVFF  58,78
0E3C:  MOVFF  57,77
0E40:  CLRF   x7E
0E42:  CLRF   x7D
0E44:  CLRF   x7C
0E46:  CLRF   x7B
0E48:  CALL   04F0
0E4C:  BNC   0E58
....................    { 
....................       s = 1; 
0E4E:  BSF    x68.0
....................       n = -n; 
0E50:  NEGF   x67
....................       y = -y; 
0E52:  MOVF   5C,W
0E54:  XORLW  80
0E56:  MOVWF  5C
....................    } 
....................  
....................    res = 0.0; 
0E58:  CLRF   x62
0E5A:  CLRF   x61
0E5C:  CLRF   x60
0E5E:  CLRF   5F
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
0E60:  CLRF   x6A
0E62:  MOVLW  5F
0E64:  MOVWF  FE9
0E66:  MOVFF  6A,FEA
0E6A:  MOVLW  7F
0E6C:  ADDWF  x67,W
0E6E:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
0E70:  MOVFF  5E,7A
0E74:  MOVFF  5D,79
0E78:  MOVFF  5C,78
0E7C:  MOVFF  5B,77
0E80:  MOVLW  3B
0E82:  MOVWF  x7E
0E84:  MOVLW  AA
0E86:  MOVWF  x7D
0E88:  MOVLW  38
0E8A:  MOVWF  x7C
0E8C:  MOVLW  7F
0E8E:  MOVWF  x7B
0E90:  CALL   003A
0E94:  MOVFF  03,6C
0E98:  MOVFF  02,6B
0E9C:  MOVFF  01,6A
0EA0:  MOVFF  00,69
0EA4:  CLRF   x6E
0EA6:  MOVFF  67,6D
0EAA:  BTFSC  x6D.7
0EAC:  DECF   x6E,F
0EAE:  CALL   0566
0EB2:  BSF    FD8.1
0EB4:  MOVFF  6C,7E
0EB8:  MOVFF  6B,7D
0EBC:  MOVFF  6A,7C
0EC0:  MOVFF  69,7B
0EC4:  MOVFF  03,82
0EC8:  MOVFF  02,81
0ECC:  MOVFF  01,80
0ED0:  MOVFF  00,7F
0ED4:  CALL   0286
0ED8:  MOVFF  03,5E
0EDC:  MOVFF  02,5D
0EE0:  MOVFF  01,5C
0EE4:  MOVFF  00,5B
....................  
....................    r = pe[0]*y + pe[1]; 
0EE8:  MOVLW  7C
0EEA:  MOVWF  x7A
0EEC:  MOVLW  88
0EEE:  MOVWF  x79
0EF0:  MOVLW  59
0EF2:  MOVWF  x78
0EF4:  MOVLW  72
0EF6:  MOVWF  x77
0EF8:  MOVFF  5E,7E
0EFC:  MOVFF  5D,7D
0F00:  MOVFF  5C,7C
0F04:  MOVFF  5B,7B
0F08:  CALL   003A
0F0C:  MOVFF  03,6C
0F10:  MOVFF  02,6B
0F14:  MOVFF  01,6A
0F18:  MOVFF  00,69
0F1C:  BCF    FD8.1
0F1E:  MOVFF  03,7E
0F22:  MOVFF  02,7D
0F26:  MOVFF  01,7C
0F2A:  MOVFF  00,7B
0F2E:  MOVLW  E0
0F30:  MOVWF  x82
0F32:  MOVLW  97
0F34:  MOVWF  x81
0F36:  MOVLW  26
0F38:  MOVWF  x80
0F3A:  MOVLW  75
0F3C:  MOVWF  x7F
0F3E:  CALL   0286
0F42:  MOVFF  03,66
0F46:  MOVFF  02,65
0F4A:  MOVFF  01,64
0F4E:  MOVFF  00,63
....................    r = r*y + pe[2]; 
0F52:  MOVFF  66,7A
0F56:  MOVFF  65,79
0F5A:  MOVFF  64,78
0F5E:  MOVFF  63,77
0F62:  MOVFF  5E,7E
0F66:  MOVFF  5D,7D
0F6A:  MOVFF  5C,7C
0F6E:  MOVFF  5B,7B
0F72:  CALL   003A
0F76:  MOVFF  03,6C
0F7A:  MOVFF  02,6B
0F7E:  MOVFF  01,6A
0F82:  MOVFF  00,69
0F86:  BCF    FD8.1
0F88:  MOVFF  03,7E
0F8C:  MOVFF  02,7D
0F90:  MOVFF  01,7C
0F94:  MOVFF  00,7B
0F98:  MOVLW  C4
0F9A:  MOVWF  x82
0F9C:  MOVLW  1D
0F9E:  MOVWF  x81
0FA0:  MOVLW  1E
0FA2:  MOVWF  x80
0FA4:  MOVLW  78
0FA6:  MOVWF  x7F
0FA8:  CALL   0286
0FAC:  MOVFF  03,66
0FB0:  MOVFF  02,65
0FB4:  MOVFF  01,64
0FB8:  MOVFF  00,63
....................    r = r*y + pe[3]; 
0FBC:  MOVFF  66,7A
0FC0:  MOVFF  65,79
0FC4:  MOVFF  64,78
0FC8:  MOVFF  63,77
0FCC:  MOVFF  5E,7E
0FD0:  MOVFF  5D,7D
0FD4:  MOVFF  5C,7C
0FD8:  MOVFF  5B,7B
0FDC:  CALL   003A
0FE0:  MOVFF  03,6C
0FE4:  MOVFF  02,6B
0FE8:  MOVFF  01,6A
0FEC:  MOVFF  00,69
0FF0:  BCF    FD8.1
0FF2:  MOVFF  03,7E
0FF6:  MOVFF  02,7D
0FFA:  MOVFF  01,7C
0FFE:  MOVFF  00,7B
1002:  MOVLW  5E
1004:  MOVWF  x82
1006:  MOVLW  50
1008:  MOVWF  x81
100A:  MOVLW  63
100C:  MOVWF  x80
100E:  MOVLW  7A
1010:  MOVWF  x7F
1012:  CALL   0286
1016:  MOVFF  03,66
101A:  MOVFF  02,65
101E:  MOVFF  01,64
1022:  MOVFF  00,63
....................    r = r*y + pe[4]; 
1026:  MOVFF  66,7A
102A:  MOVFF  65,79
102E:  MOVFF  64,78
1032:  MOVFF  63,77
1036:  MOVFF  5E,7E
103A:  MOVFF  5D,7D
103E:  MOVFF  5C,7C
1042:  MOVFF  5B,7B
1046:  CALL   003A
104A:  MOVFF  03,6C
104E:  MOVFF  02,6B
1052:  MOVFF  01,6A
1056:  MOVFF  00,69
105A:  BCF    FD8.1
105C:  MOVFF  03,7E
1060:  MOVFF  02,7D
1064:  MOVFF  01,7C
1068:  MOVFF  00,7B
106C:  MOVLW  1A
106E:  MOVWF  x82
1070:  MOVLW  FE
1072:  MOVWF  x81
1074:  MOVLW  75
1076:  MOVWF  x80
1078:  MOVLW  7C
107A:  MOVWF  x7F
107C:  CALL   0286
1080:  MOVFF  03,66
1084:  MOVFF  02,65
1088:  MOVFF  01,64
108C:  MOVFF  00,63
....................    r = r*y + pe[5]; 
1090:  MOVFF  66,7A
1094:  MOVFF  65,79
1098:  MOVFF  64,78
109C:  MOVFF  63,77
10A0:  MOVFF  5E,7E
10A4:  MOVFF  5D,7D
10A8:  MOVFF  5C,7C
10AC:  MOVFF  5B,7B
10B0:  CALL   003A
10B4:  MOVFF  03,6C
10B8:  MOVFF  02,6B
10BC:  MOVFF  01,6A
10C0:  MOVFF  00,69
10C4:  BCF    FD8.1
10C6:  MOVFF  03,7E
10CA:  MOVFF  02,7D
10CE:  MOVFF  01,7C
10D2:  MOVFF  00,7B
10D6:  MOVLW  18
10D8:  MOVWF  x82
10DA:  MOVLW  72
10DC:  MOVWF  x81
10DE:  MOVLW  31
10E0:  MOVWF  x80
10E2:  MOVLW  7E
10E4:  MOVWF  x7F
10E6:  CALL   0286
10EA:  MOVFF  03,66
10EE:  MOVFF  02,65
10F2:  MOVFF  01,64
10F6:  MOVFF  00,63
....................  
....................    res = res*(1.0 + y*r); 
10FA:  MOVFF  5E,7A
10FE:  MOVFF  5D,79
1102:  MOVFF  5C,78
1106:  MOVFF  5B,77
110A:  MOVFF  66,7E
110E:  MOVFF  65,7D
1112:  MOVFF  64,7C
1116:  MOVFF  63,7B
111A:  CALL   003A
111E:  BCF    FD8.1
1120:  CLRF   x7E
1122:  CLRF   x7D
1124:  CLRF   x7C
1126:  MOVLW  7F
1128:  MOVWF  x7B
112A:  MOVFF  03,82
112E:  MOVFF  02,81
1132:  MOVFF  01,80
1136:  MOVFF  00,7F
113A:  CALL   0286
113E:  MOVFF  62,7A
1142:  MOVFF  61,79
1146:  MOVFF  60,78
114A:  MOVFF  5F,77
114E:  MOVFF  03,7E
1152:  MOVFF  02,7D
1156:  MOVFF  01,7C
115A:  MOVFF  00,7B
115E:  CALL   003A
1162:  MOVFF  03,62
1166:  MOVFF  02,61
116A:  MOVFF  01,60
116E:  MOVFF  00,5F
....................  
....................    if (s) 
1172:  BTFSS  x68.0
1174:  BRA    11A4
....................       res = 1.0/res; 
1176:  CLRF   x73
1178:  CLRF   x72
117A:  CLRF   x71
117C:  MOVLW  7F
117E:  MOVWF  x70
1180:  MOVFF  62,77
1184:  MOVFF  61,76
1188:  MOVFF  60,75
118C:  MOVFF  5F,74
1190:  CALL   012C
1194:  MOVFF  03,62
1198:  MOVFF  02,61
119C:  MOVFF  01,60
11A0:  MOVFF  00,5F
....................    return(res); 
11A4:  MOVFF  5F,00
11A8:  MOVFF  60,01
11AC:  MOVFF  61,02
11B0:  MOVFF  62,03
11B4:  RETURN 0
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
*
05AE:  MOVFF  5A,5E
05B2:  MOVFF  59,5D
05B6:  MOVFF  58,5C
05BA:  MOVFF  57,5B
....................  
....................    if (y != 1.0) 
05BE:  MOVFF  5E,7A
05C2:  MOVFF  5D,79
05C6:  MOVFF  5C,78
05CA:  MOVFF  5B,77
05CE:  CLRF   x7E
05D0:  CLRF   x7D
05D2:  CLRF   x7C
05D4:  MOVLW  7F
05D6:  MOVWF  x7B
05D8:  RCALL  04F0
05DA:  BTFSC  FD8.2
05DC:  BRA    08D4
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
05DE:  CLRF   x6D
05E0:  MOVLW  5B
05E2:  MOVWF  FE9
05E4:  MOVFF  6D,FEA
05E8:  MOVLW  7E
05EA:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
05EC:  BSF    FD8.1
05EE:  MOVFF  5E,7E
05F2:  MOVFF  5D,7D
05F6:  MOVFF  5C,7C
05FA:  MOVFF  5B,7B
05FE:  CLRF   x82
0600:  CLRF   x81
0602:  CLRF   x80
0604:  MOVLW  7F
0606:  MOVWF  x7F
0608:  RCALL  0286
060A:  MOVFF  03,6F
060E:  MOVFF  02,6E
0612:  MOVFF  01,6D
0616:  MOVFF  00,6C
061A:  BCF    FD8.1
061C:  MOVFF  5E,7E
0620:  MOVFF  5D,7D
0624:  MOVFF  5C,7C
0628:  MOVFF  5B,7B
062C:  CLRF   x82
062E:  CLRF   x81
0630:  CLRF   x80
0632:  MOVLW  7F
0634:  MOVWF  x7F
0636:  RCALL  0286
0638:  MOVFF  6F,73
063C:  MOVFF  6E,72
0640:  MOVFF  6D,71
0644:  MOVFF  6C,70
0648:  MOVFF  03,77
064C:  MOVFF  02,76
0650:  MOVFF  01,75
0654:  MOVFF  00,74
0658:  RCALL  012C
065A:  MOVFF  03,5E
065E:  MOVFF  02,5D
0662:  MOVFF  01,5C
0666:  MOVFF  00,5B
....................  
....................       y2=y*y; 
066A:  MOVFF  5E,7A
066E:  MOVFF  5D,79
0672:  MOVFF  5C,78
0676:  MOVFF  5B,77
067A:  MOVFF  5E,7E
067E:  MOVFF  5D,7D
0682:  MOVFF  5C,7C
0686:  MOVFF  5B,7B
068A:  RCALL  003A
068C:  MOVFF  03,6A
0690:  MOVFF  02,69
0694:  MOVFF  01,68
0698:  MOVFF  00,67
....................  
....................       res = pl[0]*y2 + pl[1]; 
069C:  MOVLW  99
069E:  MOVWF  x7A
06A0:  MOVLW  47
06A2:  MOVWF  x79
06A4:  MOVLW  8A
06A6:  MOVWF  x78
06A8:  MOVLW  7F
06AA:  MOVWF  x77
06AC:  MOVFF  6A,7E
06B0:  MOVFF  69,7D
06B4:  MOVFF  68,7C
06B8:  MOVFF  67,7B
06BC:  RCALL  003A
06BE:  MOVFF  03,6F
06C2:  MOVFF  02,6E
06C6:  MOVFF  01,6D
06CA:  MOVFF  00,6C
06CE:  BCF    FD8.1
06D0:  MOVFF  03,7E
06D4:  MOVFF  02,7D
06D8:  MOVFF  01,7C
06DC:  MOVFF  00,7B
06E0:  CLRF   x82
06E2:  CLRF   x81
06E4:  CLRF   x80
06E6:  MOVLW  80
06E8:  MOVWF  x7F
06EA:  RCALL  0286
06EC:  MOVFF  03,62
06F0:  MOVFF  02,61
06F4:  MOVFF  01,60
06F8:  MOVFF  00,5F
....................  
....................       r = ql[0]*y2 + ql[1]; 
06FC:  MOVLW  4C
06FE:  MOVWF  x7A
0700:  MOVLW  F3
0702:  MOVWF  x79
0704:  MOVLW  3A
0706:  MOVWF  x78
0708:  MOVLW  7B
070A:  MOVWF  x77
070C:  MOVFF  6A,7E
0710:  MOVFF  69,7D
0714:  MOVFF  68,7C
0718:  MOVFF  67,7B
071C:  RCALL  003A
071E:  MOVFF  03,6F
0722:  MOVFF  02,6E
0726:  MOVFF  01,6D
072A:  MOVFF  00,6C
072E:  BCF    FD8.1
0730:  MOVFF  03,7E
0734:  MOVFF  02,7D
0738:  MOVFF  01,7C
073C:  MOVFF  00,7B
0740:  MOVLW  2B
0742:  MOVWF  x82
0744:  MOVLW  9D
0746:  MOVWF  x81
0748:  MOVLW  DF
074A:  MOVWF  x80
074C:  MOVLW  7E
074E:  MOVWF  x7F
0750:  RCALL  0286
0752:  MOVFF  03,66
0756:  MOVFF  02,65
075A:  MOVFF  01,64
075E:  MOVFF  00,63
....................       r = r*y2 + 1.0; 
0762:  MOVFF  66,7A
0766:  MOVFF  65,79
076A:  MOVFF  64,78
076E:  MOVFF  63,77
0772:  MOVFF  6A,7E
0776:  MOVFF  69,7D
077A:  MOVFF  68,7C
077E:  MOVFF  67,7B
0782:  RCALL  003A
0784:  MOVFF  03,6F
0788:  MOVFF  02,6E
078C:  MOVFF  01,6D
0790:  MOVFF  00,6C
0794:  BCF    FD8.1
0796:  MOVFF  03,7E
079A:  MOVFF  02,7D
079E:  MOVFF  01,7C
07A2:  MOVFF  00,7B
07A6:  CLRF   x82
07A8:  CLRF   x81
07AA:  CLRF   x80
07AC:  MOVLW  7F
07AE:  MOVWF  x7F
07B0:  RCALL  0286
07B2:  MOVFF  03,66
07B6:  MOVFF  02,65
07BA:  MOVFF  01,64
07BE:  MOVFF  00,63
....................  
....................       res = y*res/r; 
07C2:  MOVFF  5E,7A
07C6:  MOVFF  5D,79
07CA:  MOVFF  5C,78
07CE:  MOVFF  5B,77
07D2:  MOVFF  62,7E
07D6:  MOVFF  61,7D
07DA:  MOVFF  60,7C
07DE:  MOVFF  5F,7B
07E2:  RCALL  003A
07E4:  MOVFF  03,6F
07E8:  MOVFF  02,6E
07EC:  MOVFF  01,6D
07F0:  MOVFF  00,6C
07F4:  MOVFF  03,73
07F8:  MOVFF  02,72
07FC:  MOVFF  01,71
0800:  MOVFF  00,70
0804:  MOVFF  66,77
0808:  MOVFF  65,76
080C:  MOVFF  64,75
0810:  MOVFF  63,74
0814:  RCALL  012C
0816:  MOVFF  03,62
081A:  MOVFF  02,61
081E:  MOVFF  01,60
0822:  MOVFF  00,5F
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
0826:  CLRF   x6D
0828:  MOVLW  57
082A:  MOVWF  FE9
082C:  MOVFF  6D,FEA
0830:  MOVLW  7E
0832:  SUBWF  FEF,W
0834:  MOVWF  x6B
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
0836:  BTFSS  x6B.7
0838:  BRA    085E
....................          r = -(float32)-n; 
083A:  MOVLW  00
083C:  BSF    FD8.0
083E:  SUBFWB x6B,W
0840:  CLRF   x6E
0842:  MOVWF  x6D
0844:  BTFSC  x6D.7
0846:  DECF   x6E,F
0848:  RCALL  0566
084A:  MOVFF  00,63
084E:  MOVF   01,W
0850:  XORLW  80
0852:  MOVWF  x64
0854:  MOVFF  02,65
0858:  MOVFF  03,66
085C:  BRA    087A
....................       else 
....................          r = (float32)n; 
085E:  CLRF   x6E
0860:  MOVFF  6B,6D
0864:  BTFSC  x6D.7
0866:  DECF   x6E,F
0868:  RCALL  0566
086A:  MOVFF  03,66
086E:  MOVFF  02,65
0872:  MOVFF  01,64
0876:  MOVFF  00,63
....................  
....................       res += r*LN2; 
087A:  MOVFF  66,7A
087E:  MOVFF  65,79
0882:  MOVFF  64,78
0886:  MOVFF  63,77
088A:  MOVLW  18
088C:  MOVWF  x7E
088E:  MOVLW  72
0890:  MOVWF  x7D
0892:  MOVLW  31
0894:  MOVWF  x7C
0896:  MOVLW  7E
0898:  MOVWF  x7B
089A:  CALL   003A
089E:  BCF    FD8.1
08A0:  MOVFF  62,7E
08A4:  MOVFF  61,7D
08A8:  MOVFF  60,7C
08AC:  MOVFF  5F,7B
08B0:  MOVFF  03,82
08B4:  MOVFF  02,81
08B8:  MOVFF  01,80
08BC:  MOVFF  00,7F
08C0:  RCALL  0286
08C2:  MOVFF  03,62
08C6:  MOVFF  02,61
08CA:  MOVFF  01,60
08CE:  MOVFF  00,5F
....................    } 
08D2:  BRA    08DC
....................  
....................    else 
....................       res = 0.0; 
08D4:  CLRF   x62
08D6:  CLRF   x61
08D8:  CLRF   x60
08DA:  CLRF   5F
....................  
....................    return(res); 
08DC:  MOVFF  5F,00
08E0:  MOVFF  60,01
08E4:  MOVFF  61,02
08E8:  MOVFF  62,03
08EC:  RETURN 0
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
*
11B6:  MOVFF  4E,7A
11BA:  MOVFF  4D,79
11BE:  MOVFF  4C,78
11C2:  MOVFF  4B,77
11C6:  CLRF   x7E
11C8:  CLRF   x7D
11CA:  CLRF   x7C
11CC:  CLRF   x7B
11CE:  CALL   04F0
11D2:  BTFSS  FD8.0
11D4:  BRA    136C
11D6:  MOVFF  52,56
11DA:  MOVFF  51,55
11DE:  MOVFF  50,54
11E2:  MOVFF  4F,53
11E6:  CLRF   5A
11E8:  CLRF   59
11EA:  CLRF   58
11EC:  MOVLW  7F
11EE:  MOVWF  57
11F0:  RCALL  0C88
11F2:  MOVFF  03,56
11F6:  MOVFF  02,55
11FA:  MOVFF  01,54
11FE:  MOVFF  00,53
1202:  MOVFF  03,7A
1206:  MOVFF  02,79
120A:  MOVFF  01,78
120E:  MOVFF  00,77
1212:  CLRF   x7E
1214:  CLRF   x7D
1216:  CLRF   x7C
1218:  CLRF   x7B
121A:  CALL   04F0
121E:  BTFSS  FD8.2
1220:  BRA    136C
....................       if(fmod(y, 2) == 0) { 
1222:  MOVFF  52,56
1226:  MOVFF  51,55
122A:  MOVFF  50,54
122E:  MOVFF  4F,53
1232:  CLRF   5A
1234:  CLRF   59
1236:  CLRF   58
1238:  MOVLW  80
123A:  MOVWF  57
123C:  RCALL  0C88
123E:  MOVFF  03,56
1242:  MOVFF  02,55
1246:  MOVFF  01,54
124A:  MOVFF  00,53
124E:  MOVFF  03,7A
1252:  MOVFF  02,79
1256:  MOVFF  01,78
125A:  MOVFF  00,77
125E:  CLRF   x7E
1260:  CLRF   x7D
1262:  CLRF   x7C
1264:  CLRF   x7B
1266:  CALL   04F0
126A:  BNZ   12EA
....................          return (exp(log(-x) * y)); 
126C:  MOVFF  4B,53
1270:  MOVF   4C,W
1272:  XORLW  80
1274:  MOVWF  54
1276:  MOVFF  4D,55
127A:  MOVFF  4E,56
127E:  MOVFF  4E,5A
1282:  MOVFF  4D,59
1286:  MOVWF  58
1288:  MOVFF  4B,57
128C:  CALL   05AE
1290:  MOVFF  03,56
1294:  MOVFF  02,55
1298:  MOVFF  01,54
129C:  MOVFF  00,53
12A0:  MOVFF  03,7A
12A4:  MOVFF  02,79
12A8:  MOVFF  01,78
12AC:  MOVFF  00,77
12B0:  MOVFF  52,7E
12B4:  MOVFF  51,7D
12B8:  MOVFF  50,7C
12BC:  MOVFF  4F,7B
12C0:  CALL   003A
12C4:  MOVFF  03,56
12C8:  MOVFF  02,55
12CC:  MOVFF  01,54
12D0:  MOVFF  00,53
12D4:  MOVFF  03,5A
12D8:  MOVFF  02,59
12DC:  MOVFF  01,58
12E0:  MOVFF  00,57
12E4:  RCALL  0DE4
12E6:  BRA    1488
....................       } else { 
12E8:  BRA    136A
....................          return (-exp(log(-x) * y)); 
12EA:  MOVFF  4B,53
12EE:  MOVF   4C,W
12F0:  XORLW  80
12F2:  MOVWF  54
12F4:  MOVFF  4D,55
12F8:  MOVFF  4E,56
12FC:  MOVFF  4E,5A
1300:  MOVFF  4D,59
1304:  MOVWF  58
1306:  MOVFF  4B,57
130A:  CALL   05AE
130E:  MOVFF  03,56
1312:  MOVFF  02,55
1316:  MOVFF  01,54
131A:  MOVFF  00,53
131E:  MOVFF  03,7A
1322:  MOVFF  02,79
1326:  MOVFF  01,78
132A:  MOVFF  00,77
132E:  MOVFF  52,7E
1332:  MOVFF  51,7D
1336:  MOVFF  50,7C
133A:  MOVFF  4F,7B
133E:  CALL   003A
1342:  MOVFF  03,56
1346:  MOVFF  02,55
134A:  MOVFF  01,54
134E:  MOVFF  00,53
1352:  MOVFF  03,5A
1356:  MOVFF  02,59
135A:  MOVFF  01,58
135E:  MOVFF  00,57
1362:  RCALL  0DE4
1364:  MOVLW  80
1366:  XORWF  01,F
1368:  BRA    1488
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
136A:  BRA    1488
136C:  MOVFF  4E,7A
1370:  MOVFF  4D,79
1374:  MOVFF  4C,78
1378:  MOVFF  4B,77
137C:  CLRF   x7E
137E:  CLRF   x7D
1380:  CLRF   x7C
1382:  CLRF   x7B
1384:  CALL   04F0
1388:  BNC   13E0
138A:  MOVFF  52,56
138E:  MOVFF  51,55
1392:  MOVFF  50,54
1396:  MOVFF  4F,53
139A:  CLRF   5A
139C:  CLRF   59
139E:  CLRF   58
13A0:  MOVLW  7F
13A2:  MOVWF  57
13A4:  RCALL  0C88
13A6:  MOVFF  03,56
13AA:  MOVFF  02,55
13AE:  MOVFF  01,54
13B2:  MOVFF  00,53
13B6:  MOVFF  03,7A
13BA:  MOVFF  02,79
13BE:  MOVFF  01,78
13C2:  MOVFF  00,77
13C6:  CLRF   x7E
13C8:  CLRF   x7D
13CA:  CLRF   x7C
13CC:  CLRF   x7B
13CE:  CALL   04F0
13D2:  BZ    13E0
....................       return 0; 
13D4:  CLRF   00
13D6:  CLRF   01
13D8:  CLRF   02
13DA:  CLRF   03
13DC:  BRA    1488
....................    } else { 
13DE:  BRA    1488
....................       if(x != 0 || 0 >= y) { 
13E0:  MOVFF  4E,7A
13E4:  MOVFF  4D,79
13E8:  MOVFF  4C,78
13EC:  MOVFF  4B,77
13F0:  CLRF   x7E
13F2:  CLRF   x7D
13F4:  CLRF   x7C
13F6:  CLRF   x7B
13F8:  CALL   04F0
13FC:  BNZ   141E
13FE:  MOVFF  52,7A
1402:  MOVFF  51,79
1406:  MOVFF  50,78
140A:  MOVFF  4F,77
140E:  CLRF   x7E
1410:  CLRF   x7D
1412:  CLRF   x7C
1414:  CLRF   x7B
1416:  CALL   04F0
141A:  BC    141E
141C:  BNZ   1488
....................          return (exp(log(x) * y)); 
141E:  MOVFF  4E,5A
1422:  MOVFF  4D,59
1426:  MOVFF  4C,58
142A:  MOVFF  4B,57
142E:  CALL   05AE
1432:  MOVFF  03,56
1436:  MOVFF  02,55
143A:  MOVFF  01,54
143E:  MOVFF  00,53
1442:  MOVFF  03,7A
1446:  MOVFF  02,79
144A:  MOVFF  01,78
144E:  MOVFF  00,77
1452:  MOVFF  52,7E
1456:  MOVFF  51,7D
145A:  MOVFF  50,7C
145E:  MOVFF  4F,7B
1462:  CALL   003A
1466:  MOVFF  03,56
146A:  MOVFF  02,55
146E:  MOVFF  01,54
1472:  MOVFF  00,53
1476:  MOVFF  03,5A
147A:  MOVFF  02,59
147E:  MOVFF  01,58
1482:  MOVFF  00,57
1486:  RCALL  0DE4
....................       } 
....................    } 
1488:  GOTO   1622 (RETURN)
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #fuses XT,NOWDT,PUT,NOBROWNOUT,NOLVP    // bits de configuração 
.................... #use   delay(clock=20000000)// definir isso direito  
.................... //modo rápido de inicialização das portas 
.................... #use   fast_io(a) 
.................... #use   fast_io(b) 
.................... #use   fast_io(d) 
.................... #use   fast_io(e) 
.................... #byte   porta = 0xf80 // atribui o nome "porta" ao registrador do port 0xf80 
.................... #byte   portb = 0xf81  
.................... #byte   portd = 0xf83 
.................... #byte   porte = 0xf84 
....................  
....................  
.................... // pinos de entrada 
.................... #bit NTC = porta.0 
.................... #bit DHT11 = porta.1 
.................... #bit POT_SET_TEMP = porta.2 
.................... #bit POT_SET_UMI = porta.3 
.................... #bit BOT_BLK_LTH = portb.0 
.................... #bit BOT_MORE_INF = portb.1 
.................... // pinos de saida 
.................... #bit RELE_LAMP = portb.2 
.................... #bit PIN_IN1_MOTPAS = portb.3 
.................... #bit PIN_IN2_MOTPAS = portb.4 
.................... #bit PIN_IN3_MOTPAS = portb.5 
.................... #bit PIN_IN4_MOTPAS = portb.6 
.................... #bit PIN_COOLER = portb.7 
.................... //#bit Data_Pin = 0x06.7            // Pin mapped to PORTB.7      //CONFIGURAR ISSO PARA O PINO CERTO E DO 18F4550 
.................... //#bit Data_Pin_Direction = 0x86.7             // Pin direction mapped to TRISB.7 
.................... char message2[] = "RH   = 00.0 %"; 
.................... short Time_out; 
.................... unsigned  int8 RH_byte1, RH_byte2, CheckSum; 
....................  
.................... float ntc_val = 0; 
.................... float rntc = 0; 
.................... float b1=0; 
.................... float c1=0; 
.................... float temp=0; 
.................... float temperatura; 
.................... float umidade; 
.................... const float a = 0.0011303; 
.................... const float b = 0.0002339; 
.................... const double c = 0.00000008863; 
.................... char WaveStep[] = {4, 0b0001, 0b0010, 0b0100, 0b1000}; 
.................... char FullStep[] = {4, 0b0011, 0b0110, 0b1100, 0b1001}; 
.................... char HalfStep[] = {8, 0b0001, 0b0011, 0b0010, 0b0110, 0b00100, 0b1100, 0b1000, 0b1001}; 
.................... // FUNÇÃO POR INICIAR A DHT11 
....................  
.................... /*void start_signal(){ 
....................    Data_Pin_Direction = 0;           // Configure connection pin as output 
....................   Data_Pin = 0;                        // Connection pin output low 
....................     delay_ms(25); 
....................      Data_Pin = 1;                        // Connection pin output high 
....................   delay_us(30);  
....................    Data_Pin_Direction = 1;              // Configure connection pin as input 
.................... }*/ 
....................  
.................... // FUNÇAÕ POR VERIFICAR SE O SENSOR ESTA RESPONDENDO  
.................... /*short check_response(){ 
....................   delay_us(40);  
....................   if(!Data_Pin){                     // Read and test if connection pin is low 
....................   delay_us(80); 
....................   if(//Data_Pin){                    // Read and test if connection pin is high 
....................   delay_us(50); 
....................   return 1;} 
....................   } 
....................   } 
.................... */ 
....................  
.................... // FUNÇÃO PARA A OBTENÇÃO DO VALOR DE HUMIDADE 
.................... /*unsigned int8 Read_Data(){ 
....................  unsigned int8 i, k, _data = 0; // k is used to count 1 bit reading duration 
....................  if(Time_out) 
....................  break; 
....................  for(i=0;i<8;i++){ 
....................   k=0; 
....................  while(!Data_Pin){                         // Wait until pin goes high 
....................       k++; 
....................       if (k > 100) {Time_out = 1; break;} 
....................       delay_us(1);} 
....................     delay_us(30); 
....................     if(!Data_Pin) 
....................       bit_clear(_data, (7 - i));               // Clear bit (7 - i) 
....................     else{ 
....................       bit_set(_data, (7 - i));                 // Set bit (7 - i) 
....................       while(Data_Pin){                         // Wait until pin goes low 
....................       k++; 
....................       if (k > 100) {Time_out = 1; break;} 
....................       delay_us(1);} 
....................     } 
....................   } 
....................   return _data; 
.................... }*/ 
....................  
.................... // FUNÇÃO PRINCIPAL QUE RETORNARA A UMIDADE  
.................... /*void dht11(){ 
....................    delay_ms(1000); 
....................    Time_out = 0; 
....................     
....................    Start_signal(); 
....................    if(check_response()){                    // If there is response from sensor 
....................    RH_byte1 = Read_Data();                 // read RH byte1 
....................    RH_byte2 = Read_Data();                 // read RH byte2 
....................    Checksum = Read_Data();                 // read checksum                    
....................           if(CheckSum == ((RH_Byte1 + RH_Byte2) & 0xFF)){                    
....................              message2[7]  = RH_Byte1/10 + 48; 
....................              message2[8]  = RH_Byte1%10 + 48; 
....................              message2[10] = RH_Byte2/10 + 48; 
....................              /*  lcd_putc('\f');                       // LCD clear 
....................              lcd_gotoxy(1, 2);                     // Go to column 1 row 2 
....................              printf(lcd_putc, message2);           // Display message2                                 
....................            } 
....................                         } 
....................    return message2; 
.................... }*/ 
....................  
....................  
....................  
....................  
....................  
.................... float ntc(){ 
.................... set_adc_channel(0); //  escolhe o pino analogico para ler  
148C:  MOVLW  00
148E:  MOVWF  01
1490:  MOVF   FC2,W
1492:  ANDLW  C3
1494:  IORWF  01,W
1496:  MOVWF  FC2
.................... delay_us(10); // delay para começar a conversão  
1498:  MOVLW  10
149A:  MOVWF  00
149C:  DECFSZ 00,F
149E:  BRA    149C
14A0:  NOP   
.................... ntc_val = read_adc(); // le o valor na porta analogica 
14A2:  BSF    FC2.1
14A4:  BTFSC  FC2.1
14A6:  BRA    14A4
14A8:  MOVF   FC4,W
14AA:  CLRF   x7C
14AC:  MOVWF  x7B
14AE:  CALL   0004
14B2:  MOVFF  03,1F
14B6:  MOVFF  02,1E
14BA:  MOVFF  01,1D
14BE:  MOVFF  00,1C
.................... ntc_val *=5; //  
14C2:  MOVFF  1F,7A
14C6:  MOVFF  1E,79
14CA:  MOVFF  1D,78
14CE:  MOVFF  1C,77
14D2:  CLRF   x7E
14D4:  CLRF   x7D
14D6:  MOVLW  20
14D8:  MOVWF  x7C
14DA:  MOVLW  81
14DC:  MOVWF  x7B
14DE:  CALL   003A
14E2:  MOVFF  03,1F
14E6:  MOVFF  02,1E
14EA:  MOVFF  01,1D
14EE:  MOVFF  00,1C
.................... ntc_val/=1023; 
14F2:  MOVFF  1F,73
14F6:  MOVFF  1E,72
14FA:  MOVFF  1D,71
14FE:  MOVFF  1C,70
1502:  CLRF   x77
1504:  MOVLW  C0
1506:  MOVWF  x76
1508:  MOVLW  7F
150A:  MOVWF  x75
150C:  MOVLW  88
150E:  MOVWF  x74
1510:  CALL   012C
1514:  MOVFF  03,1F
1518:  MOVFF  02,1E
151C:  MOVFF  01,1D
1520:  MOVFF  00,1C
.................... rntc=33000/ntc_val;     
1524:  CLRF   x73
1526:  MOVLW  E8
1528:  MOVWF  x72
152A:  CLRF   x71
152C:  MOVLW  8E
152E:  MOVWF  x70
1530:  MOVFF  1F,77
1534:  MOVFF  1E,76
1538:  MOVFF  1D,75
153C:  MOVFF  1C,74
1540:  CALL   012C
1544:  MOVFF  03,23
1548:  MOVFF  02,22
154C:  MOVFF  01,21
1550:  MOVFF  00,20
....................        rntc=rntc-10000;       
1554:  BSF    FD8.1
1556:  MOVFF  23,7E
155A:  MOVFF  22,7D
155E:  MOVFF  21,7C
1562:  MOVFF  20,7B
1566:  CLRF   x82
1568:  MOVLW  40
156A:  MOVWF  x81
156C:  MOVLW  1C
156E:  MOVWF  x80
1570:  MOVLW  8C
1572:  MOVWF  x7F
1574:  CALL   0286
1578:  MOVFF  03,23
157C:  MOVFF  02,22
1580:  MOVFF  01,21
1584:  MOVFF  00,20
....................        b1=log(rntc);           
1588:  MOVFF  23,5A
158C:  MOVFF  22,59
1590:  MOVFF  21,58
1594:  MOVFF  20,57
1598:  CALL   05AE
159C:  MOVFF  03,27
15A0:  MOVFF  02,26
15A4:  MOVFF  01,25
15A8:  MOVFF  00,24
....................        b1=b1*b;                
15AC:  MOVFF  27,7A
15B0:  MOVFF  26,79
15B4:  MOVFF  25,78
15B8:  MOVFF  24,77
15BC:  MOVLW  0E
15BE:  MOVWF  x7E
15C0:  MOVLW  43
15C2:  MOVWF  x7D
15C4:  MOVLW  75
15C6:  MOVWF  x7C
15C8:  MOVLW  72
15CA:  MOVWF  x7B
15CC:  CALL   003A
15D0:  MOVFF  03,27
15D4:  MOVFF  02,26
15D8:  MOVFF  01,25
15DC:  MOVFF  00,24
....................        c1=log(rntc);           
15E0:  MOVFF  23,5A
15E4:  MOVFF  22,59
15E8:  MOVFF  21,58
15EC:  MOVFF  20,57
15F0:  CALL   05AE
15F4:  MOVFF  03,2B
15F8:  MOVFF  02,2A
15FC:  MOVFF  01,29
1600:  MOVFF  00,28
....................        c1=pow(c1,3);           
1604:  MOVFF  2B,4E
1608:  MOVFF  2A,4D
160C:  MOVFF  29,4C
1610:  MOVFF  28,4B
1614:  CLRF   52
1616:  CLRF   51
1618:  MOVLW  40
161A:  MOVWF  50
161C:  MOVLW  80
161E:  MOVWF  4F
1620:  BRA    11B6
1622:  MOVFF  03,2B
1626:  MOVFF  02,2A
162A:  MOVFF  01,29
162E:  MOVFF  00,28
....................        c1=c1*c;                
1632:  MOVFF  2B,7A
1636:  MOVFF  2A,79
163A:  MOVFF  29,78
163E:  MOVFF  28,77
1642:  MOVLW  DC
1644:  MOVWF  x7E
1646:  MOVLW  54
1648:  MOVWF  x7D
164A:  MOVLW  3E
164C:  MOVWF  x7C
164E:  MOVLW  67
1650:  MOVWF  x7B
1652:  CALL   003A
1656:  MOVFF  03,2B
165A:  MOVFF  02,2A
165E:  MOVFF  01,29
1662:  MOVFF  00,28
....................        temp=a+b1+c1;           
1666:  BCF    FD8.1
1668:  MOVLW  93
166A:  MOVWF  x7E
166C:  MOVLW  26
166E:  MOVWF  x7D
1670:  MOVLW  14
1672:  MOVWF  x7C
1674:  MOVLW  75
1676:  MOVWF  x7B
1678:  MOVFF  27,82
167C:  MOVFF  26,81
1680:  MOVFF  25,80
1684:  MOVFF  24,7F
1688:  CALL   0286
168C:  MOVFF  03,4E
1690:  MOVFF  02,4D
1694:  MOVFF  01,4C
1698:  MOVFF  00,4B
169C:  BCF    FD8.1
169E:  MOVFF  03,7E
16A2:  MOVFF  02,7D
16A6:  MOVFF  01,7C
16AA:  MOVFF  00,7B
16AE:  MOVFF  2B,82
16B2:  MOVFF  2A,81
16B6:  MOVFF  29,80
16BA:  MOVFF  28,7F
16BE:  CALL   0286
16C2:  MOVFF  03,2F
16C6:  MOVFF  02,2E
16CA:  MOVFF  01,2D
16CE:  MOVFF  00,2C
....................        temp=1/temp;            
16D2:  CLRF   x73
16D4:  CLRF   x72
16D6:  CLRF   x71
16D8:  MOVLW  7F
16DA:  MOVWF  x70
16DC:  MOVFF  2F,77
16E0:  MOVFF  2E,76
16E4:  MOVFF  2D,75
16E8:  MOVFF  2C,74
16EC:  CALL   012C
16F0:  MOVFF  03,2F
16F4:  MOVFF  02,2E
16F8:  MOVFF  01,2D
16FC:  MOVFF  00,2C
....................        temp=temp-273.15; 
1700:  BSF    FD8.1
1702:  MOVFF  2F,7E
1706:  MOVFF  2E,7D
170A:  MOVFF  2D,7C
170E:  MOVFF  2C,7B
1712:  MOVLW  33
1714:  MOVWF  x82
1716:  MOVLW  93
1718:  MOVWF  x81
171A:  MOVLW  08
171C:  MOVWF  x80
171E:  MOVLW  87
1720:  MOVWF  x7F
1722:  CALL   0286
1726:  MOVFF  03,2F
172A:  MOVFF  02,2E
172E:  MOVFF  01,2D
1732:  MOVFF  00,2C
....................        return temp; 
1736:  MOVFF  2C,00
173A:  MOVFF  2D,01
173E:  MOVFF  2E,02
1742:  MOVFF  2F,03
1746:  GOTO   1812 (RETURN)
....................  
.................... } 
....................  
....................  
....................  
....................  
.................... void main (void){ 
174A:  CLRF   FF8
174C:  BCF    FD0.7
174E:  CLRF   1F
1750:  CLRF   1E
1752:  CLRF   1D
1754:  CLRF   1C
1756:  CLRF   23
1758:  CLRF   22
175A:  CLRF   21
175C:  CLRF   20
175E:  CLRF   27
1760:  CLRF   26
1762:  CLRF   25
1764:  CLRF   24
1766:  CLRF   2B
1768:  CLRF   2A
176A:  CLRF   29
176C:  CLRF   28
176E:  CLRF   2F
1770:  CLRF   2E
1772:  CLRF   2D
1774:  CLRF   2C
1776:  MOVF   FC1,W
1778:  ANDLW  C0
177A:  IORLW  0F
177C:  MOVWF  FC1
177E:  MOVLW  07
1780:  MOVWF  FB4
1782:  BRA    17B2
1784:  DATA 02,00
1786:  DATA 04,00
1788:  DATA 00,0E
178A:  DATA 00,0A
178C:  DATA 52,48
178E:  DATA A0,A0
1790:  DATA A0,3D
1792:  DATA A0,30
1794:  DATA 30,2E
1796:  DATA 30,A0
1798:  DATA 25,00
179A:  DATA 13,00
179C:  DATA 38,04
179E:  DATA 01,02
17A0:  DATA 04,08
17A2:  DATA 04,03
17A4:  DATA 06,0C
17A6:  DATA 09,08
17A8:  DATA 01,03
17AA:  DATA 02,06
17AC:  DATA 04,0C
17AE:  DATA 08,09
17B0:  DATA 00,00
17B2:  MOVLW  00
17B4:  MOVWF  FF8
17B6:  MOVLW  17
17B8:  MOVWF  FF7
17BA:  MOVLW  84
17BC:  MOVWF  FF6
17BE:  TBLRD*+
17C0:  MOVF   FF5,W
17C2:  MOVWF  00
17C4:  XORLW  00
17C6:  BZ    17EE
17C8:  TBLRD*+
17CA:  MOVF   FF5,W
17CC:  MOVWF  01
17CE:  BTFSC  FE8.7
17D0:  BRA    17DC
17D2:  ANDLW  0F
17D4:  MOVWF  FEA
17D6:  TBLRD*+
17D8:  MOVFF  FF5,FE9
17DC:  BTFSC  01.6
17DE:  TBLRD*+
17E0:  BTFSS  01.6
17E2:  TBLRD*+
17E4:  MOVFF  FF5,FEE
17E8:  DCFSNZ 00,F
17EA:  BRA    17BE
17EC:  BRA    17E0
17EE:  CLRF   FF8
.................... setup_adc(  ADC_CLOCK_INTERNAL  ); //  configura o clock utilizado para o conversor ad 
17F0:  MOVF   FC0,W
17F2:  ANDLW  C0
17F4:  IORLW  07
17F6:  MOVWF  FC0
17F8:  BCF    FC0.7
17FA:  BSF    FC2.0
.................... setup_adc_ports( AN0_TO_AN3 ); 
17FC:  MOVF   FC1,W
17FE:  ANDLW  C0
1800:  IORLW  0B
1802:  MOVWF  FC1
.................... //set_tris_a(0b00001111); // verificar se pinos analogicos necessitam de definição de tris 
.................... set_tris_b(0b11000000);  // define os pinos RB0 E RB1 como entrada e os demais como saida 
1804:  MOVLW  C0
1806:  MOVWF  F93
.................... set_tris_d(0b00000000); 
1808:  MOVLW  00
180A:  MOVWF  F95
.................... set_tris_e(0b00000100); 
180C:  MOVLW  04
180E:  MOVWF  F96
....................   
....................  
....................  
....................   while(true){ 
....................    
....................   temperatura = ntc(); 
1810:  BRA    148C
1812:  MOVFF  03,33
1816:  MOVFF  02,32
181A:  MOVFF  01,31
181E:  MOVFF  00,30
....................  //umidade = dht11(); 
....................    
....................     if(temperatura>38){ 
1822:  CLRF   x7A
1824:  CLRF   x79
1826:  MOVLW  18
1828:  MOVWF  x78
182A:  MOVLW  84
182C:  MOVWF  x77
182E:  MOVFF  33,7E
1832:  MOVFF  32,7D
1836:  MOVFF  31,7C
183A:  MOVFF  30,7B
183E:  CALL   04F0
1842:  BNC   1846
....................     PIN_COOLER =1 ; 
1844:  BSF    F81.7
....................      
....................      
....................      
....................     } 
1846:  BRA    1810
....................      
....................    
....................    
....................   
....................    
....................    
....................    
....................    
....................    
....................    
....................   } 
....................    
....................    
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... } 
1848:  SLEEP 

Configuration Fuses:
   Word  1: C03F   PLL12 CPUDIV4 USBDIV XT FCMEN IESO
   Word  2: 1E38   PUT NOBROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
