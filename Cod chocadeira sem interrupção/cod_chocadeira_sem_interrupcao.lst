CCS PCH C Compiler, Version 5.015, 5967               26-jun-17 18:20

               Filename:   C:\Users\henri\Documents\GitHub\Projeto-chocadeira\Cod chocadeira sem interrupção\cod_chocadeira_sem_interrupcao.lst

               ROM used:   7688 bytes (23%)
                           Largest free fragment is 25080
               RAM used:   54 (3%) at main() level
                           118 (6%) worst case
               Stack used: 6 locations
               Stack size: 31

*
0000:  GOTO   1CD0
....................  
.................... #INCLUDE<18F4550.h>//   Inclui a biblioteca resposável por estabelecer os parametros do pic utilizado no projeto 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
0004:  DATA 4D,45
0006:  DATA 58,45
0008:  DATA 4E,44
000A:  DATA 4F,00
*
00B2:  TBLRD*+
00B4:  MOVF   FF5,F
00B6:  BZ    00D0
00B8:  MOVFF  FF6,38
00BC:  MOVFF  FF7,39
00C0:  MOVFF  FF5,43
00C4:  RCALL  0096
00C6:  MOVFF  38,FF6
00CA:  MOVFF  39,FF7
00CE:  BRA    00B2
00D0:  GOTO   0108 (RETURN)
*
01A2:  MOVLW  8E
01A4:  MOVWF  00
01A6:  MOVFF  67,01
01AA:  MOVFF  66,02
01AE:  CLRF   03
01B0:  MOVF   01,F
01B2:  BNZ   01C6
01B4:  MOVFF  02,01
01B8:  CLRF   02
01BA:  MOVLW  08
01BC:  SUBWF  00,F
01BE:  MOVF   01,F
01C0:  BNZ   01C6
01C2:  CLRF   00
01C4:  BRA    01D6
01C6:  BCF    FD8.0
01C8:  BTFSC  01.7
01CA:  BRA    01D4
01CC:  RLCF   02,F
01CE:  RLCF   01,F
01D0:  DECF   00,F
01D2:  BRA    01C6
01D4:  BCF    01.7
01D6:  RETURN 0
01D8:  MOVF   x62,W
01DA:  BTFSC  FD8.2
01DC:  BRA    02C0
01DE:  MOVWF  00
01E0:  MOVF   x66,W
01E2:  BTFSC  FD8.2
01E4:  BRA    02C0
01E6:  ADDWF  00,F
01E8:  BNC   01F2
01EA:  MOVLW  81
01EC:  ADDWF  00,F
01EE:  BC    02C0
01F0:  BRA    01FA
01F2:  MOVLW  7F
01F4:  SUBWF  00,F
01F6:  BNC   02C0
01F8:  BZ    02C0
01FA:  MOVFF  63,6A
01FE:  MOVF   x67,W
0200:  XORWF  x6A,F
0202:  BSF    x63.7
0204:  BSF    x67.7
0206:  MOVF   x65,W
0208:  MULWF  x69
020A:  MOVFF  FF4,6C
020E:  MOVF   x64,W
0210:  MULWF  x68
0212:  MOVFF  FF4,03
0216:  MOVFF  FF3,6B
021A:  MULWF  x69
021C:  MOVF   FF3,W
021E:  ADDWF  x6C,F
0220:  MOVF   FF4,W
0222:  ADDWFC x6B,F
0224:  MOVLW  00
0226:  ADDWFC 03,F
0228:  MOVF   x65,W
022A:  MULWF  x68
022C:  MOVF   FF3,W
022E:  ADDWF  x6C,F
0230:  MOVF   FF4,W
0232:  ADDWFC x6B,F
0234:  MOVLW  00
0236:  CLRF   02
0238:  ADDWFC 03,F
023A:  ADDWFC 02,F
023C:  MOVF   x63,W
023E:  MULWF  x69
0240:  MOVF   FF3,W
0242:  ADDWF  x6B,F
0244:  MOVF   FF4,W
0246:  ADDWFC 03,F
0248:  MOVLW  00
024A:  ADDWFC 02,F
024C:  MOVF   x63,W
024E:  MULWF  x68
0250:  MOVF   FF3,W
0252:  ADDWF  03,F
0254:  MOVF   FF4,W
0256:  ADDWFC 02,F
0258:  MOVLW  00
025A:  CLRF   01
025C:  ADDWFC 01,F
025E:  MOVF   x65,W
0260:  MULWF  x67
0262:  MOVF   FF3,W
0264:  ADDWF  x6B,F
0266:  MOVF   FF4,W
0268:  ADDWFC 03,F
026A:  MOVLW  00
026C:  ADDWFC 02,F
026E:  ADDWFC 01,F
0270:  MOVF   x64,W
0272:  MULWF  x67
0274:  MOVF   FF3,W
0276:  ADDWF  03,F
0278:  MOVF   FF4,W
027A:  ADDWFC 02,F
027C:  MOVLW  00
027E:  ADDWFC 01,F
0280:  MOVF   x63,W
0282:  MULWF  x67
0284:  MOVF   FF3,W
0286:  ADDWF  02,F
0288:  MOVF   FF4,W
028A:  ADDWFC 01,F
028C:  INCF   00,F
028E:  BTFSC  01.7
0290:  BRA    029C
0292:  RLCF   x6B,F
0294:  RLCF   03,F
0296:  RLCF   02,F
0298:  RLCF   01,F
029A:  DECF   00,F
029C:  MOVLW  00
029E:  BTFSS  x6B.7
02A0:  BRA    02B6
02A2:  INCF   03,F
02A4:  ADDWFC 02,F
02A6:  ADDWFC 01,F
02A8:  MOVF   01,W
02AA:  BNZ   02B6
02AC:  MOVF   02,W
02AE:  BNZ   02B6
02B0:  MOVF   03,W
02B2:  BNZ   02B6
02B4:  INCF   00,F
02B6:  BTFSC  x6A.7
02B8:  BSF    01.7
02BA:  BTFSS  x6A.7
02BC:  BCF    01.7
02BE:  BRA    02C8
02C0:  CLRF   00
02C2:  CLRF   01
02C4:  CLRF   02
02C6:  CLRF   03
02C8:  RETURN 0
02CA:  MOVF   5B,W
02CC:  BTFSC  FD8.2
02CE:  BRA    041A
02D0:  MOVWF  x67
02D2:  MOVF   5F,W
02D4:  BTFSC  FD8.2
02D6:  BRA    041A
02D8:  SUBWF  x67,F
02DA:  BNC   02E6
02DC:  MOVLW  7F
02DE:  ADDWF  x67,F
02E0:  BTFSC  FD8.0
02E2:  BRA    041A
02E4:  BRA    02F2
02E6:  MOVLW  81
02E8:  SUBWF  x67,F
02EA:  BTFSS  FD8.0
02EC:  BRA    041A
02EE:  BTFSC  FD8.2
02F0:  BRA    041A
02F2:  MOVFF  67,00
02F6:  CLRF   01
02F8:  CLRF   02
02FA:  CLRF   03
02FC:  CLRF   x66
02FE:  MOVFF  5C,65
0302:  BSF    x65.7
0304:  MOVFF  5D,64
0308:  MOVFF  5E,63
030C:  MOVLW  19
030E:  MOVWF  x67
0310:  MOVF   x62,W
0312:  SUBWF  x63,F
0314:  BC    0330
0316:  MOVLW  01
0318:  SUBWF  x64,F
031A:  BC    0330
031C:  SUBWF  x65,F
031E:  BC    0330
0320:  SUBWF  x66,F
0322:  BC    0330
0324:  INCF   x66,F
0326:  INCF   x65,F
0328:  INCF   x64,F
032A:  MOVF   x62,W
032C:  ADDWF  x63,F
032E:  BRA    0380
0330:  MOVF   x61,W
0332:  SUBWF  x64,F
0334:  BC    035A
0336:  MOVLW  01
0338:  SUBWF  x65,F
033A:  BC    035A
033C:  SUBWF  x66,F
033E:  BC    035A
0340:  INCF   x66,F
0342:  INCF   x65,F
0344:  MOVF   x61,W
0346:  ADDWF  x64,F
0348:  MOVF   x62,W
034A:  ADDWF  x63,F
034C:  BNC   0380
034E:  INCF   x64,F
0350:  BNZ   0380
0352:  INCF   x65,F
0354:  BNZ   0380
0356:  INCF   x66,F
0358:  BRA    0380
035A:  MOVF   x60,W
035C:  IORLW  80
035E:  SUBWF  x65,F
0360:  BC    037E
0362:  MOVLW  01
0364:  SUBWF  x66,F
0366:  BC    037E
0368:  INCF   x66,F
036A:  MOVF   x60,W
036C:  IORLW  80
036E:  ADDWF  x65,F
0370:  MOVF   x61,W
0372:  ADDWF  x64,F
0374:  BNC   0348
0376:  INCF   x65,F
0378:  BNZ   0348
037A:  INCF   x66,F
037C:  BRA    0348
037E:  BSF    03.0
0380:  DECFSZ x67,F
0382:  BRA    0386
0384:  BRA    039C
0386:  BCF    FD8.0
0388:  RLCF   x63,F
038A:  RLCF   x64,F
038C:  RLCF   x65,F
038E:  RLCF   x66,F
0390:  BCF    FD8.0
0392:  RLCF   03,F
0394:  RLCF   02,F
0396:  RLCF   01,F
0398:  RLCF   x68,F
039A:  BRA    0310
039C:  BTFSS  x68.0
039E:  BRA    03AC
03A0:  BCF    FD8.0
03A2:  RRCF   01,F
03A4:  RRCF   02,F
03A6:  RRCF   03,F
03A8:  RRCF   x68,F
03AA:  BRA    03B0
03AC:  DECF   00,F
03AE:  BZ    041A
03B0:  BTFSC  x68.7
03B2:  BRA    03F0
03B4:  BCF    FD8.0
03B6:  RLCF   x63,F
03B8:  RLCF   x64,F
03BA:  RLCF   x65,F
03BC:  RLCF   x66,F
03BE:  MOVF   x62,W
03C0:  SUBWF  x63,F
03C2:  BC    03D2
03C4:  MOVLW  01
03C6:  SUBWF  x64,F
03C8:  BC    03D2
03CA:  SUBWF  x65,F
03CC:  BC    03D2
03CE:  SUBWF  x66,F
03D0:  BNC   0406
03D2:  MOVF   x61,W
03D4:  SUBWF  x64,F
03D6:  BC    03E2
03D8:  MOVLW  01
03DA:  SUBWF  x65,F
03DC:  BC    03E2
03DE:  SUBWF  x66,F
03E0:  BNC   0406
03E2:  MOVF   x60,W
03E4:  IORLW  80
03E6:  SUBWF  x65,F
03E8:  BC    03F0
03EA:  MOVLW  01
03EC:  SUBWF  x66,F
03EE:  BNC   0406
03F0:  INCF   03,F
03F2:  BNZ   0406
03F4:  INCF   02,F
03F6:  BNZ   0406
03F8:  INCF   01,F
03FA:  BNZ   0406
03FC:  INCF   00,F
03FE:  BZ    041A
0400:  RRCF   01,F
0402:  RRCF   02,F
0404:  RRCF   03,F
0406:  MOVFF  5C,67
040A:  MOVF   x60,W
040C:  XORWF  x67,F
040E:  BTFSS  x67.7
0410:  BRA    0416
0412:  BSF    01.7
0414:  BRA    0422
0416:  BCF    01.7
0418:  BRA    0422
041A:  CLRF   00
041C:  CLRF   01
041E:  CLRF   02
0420:  CLRF   03
0422:  RETURN 0
0424:  MOVLW  80
0426:  BTFSC  FD8.1
0428:  XORWF  x6B,F
042A:  CLRF   x70
042C:  CLRF   x71
042E:  MOVFF  67,6F
0432:  MOVF   x6B,W
0434:  XORWF  x6F,F
0436:  MOVF   x66,W
0438:  BTFSC  FD8.2
043A:  BRA    05F4
043C:  MOVWF  x6E
043E:  MOVWF  00
0440:  MOVF   x6A,W
0442:  BTFSC  FD8.2
0444:  BRA    0606
0446:  SUBWF  x6E,F
0448:  BTFSC  FD8.2
044A:  BRA    054E
044C:  BNC   04C8
044E:  MOVFF  6B,74
0452:  BSF    x74.7
0454:  MOVFF  6C,73
0458:  MOVFF  6D,72
045C:  CLRF   x71
045E:  BCF    FD8.0
0460:  RRCF   x74,F
0462:  RRCF   x73,F
0464:  RRCF   x72,F
0466:  RRCF   x71,F
0468:  DECFSZ x6E,F
046A:  BRA    045C
046C:  BTFSS  x6F.7
046E:  BRA    0476
0470:  BSF    x70.0
0472:  BRA    062E
0474:  BCF    x70.0
0476:  BCF    x6E.0
0478:  BSF    x70.4
047A:  CLRF   FEA
047C:  MOVLW  69
047E:  MOVWF  FE9
0480:  BRA    0654
0482:  BCF    x70.4
0484:  BTFSC  x6F.7
0486:  BRA    049C
0488:  BTFSS  x6E.0
048A:  BRA    04B2
048C:  RRCF   x74,F
048E:  RRCF   x73,F
0490:  RRCF   x72,F
0492:  RRCF   x71,F
0494:  INCF   00,F
0496:  BTFSC  FD8.2
0498:  BRA    0624
049A:  BRA    04B2
049C:  BTFSC  x74.7
049E:  BRA    04B8
04A0:  BCF    FD8.0
04A2:  RLCF   x71,F
04A4:  RLCF   x72,F
04A6:  RLCF   x73,F
04A8:  RLCF   x74,F
04AA:  DECF   00,F
04AC:  BTFSC  FD8.2
04AE:  BRA    0624
04B0:  BRA    049C
04B2:  BSF    x70.6
04B4:  BRA    058C
04B6:  BCF    x70.6
04B8:  MOVFF  67,6F
04BC:  BTFSS  x67.7
04BE:  BRA    04C4
04C0:  BSF    x74.7
04C2:  BRA    0616
04C4:  BCF    x74.7
04C6:  BRA    0616
04C8:  MOVFF  6A,6E
04CC:  MOVFF  6A,00
04D0:  MOVF   x66,W
04D2:  SUBWF  x6E,F
04D4:  MOVFF  67,74
04D8:  BSF    x74.7
04DA:  MOVFF  68,73
04DE:  MOVFF  69,72
04E2:  CLRF   x71
04E4:  BCF    FD8.0
04E6:  RRCF   x74,F
04E8:  RRCF   x73,F
04EA:  RRCF   x72,F
04EC:  RRCF   x71,F
04EE:  DECFSZ x6E,F
04F0:  BRA    04E2
04F2:  BTFSS  x6F.7
04F4:  BRA    04FC
04F6:  BSF    x70.1
04F8:  BRA    062E
04FA:  BCF    x70.1
04FC:  BCF    x6E.0
04FE:  BSF    x70.5
0500:  CLRF   FEA
0502:  MOVLW  6D
0504:  MOVWF  FE9
0506:  BRA    0654
0508:  BCF    x70.5
050A:  BTFSC  x6F.7
050C:  BRA    0522
050E:  BTFSS  x6E.0
0510:  BRA    0538
0512:  RRCF   x74,F
0514:  RRCF   x73,F
0516:  RRCF   x72,F
0518:  RRCF   x71,F
051A:  INCF   00,F
051C:  BTFSC  FD8.2
051E:  BRA    0624
0520:  BRA    0538
0522:  BTFSC  x74.7
0524:  BRA    053E
0526:  BCF    FD8.0
0528:  RLCF   x71,F
052A:  RLCF   x72,F
052C:  RLCF   x73,F
052E:  RLCF   x74,F
0530:  DECF   00,F
0532:  BTFSC  FD8.2
0534:  BRA    0624
0536:  BRA    0522
0538:  BSF    x70.7
053A:  BRA    058C
053C:  BCF    x70.7
053E:  MOVFF  6B,6F
0542:  BTFSS  x6B.7
0544:  BRA    054A
0546:  BSF    x74.7
0548:  BRA    0616
054A:  BCF    x74.7
054C:  BRA    0616
054E:  MOVFF  6B,74
0552:  BSF    x74.7
0554:  MOVFF  6C,73
0558:  MOVFF  6D,72
055C:  BTFSS  x6F.7
055E:  BRA    0568
0560:  BCF    x74.7
0562:  BSF    x70.2
0564:  BRA    062E
0566:  BCF    x70.2
0568:  CLRF   x71
056A:  BCF    x6E.0
056C:  CLRF   FEA
056E:  MOVLW  69
0570:  MOVWF  FE9
0572:  BRA    0654
0574:  BTFSC  x6F.7
0576:  BRA    05B0
0578:  MOVFF  67,6F
057C:  BTFSS  x6E.0
057E:  BRA    058C
0580:  RRCF   x74,F
0582:  RRCF   x73,F
0584:  RRCF   x72,F
0586:  RRCF   x71,F
0588:  INCF   00,F
058A:  BZ    0624
058C:  BTFSS  x71.7
058E:  BRA    05A6
0590:  INCF   x72,F
0592:  BNZ   05A6
0594:  INCF   x73,F
0596:  BNZ   05A6
0598:  INCF   x74,F
059A:  BNZ   05A6
059C:  RRCF   x74,F
059E:  RRCF   x73,F
05A0:  RRCF   x72,F
05A2:  INCF   00,F
05A4:  BZ    0624
05A6:  BTFSC  x70.6
05A8:  BRA    04B6
05AA:  BTFSC  x70.7
05AC:  BRA    053C
05AE:  BRA    05E8
05B0:  MOVLW  80
05B2:  XORWF  x74,F
05B4:  BTFSS  x74.7
05B6:  BRA    05C0
05B8:  BRA    062E
05BA:  MOVFF  6B,6F
05BE:  BRA    05D4
05C0:  MOVFF  67,6F
05C4:  MOVF   x74,F
05C6:  BNZ   05D4
05C8:  MOVF   x73,F
05CA:  BNZ   05D4
05CC:  MOVF   x72,F
05CE:  BNZ   05D4
05D0:  CLRF   00
05D2:  BRA    0616
05D4:  BTFSC  x74.7
05D6:  BRA    05E8
05D8:  BCF    FD8.0
05DA:  RLCF   x71,F
05DC:  RLCF   x72,F
05DE:  RLCF   x73,F
05E0:  RLCF   x74,F
05E2:  DECFSZ 00,F
05E4:  BRA    05D4
05E6:  BRA    0624
05E8:  BTFSS  x6F.7
05EA:  BRA    05F0
05EC:  BSF    x74.7
05EE:  BRA    0616
05F0:  BCF    x74.7
05F2:  BRA    0616
05F4:  MOVFF  6A,00
05F8:  MOVFF  6B,74
05FC:  MOVFF  6C,73
0600:  MOVFF  6D,72
0604:  BRA    0616
0606:  MOVFF  66,00
060A:  MOVFF  67,74
060E:  MOVFF  68,73
0612:  MOVFF  69,72
0616:  MOVFF  74,01
061A:  MOVFF  73,02
061E:  MOVFF  72,03
0622:  BRA    068C
0624:  CLRF   00
0626:  CLRF   01
0628:  CLRF   02
062A:  CLRF   03
062C:  BRA    068C
062E:  CLRF   x71
0630:  COMF   x72,F
0632:  COMF   x73,F
0634:  COMF   x74,F
0636:  COMF   x71,F
0638:  INCF   x71,F
063A:  BNZ   0646
063C:  INCF   x72,F
063E:  BNZ   0646
0640:  INCF   x73,F
0642:  BNZ   0646
0644:  INCF   x74,F
0646:  BTFSC  x70.0
0648:  BRA    0474
064A:  BTFSC  x70.1
064C:  BRA    04FA
064E:  BTFSC  x70.2
0650:  BRA    0566
0652:  BRA    05BA
0654:  MOVF   FEF,W
0656:  ADDWF  x72,F
0658:  BNC   0664
065A:  INCF   x73,F
065C:  BNZ   0664
065E:  INCF   x74,F
0660:  BTFSC  FD8.2
0662:  BSF    x6E.0
0664:  MOVF   FED,F
0666:  MOVF   FEF,W
0668:  ADDWF  x73,F
066A:  BNC   0672
066C:  INCF   x74,F
066E:  BTFSC  FD8.2
0670:  BSF    x6E.0
0672:  MOVF   FED,F
0674:  MOVF   FEF,W
0676:  BTFSC  FEF.7
0678:  BRA    067C
067A:  XORLW  80
067C:  ADDWF  x74,F
067E:  BTFSC  FD8.0
0680:  BSF    x6E.0
0682:  BTFSC  x70.4
0684:  BRA    0482
0686:  BTFSC  x70.5
0688:  BRA    0508
068A:  BRA    0574
068C:  RETURN 0
068E:  MOVFF  63,6A
0692:  MOVF   x67,W
0694:  XORWF  x6A,F
0696:  BTFSS  x6A.7
0698:  BRA    06A4
069A:  BCF    FD8.2
069C:  BCF    FD8.0
069E:  BTFSC  x63.7
06A0:  BSF    FD8.0
06A2:  BRA    0702
06A4:  MOVFF  63,6A
06A8:  MOVFF  66,6B
06AC:  MOVF   x62,W
06AE:  SUBWF  x6B,F
06B0:  BZ    06BE
06B2:  BTFSS  x6A.7
06B4:  BRA    0702
06B6:  MOVF   FD8,W
06B8:  XORLW  01
06BA:  MOVWF  FD8
06BC:  BRA    0702
06BE:  MOVFF  67,6B
06C2:  MOVF   x63,W
06C4:  SUBWF  x6B,F
06C6:  BZ    06D4
06C8:  BTFSS  x6A.7
06CA:  BRA    0702
06CC:  MOVF   FD8,W
06CE:  XORLW  01
06D0:  MOVWF  FD8
06D2:  BRA    0702
06D4:  MOVFF  68,6B
06D8:  MOVF   x64,W
06DA:  SUBWF  x6B,F
06DC:  BZ    06EA
06DE:  BTFSS  x6A.7
06E0:  BRA    0702
06E2:  MOVF   FD8,W
06E4:  XORLW  01
06E6:  MOVWF  FD8
06E8:  BRA    0702
06EA:  MOVFF  69,6B
06EE:  MOVF   x65,W
06F0:  SUBWF  x6B,F
06F2:  BZ    0700
06F4:  BTFSS  x6A.7
06F6:  BRA    0702
06F8:  MOVF   FD8,W
06FA:  XORLW  01
06FC:  MOVWF  FD8
06FE:  BRA    0702
0700:  BCF    FD8.0
0702:  RETURN 0
0704:  MOVLW  8E
0706:  MOVWF  00
0708:  MOVFF  59,01
070C:  MOVFF  58,02
0710:  CLRF   03
0712:  BTFSS  59.7
0714:  BRA    0720
0716:  COMF   01,F
0718:  COMF   02,F
071A:  INCF   02,F
071C:  BNZ   0720
071E:  INCF   01,F
0720:  MOVF   01,F
0722:  BNZ   0736
0724:  MOVFF  02,01
0728:  CLRF   02
072A:  MOVLW  08
072C:  SUBWF  00,F
072E:  MOVF   01,F
0730:  BNZ   0736
0732:  CLRF   00
0734:  BRA    074A
0736:  BCF    FD8.0
0738:  BTFSC  01.7
073A:  BRA    0744
073C:  RLCF   02,F
073E:  RLCF   01,F
0740:  DECF   00,F
0742:  BRA    0736
0744:  BTFSC  59.7
0746:  BRA    074A
0748:  BCF    01.7
074A:  RETURN 0
*
0A8C:  MOVLW  8E
0A8E:  MOVWF  00
0A90:  MOVF   x62,W
0A92:  SUBWF  00,F
0A94:  MOVFF  63,02
0A98:  MOVFF  64,01
0A9C:  BSF    02.7
0A9E:  MOVF   00,F
0AA0:  BZ    0AB4
0AA2:  BCF    FD8.0
0AA4:  MOVF   02,F
0AA6:  BNZ   0AAC
0AA8:  MOVF   01,F
0AAA:  BZ    0AB4
0AAC:  RRCF   02,F
0AAE:  RRCF   01,F
0AB0:  DECFSZ 00,F
0AB2:  BRA    0AA2
0AB4:  BTFSS  x63.7
0AB6:  BRA    0AC2
0AB8:  COMF   01,F
0ABA:  COMF   02,F
0ABC:  INCF   01,F
0ABE:  BTFSC  FD8.2
0AC0:  INCF   02,F
0AC2:  RETURN 0
*
19E6:  MOVF   37,W
19E8:  CLRF   01
19EA:  SUBWF  36,W
19EC:  BC    19F4
19EE:  MOVFF  36,00
19F2:  BRA    1A0C
19F4:  CLRF   00
19F6:  MOVLW  08
19F8:  MOVWF  38
19FA:  RLCF   36,F
19FC:  RLCF   00,F
19FE:  MOVF   37,W
1A00:  SUBWF  00,W
1A02:  BTFSC  FD8.0
1A04:  MOVWF  00
1A06:  RLCF   01,F
1A08:  DECFSZ 38,F
1A0A:  BRA    19FA
1A0C:  RETURN 0
*
1A7E:  MOVF   43,W
1A80:  SUBLW  B6
1A82:  MOVWF  43
1A84:  CLRF   03
1A86:  MOVFF  44,47
1A8A:  BSF    44.7
1A8C:  BCF    FD8.0
1A8E:  RRCF   44,F
1A90:  RRCF   45,F
1A92:  RRCF   46,F
1A94:  RRCF   03,F
1A96:  RRCF   02,F
1A98:  RRCF   01,F
1A9A:  RRCF   00,F
1A9C:  DECFSZ 43,F
1A9E:  BRA    1A8C
1AA0:  BTFSS  47.7
1AA2:  BRA    1ABA
1AA4:  COMF   00,F
1AA6:  COMF   01,F
1AA8:  COMF   02,F
1AAA:  COMF   03,F
1AAC:  INCF   00,F
1AAE:  BTFSC  FD8.2
1AB0:  INCF   01,F
1AB2:  BTFSC  FD8.2
1AB4:  INCF   02,F
1AB6:  BTFSC  FD8.2
1AB8:  INCF   03,F
1ABA:  GOTO   1B9C (RETURN)
1ABE:  BTFSC  FD8.1
1AC0:  BRA    1AC8
1AC2:  CLRF   FEA
1AC4:  MOVLW  4B
1AC6:  MOVWF  FE9
1AC8:  CLRF   00
1ACA:  CLRF   01
1ACC:  CLRF   02
1ACE:  CLRF   03
1AD0:  CLRF   4B
1AD2:  CLRF   4C
1AD4:  CLRF   4D
1AD6:  CLRF   4E
1AD8:  MOVF   4A,W
1ADA:  IORWF  49,W
1ADC:  IORWF  48,W
1ADE:  IORWF  47,W
1AE0:  BZ    1B3A
1AE2:  MOVLW  20
1AE4:  MOVWF  4F
1AE6:  BCF    FD8.0
1AE8:  RLCF   43,F
1AEA:  RLCF   44,F
1AEC:  RLCF   45,F
1AEE:  RLCF   46,F
1AF0:  RLCF   4B,F
1AF2:  RLCF   4C,F
1AF4:  RLCF   4D,F
1AF6:  RLCF   4E,F
1AF8:  MOVF   4A,W
1AFA:  SUBWF  4E,W
1AFC:  BNZ   1B0E
1AFE:  MOVF   49,W
1B00:  SUBWF  4D,W
1B02:  BNZ   1B0E
1B04:  MOVF   48,W
1B06:  SUBWF  4C,W
1B08:  BNZ   1B0E
1B0A:  MOVF   47,W
1B0C:  SUBWF  4B,W
1B0E:  BNC   1B2E
1B10:  MOVF   47,W
1B12:  SUBWF  4B,F
1B14:  MOVF   48,W
1B16:  BTFSS  FD8.0
1B18:  INCFSZ 48,W
1B1A:  SUBWF  4C,F
1B1C:  MOVF   49,W
1B1E:  BTFSS  FD8.0
1B20:  INCFSZ 49,W
1B22:  SUBWF  4D,F
1B24:  MOVF   4A,W
1B26:  BTFSS  FD8.0
1B28:  INCFSZ 4A,W
1B2A:  SUBWF  4E,F
1B2C:  BSF    FD8.0
1B2E:  RLCF   00,F
1B30:  RLCF   01,F
1B32:  RLCF   02,F
1B34:  RLCF   03,F
1B36:  DECFSZ 4F,F
1B38:  BRA    1AE6
1B3A:  MOVFF  4B,FEF
1B3E:  MOVFF  4C,FEC
1B42:  MOVFF  4D,FEC
1B46:  MOVFF  4E,FEC
1B4A:  RETURN 0
1B4C:  MOVF   FE9,W
1B4E:  MOVWF  3B
1B50:  MOVF   3A,W
1B52:  MOVWF  3D
1B54:  BZ    1B8A
1B56:  MOVFF  39,65
1B5A:  MOVFF  38,64
1B5E:  MOVFF  37,63
1B62:  MOVFF  36,62
1B66:  CLRF   x69
1B68:  CLRF   x68
1B6A:  MOVLW  20
1B6C:  MOVWF  x67
1B6E:  MOVLW  82
1B70:  MOVWF  x66
1B72:  CALL   01D8
1B76:  MOVFF  03,39
1B7A:  MOVFF  02,38
1B7E:  MOVFF  01,37
1B82:  MOVFF  00,36
1B86:  DECFSZ 3D,F
1B88:  BRA    1B56
1B8A:  MOVFF  39,46
1B8E:  MOVFF  38,45
1B92:  MOVFF  37,44
1B96:  MOVFF  36,43
1B9A:  BRA    1A7E
1B9C:  MOVFF  03,39
1BA0:  MOVFF  02,38
1BA4:  MOVFF  01,37
1BA8:  MOVFF  00,36
1BAC:  BTFSS  39.7
1BAE:  BRA    1BCA
1BB0:  DECF   3B,F
1BB2:  BSF    3B.5
1BB4:  COMF   36,F
1BB6:  COMF   37,F
1BB8:  COMF   38,F
1BBA:  COMF   39,F
1BBC:  INCF   36,F
1BBE:  BTFSC  FD8.2
1BC0:  INCF   37,F
1BC2:  BTFSC  FD8.2
1BC4:  INCF   38,F
1BC6:  BTFSC  FD8.2
1BC8:  INCF   39,F
1BCA:  MOVLW  3B
1BCC:  MOVWF  42
1BCE:  MOVLW  9A
1BD0:  MOVWF  41
1BD2:  MOVLW  CA
1BD4:  MOVWF  40
1BD6:  CLRF   3F
1BD8:  MOVLW  0A
1BDA:  MOVWF  3D
1BDC:  MOVF   3A,W
1BDE:  BTFSC  FD8.2
1BE0:  INCF   3B,F
1BE2:  BSF    FD8.1
1BE4:  CLRF   FEA
1BE6:  MOVLW  36
1BE8:  MOVWF  FE9
1BEA:  MOVFF  39,46
1BEE:  MOVFF  38,45
1BF2:  MOVFF  37,44
1BF6:  MOVFF  36,43
1BFA:  MOVFF  42,4A
1BFE:  MOVFF  41,49
1C02:  MOVFF  40,48
1C06:  MOVFF  3F,47
1C0A:  RCALL  1ABE
1C0C:  MOVF   01,W
1C0E:  MOVF   00,F
1C10:  BNZ   1C30
1C12:  INCF   3A,W
1C14:  SUBWF  3D,W
1C16:  BZ    1C30
1C18:  MOVF   3B,W
1C1A:  BZ    1C34
1C1C:  ANDLW  0F
1C1E:  SUBWF  3D,W
1C20:  BZ    1C24
1C22:  BC    1C9A
1C24:  BTFSC  3B.7
1C26:  BRA    1C9A
1C28:  BTFSC  3B.6
1C2A:  BRA    1C34
1C2C:  MOVLW  20
1C2E:  BRA    1C90
1C30:  MOVLW  20
1C32:  ANDWF  3B,F
1C34:  BTFSS  3B.5
1C36:  BRA    1C52
1C38:  BCF    3B.5
1C3A:  MOVF   3A,W
1C3C:  BTFSS  FD8.2
1C3E:  DECF   3B,F
1C40:  MOVF   00,W
1C42:  MOVWF  3B
1C44:  MOVLW  2D
1C46:  MOVWF  43
1C48:  CALL   0096
1C4C:  MOVF   3B,W
1C4E:  MOVWF  00
1C50:  CLRF   3B
1C52:  MOVF   3A,W
1C54:  SUBWF  3D,W
1C56:  BNZ   1C6E
1C58:  MOVF   00,W
1C5A:  MOVWF  3B
1C5C:  MOVLW  2E
1C5E:  MOVWF  43
1C60:  CALL   0096
1C64:  MOVF   3B,W
1C66:  MOVWF  00
1C68:  MOVLW  20
1C6A:  ANDWF  3B,F
1C6C:  MOVLW  00
1C6E:  MOVLW  30
1C70:  BTFSS  3B.5
1C72:  BRA    1C90
1C74:  BCF    3B.5
1C76:  MOVF   3A,W
1C78:  BTFSS  FD8.2
1C7A:  DECF   3B,F
1C7C:  MOVF   00,W
1C7E:  MOVWF  3B
1C80:  MOVLW  2D
1C82:  MOVWF  43
1C84:  CALL   0096
1C88:  MOVF   3B,W
1C8A:  MOVWF  00
1C8C:  CLRF   3B
1C8E:  MOVLW  30
1C90:  ADDWF  00,F
1C92:  MOVFF  00,43
1C96:  CALL   0096
1C9A:  BCF    FD8.1
1C9C:  MOVFF  42,46
1CA0:  MOVFF  41,45
1CA4:  MOVFF  40,44
1CA8:  MOVFF  3F,43
1CAC:  CLRF   4A
1CAE:  CLRF   49
1CB0:  CLRF   48
1CB2:  MOVLW  0A
1CB4:  MOVWF  47
1CB6:  RCALL  1ABE
1CB8:  MOVFF  03,42
1CBC:  MOVFF  02,41
1CC0:  MOVFF  01,40
1CC4:  MOVFF  00,3F
1CC8:  DECFSZ 3D,F
1CCA:  BRA    1BE2
1CCC:  GOTO   1DAE (RETURN)
....................  
.................... #list 
....................  
.................... #DEVICE ADC =10  // seleciona o conversor a/d com 10 bits 
.................... #INCLUDE <stdlib.h>   
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <math.h> //  Inclui a biblioteca responsavel por fornecer funções de calculos matematicos  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
0AC4:  BCF    x61.0
....................    y = x; 
0AC6:  MOVFF  55,5A
0ACA:  MOVFF  54,59
0ACE:  MOVFF  53,58
0AD2:  MOVFF  52,57
....................  
....................    if (x < 0) 
0AD6:  MOVFF  55,65
0ADA:  MOVFF  54,64
0ADE:  MOVFF  53,63
0AE2:  MOVFF  52,62
0AE6:  CLRF   x69
0AE8:  CLRF   x68
0AEA:  CLRF   x67
0AEC:  CLRF   x66
0AEE:  RCALL  068E
0AF0:  BNC   0AFA
....................    { 
....................       s = 1; 
0AF2:  BSF    x61.0
....................       y = -y; 
0AF4:  MOVF   58,W
0AF6:  XORLW  80
0AF8:  MOVWF  58
....................    } 
....................  
....................    if (y <= 32768.0) 
0AFA:  MOVFF  5A,65
0AFE:  MOVFF  59,64
0B02:  MOVFF  58,63
0B06:  MOVFF  57,62
0B0A:  CLRF   x69
0B0C:  CLRF   x68
0B0E:  CLRF   x67
0B10:  MOVLW  8E
0B12:  MOVWF  x66
0B14:  RCALL  068E
0B16:  BC    0B1A
0B18:  BNZ   0B4A
....................       res = (float32)(unsigned int16)y; 
0B1A:  MOVFF  5A,65
0B1E:  MOVFF  59,64
0B22:  MOVFF  58,63
0B26:  MOVFF  57,62
0B2A:  RCALL  0A8C
0B2C:  MOVFF  02,67
0B30:  MOVFF  01,66
0B34:  CALL   01A2
0B38:  MOVFF  03,5E
0B3C:  MOVFF  02,5D
0B40:  MOVFF  01,5C
0B44:  MOVFF  00,5B
0B48:  BRA    0CD4
....................  
....................  else if (y < 10000000.0) 
0B4A:  MOVFF  5A,65
0B4E:  MOVFF  59,64
0B52:  MOVFF  58,63
0B56:  MOVFF  57,62
0B5A:  MOVLW  80
0B5C:  MOVWF  x69
0B5E:  MOVLW  96
0B60:  MOVWF  x68
0B62:  MOVLW  18
0B64:  MOVWF  x67
0B66:  MOVLW  96
0B68:  MOVWF  x66
0B6A:  RCALL  068E
0B6C:  BTFSS  FD8.0
0B6E:  BRA    0CC4
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
0B70:  MOVFF  5A,65
0B74:  MOVFF  59,64
0B78:  MOVFF  58,63
0B7C:  MOVFF  57,62
0B80:  CLRF   x69
0B82:  CLRF   x68
0B84:  CLRF   x67
0B86:  MOVLW  70
0B88:  MOVWF  x66
0B8A:  CALL   01D8
0B8E:  MOVFF  03,65
0B92:  MOVFF  02,64
0B96:  MOVFF  01,63
0B9A:  MOVFF  00,62
0B9E:  RCALL  0A8C
0BA0:  MOVFF  02,60
0BA4:  MOVFF  01,5F
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
0BA8:  MOVFF  5A,65
0BAC:  MOVFF  59,64
0BB0:  MOVFF  58,63
0BB4:  MOVFF  57,62
0BB8:  CLRF   x69
0BBA:  CLRF   x68
0BBC:  CLRF   x67
0BBE:  MOVLW  70
0BC0:  MOVWF  x66
0BC2:  CALL   01D8
0BC6:  MOVFF  03,65
0BCA:  MOVFF  02,64
0BCE:  MOVFF  01,63
0BD2:  MOVFF  00,62
0BD6:  MOVFF  60,67
0BDA:  MOVFF  5F,66
0BDE:  CALL   01A2
0BE2:  BSF    FD8.1
0BE4:  MOVFF  65,69
0BE8:  MOVFF  64,68
0BEC:  MOVFF  63,67
0BF0:  MOVFF  62,66
0BF4:  MOVFF  03,6D
0BF8:  MOVFF  02,6C
0BFC:  MOVFF  01,6B
0C00:  MOVFF  00,6A
0C04:  RCALL  0424
0C06:  CLRF   x65
0C08:  CLRF   x64
0C0A:  CLRF   x63
0C0C:  MOVLW  8E
0C0E:  MOVWF  x62
0C10:  MOVFF  03,69
0C14:  MOVFF  02,68
0C18:  MOVFF  01,67
0C1C:  MOVFF  00,66
0C20:  CALL   01D8
0C24:  MOVFF  03,5A
0C28:  MOVFF  02,59
0C2C:  MOVFF  01,58
0C30:  MOVFF  00,57
....................       res = 32768.0*(float32)l; 
0C34:  MOVFF  60,67
0C38:  MOVFF  5F,66
0C3C:  CALL   01A2
0C40:  CLRF   x65
0C42:  CLRF   x64
0C44:  CLRF   x63
0C46:  MOVLW  8E
0C48:  MOVWF  x62
0C4A:  MOVFF  03,69
0C4E:  MOVFF  02,68
0C52:  MOVFF  01,67
0C56:  MOVFF  00,66
0C5A:  CALL   01D8
0C5E:  MOVFF  03,5E
0C62:  MOVFF  02,5D
0C66:  MOVFF  01,5C
0C6A:  MOVFF  00,5B
....................       res += (float32)(unsigned int16)y; 
0C6E:  MOVFF  5A,65
0C72:  MOVFF  59,64
0C76:  MOVFF  58,63
0C7A:  MOVFF  57,62
0C7E:  RCALL  0A8C
0C80:  MOVFF  02,67
0C84:  MOVFF  01,66
0C88:  CALL   01A2
0C8C:  BCF    FD8.1
0C8E:  MOVFF  5E,69
0C92:  MOVFF  5D,68
0C96:  MOVFF  5C,67
0C9A:  MOVFF  5B,66
0C9E:  MOVFF  03,6D
0CA2:  MOVFF  02,6C
0CA6:  MOVFF  01,6B
0CAA:  MOVFF  00,6A
0CAE:  CALL   0424
0CB2:  MOVFF  03,5E
0CB6:  MOVFF  02,5D
0CBA:  MOVFF  01,5C
0CBE:  MOVFF  00,5B
....................    } 
0CC2:  BRA    0CD4
....................  
....................  else 
....................   res = y; 
0CC4:  MOVFF  5A,5E
0CC8:  MOVFF  59,5D
0CCC:  MOVFF  58,5C
0CD0:  MOVFF  57,5B
....................  
....................  y = y - (float32)(unsigned int16)y; 
0CD4:  MOVFF  5A,65
0CD8:  MOVFF  59,64
0CDC:  MOVFF  58,63
0CE0:  MOVFF  57,62
0CE4:  RCALL  0A8C
0CE6:  MOVFF  02,67
0CEA:  MOVFF  01,66
0CEE:  CALL   01A2
0CF2:  BSF    FD8.1
0CF4:  MOVFF  5A,69
0CF8:  MOVFF  59,68
0CFC:  MOVFF  58,67
0D00:  MOVFF  57,66
0D04:  MOVFF  03,6D
0D08:  MOVFF  02,6C
0D0C:  MOVFF  01,6B
0D10:  MOVFF  00,6A
0D14:  CALL   0424
0D18:  MOVFF  03,5A
0D1C:  MOVFF  02,59
0D20:  MOVFF  01,58
0D24:  MOVFF  00,57
....................  
....................  if (s) 
0D28:  BTFSS  x61.0
0D2A:  BRA    0D32
....................   res = -res; 
0D2C:  MOVF   5C,W
0D2E:  XORLW  80
0D30:  MOVWF  5C
....................  
....................  if (y != 0) 
0D32:  MOVFF  5A,65
0D36:  MOVFF  59,64
0D3A:  MOVFF  58,63
0D3E:  MOVFF  57,62
0D42:  CLRF   x69
0D44:  CLRF   x68
0D46:  CLRF   x67
0D48:  CLRF   x66
0D4A:  RCALL  068E
0D4C:  BZ    0DBE
....................  { 
....................   if (s == 1 && n == 0) 
0D4E:  BTFSS  x61.0
0D50:  BRA    0D86
0D52:  MOVF   56,F
0D54:  BNZ   0D86
....................    res -= 1.0; 
0D56:  BSF    FD8.1
0D58:  MOVFF  5E,69
0D5C:  MOVFF  5D,68
0D60:  MOVFF  5C,67
0D64:  MOVFF  5B,66
0D68:  CLRF   x6D
0D6A:  CLRF   x6C
0D6C:  CLRF   x6B
0D6E:  MOVLW  7F
0D70:  MOVWF  x6A
0D72:  CALL   0424
0D76:  MOVFF  03,5E
0D7A:  MOVFF  02,5D
0D7E:  MOVFF  01,5C
0D82:  MOVFF  00,5B
....................  
....................   if (s == 0 && n == 1) 
0D86:  BTFSC  x61.0
0D88:  BRA    0DBE
0D8A:  DECFSZ 56,W
0D8C:  BRA    0DBE
....................    res += 1.0; 
0D8E:  BCF    FD8.1
0D90:  MOVFF  5E,69
0D94:  MOVFF  5D,68
0D98:  MOVFF  5C,67
0D9C:  MOVFF  5B,66
0DA0:  CLRF   x6D
0DA2:  CLRF   x6C
0DA4:  CLRF   x6B
0DA6:  MOVLW  7F
0DA8:  MOVWF  x6A
0DAA:  CALL   0424
0DAE:  MOVFF  03,5E
0DB2:  MOVFF  02,5D
0DB6:  MOVFF  01,5C
0DBA:  MOVFF  00,5B
....................  } 
....................  if (x == 0) 
0DBE:  MOVFF  55,65
0DC2:  MOVFF  54,64
0DC6:  MOVFF  53,63
0DCA:  MOVFF  52,62
0DCE:  CLRF   x69
0DD0:  CLRF   x68
0DD2:  CLRF   x67
0DD4:  CLRF   x66
0DD6:  RCALL  068E
0DD8:  BNZ   0DE2
....................     res = 0; 
0DDA:  CLRF   5E
0DDC:  CLRF   5D
0DDE:  CLRF   5C
0DE0:  CLRF   5B
....................  
....................  return (res); 
0DE2:  MOVFF  5B,00
0DE6:  MOVFF  5C,01
0DEA:  MOVFF  5D,02
0DEE:  MOVFF  5E,03
0DF2:  RETURN 0
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
*
0E0E:  MOVFF  51,55
0E12:  MOVFF  50,54
0E16:  MOVFF  4F,53
0E1A:  MOVFF  4E,52
0E1E:  CLRF   56
0E20:  RCALL  0AC4
0E22:  GOTO   0F24 (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
0DF4:  MOVFF  51,55
0DF8:  MOVFF  50,54
0DFC:  MOVFF  4F,53
0E00:  MOVFF  4E,52
0E04:  MOVLW  01
0E06:  MOVWF  56
0E08:  RCALL  0AC4
0E0A:  GOTO   0EDC (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
*
0E26:  MOVFF  45,65
0E2A:  MOVFF  44,64
0E2E:  MOVFF  43,63
0E32:  MOVFF  42,62
0E36:  CLRF   x69
0E38:  CLRF   x68
0E3A:  CLRF   x67
0E3C:  CLRF   x66
0E3E:  RCALL  068E
0E40:  BTFSC  FD8.2
0E42:  BRA    0F80
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
0E44:  MOVFF  41,5E
0E48:  MOVFF  40,5D
0E4C:  MOVFF  3F,5C
0E50:  MOVFF  3E,5B
0E54:  MOVFF  45,62
0E58:  MOVFF  44,61
0E5C:  MOVFF  43,60
0E60:  MOVFF  42,5F
0E64:  CALL   02CA
0E68:  MOVFF  03,4D
0E6C:  MOVFF  02,4C
0E70:  MOVFF  01,4B
0E74:  MOVFF  00,4A
0E78:  MOVFF  03,65
0E7C:  MOVFF  02,64
0E80:  MOVFF  01,63
0E84:  MOVFF  00,62
0E88:  CLRF   x69
0E8A:  CLRF   x68
0E8C:  CLRF   x67
0E8E:  CLRF   x66
0E90:  CALL   068E
0E94:  BNC   0EDE
0E96:  MOVFF  41,5E
0E9A:  MOVFF  40,5D
0E9E:  MOVFF  3F,5C
0EA2:  MOVFF  3E,5B
0EA6:  MOVFF  45,62
0EAA:  MOVFF  44,61
0EAE:  MOVFF  43,60
0EB2:  MOVFF  42,5F
0EB6:  CALL   02CA
0EBA:  MOVFF  03,4D
0EBE:  MOVFF  02,4C
0EC2:  MOVFF  01,4B
0EC6:  MOVFF  00,4A
0ECA:  MOVFF  03,51
0ECE:  MOVFF  02,50
0ED2:  MOVFF  01,4F
0ED6:  MOVFF  00,4E
0EDA:  BRA    0DF4
0EDC:  BRA    0F24
0EDE:  MOVFF  41,5E
0EE2:  MOVFF  40,5D
0EE6:  MOVFF  3F,5C
0EEA:  MOVFF  3E,5B
0EEE:  MOVFF  45,62
0EF2:  MOVFF  44,61
0EF6:  MOVFF  43,60
0EFA:  MOVFF  42,5F
0EFE:  CALL   02CA
0F02:  MOVFF  03,4D
0F06:  MOVFF  02,4C
0F0A:  MOVFF  01,4B
0F0E:  MOVFF  00,4A
0F12:  MOVFF  03,51
0F16:  MOVFF  02,50
0F1A:  MOVFF  01,4F
0F1E:  MOVFF  00,4E
0F22:  BRA    0E0E
0F24:  MOVFF  03,49
0F28:  MOVFF  02,48
0F2C:  MOVFF  01,47
0F30:  MOVFF  00,46
....................       return(x-(i*y)); 
0F34:  MOVFF  49,65
0F38:  MOVFF  48,64
0F3C:  MOVFF  47,63
0F40:  MOVFF  46,62
0F44:  MOVFF  45,69
0F48:  MOVFF  44,68
0F4C:  MOVFF  43,67
0F50:  MOVFF  42,66
0F54:  CALL   01D8
0F58:  BSF    FD8.1
0F5A:  MOVFF  41,69
0F5E:  MOVFF  40,68
0F62:  MOVFF  3F,67
0F66:  MOVFF  3E,66
0F6A:  MOVFF  03,6D
0F6E:  MOVFF  02,6C
0F72:  MOVFF  01,6B
0F76:  MOVFF  00,6A
0F7A:  CALL   0424
0F7E:  BRA    0F80
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
0F80:  RETURN 0
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
0F82:  MOVFF  45,65
0F86:  MOVFF  44,64
0F8A:  MOVFF  43,63
0F8E:  MOVFF  42,62
0F92:  MOVLW  3B
0F94:  MOVWF  x69
0F96:  MOVLW  AA
0F98:  MOVWF  x68
0F9A:  MOVLW  38
0F9C:  MOVWF  x67
0F9E:  MOVLW  7F
0FA0:  MOVWF  x66
0FA2:  CALL   01D8
0FA6:  MOVFF  03,65
0FAA:  MOVFF  02,64
0FAE:  MOVFF  01,63
0FB2:  MOVFF  00,62
0FB6:  RCALL  0A8C
0FB8:  MOVFF  01,52
....................    s = 0; 
0FBC:  BCF    53.0
....................    y = x; 
0FBE:  MOVFF  45,49
0FC2:  MOVFF  44,48
0FC6:  MOVFF  43,47
0FCA:  MOVFF  42,46
....................  
....................    if (x < 0) 
0FCE:  MOVFF  45,65
0FD2:  MOVFF  44,64
0FD6:  MOVFF  43,63
0FDA:  MOVFF  42,62
0FDE:  CLRF   x69
0FE0:  CLRF   x68
0FE2:  CLRF   x67
0FE4:  CLRF   x66
0FE6:  CALL   068E
0FEA:  BNC   0FF6
....................    { 
....................       s = 1; 
0FEC:  BSF    53.0
....................       n = -n; 
0FEE:  NEGF   52
....................       y = -y; 
0FF0:  MOVF   47,W
0FF2:  XORLW  80
0FF4:  MOVWF  47
....................    } 
....................  
....................    res = 0.0; 
0FF6:  CLRF   4D
0FF8:  CLRF   4C
0FFA:  CLRF   4B
0FFC:  CLRF   4A
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
0FFE:  CLRF   55
1000:  MOVLW  4A
1002:  MOVWF  FE9
1004:  MOVFF  55,FEA
1008:  MOVLW  7F
100A:  ADDWF  52,W
100C:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
100E:  MOVFF  49,65
1012:  MOVFF  48,64
1016:  MOVFF  47,63
101A:  MOVFF  46,62
101E:  MOVLW  3B
1020:  MOVWF  x69
1022:  MOVLW  AA
1024:  MOVWF  x68
1026:  MOVLW  38
1028:  MOVWF  x67
102A:  MOVLW  7F
102C:  MOVWF  x66
102E:  CALL   01D8
1032:  MOVFF  03,57
1036:  MOVFF  02,56
103A:  MOVFF  01,55
103E:  MOVFF  00,54
1042:  CLRF   59
1044:  MOVFF  52,58
1048:  BTFSC  58.7
104A:  DECF   59,F
104C:  CALL   0704
1050:  BSF    FD8.1
1052:  MOVFF  57,69
1056:  MOVFF  56,68
105A:  MOVFF  55,67
105E:  MOVFF  54,66
1062:  MOVFF  03,6D
1066:  MOVFF  02,6C
106A:  MOVFF  01,6B
106E:  MOVFF  00,6A
1072:  CALL   0424
1076:  MOVFF  03,49
107A:  MOVFF  02,48
107E:  MOVFF  01,47
1082:  MOVFF  00,46
....................  
....................    r = pe[0]*y + pe[1]; 
1086:  MOVLW  7C
1088:  MOVWF  x65
108A:  MOVLW  88
108C:  MOVWF  x64
108E:  MOVLW  59
1090:  MOVWF  x63
1092:  MOVLW  72
1094:  MOVWF  x62
1096:  MOVFF  49,69
109A:  MOVFF  48,68
109E:  MOVFF  47,67
10A2:  MOVFF  46,66
10A6:  CALL   01D8
10AA:  MOVFF  03,57
10AE:  MOVFF  02,56
10B2:  MOVFF  01,55
10B6:  MOVFF  00,54
10BA:  BCF    FD8.1
10BC:  MOVFF  03,69
10C0:  MOVFF  02,68
10C4:  MOVFF  01,67
10C8:  MOVFF  00,66
10CC:  MOVLW  E0
10CE:  MOVWF  x6D
10D0:  MOVLW  97
10D2:  MOVWF  x6C
10D4:  MOVLW  26
10D6:  MOVWF  x6B
10D8:  MOVLW  75
10DA:  MOVWF  x6A
10DC:  CALL   0424
10E0:  MOVFF  03,51
10E4:  MOVFF  02,50
10E8:  MOVFF  01,4F
10EC:  MOVFF  00,4E
....................    r = r*y + pe[2]; 
10F0:  MOVFF  51,65
10F4:  MOVFF  50,64
10F8:  MOVFF  4F,63
10FC:  MOVFF  4E,62
1100:  MOVFF  49,69
1104:  MOVFF  48,68
1108:  MOVFF  47,67
110C:  MOVFF  46,66
1110:  CALL   01D8
1114:  MOVFF  03,57
1118:  MOVFF  02,56
111C:  MOVFF  01,55
1120:  MOVFF  00,54
1124:  BCF    FD8.1
1126:  MOVFF  03,69
112A:  MOVFF  02,68
112E:  MOVFF  01,67
1132:  MOVFF  00,66
1136:  MOVLW  C4
1138:  MOVWF  x6D
113A:  MOVLW  1D
113C:  MOVWF  x6C
113E:  MOVLW  1E
1140:  MOVWF  x6B
1142:  MOVLW  78
1144:  MOVWF  x6A
1146:  CALL   0424
114A:  MOVFF  03,51
114E:  MOVFF  02,50
1152:  MOVFF  01,4F
1156:  MOVFF  00,4E
....................    r = r*y + pe[3]; 
115A:  MOVFF  51,65
115E:  MOVFF  50,64
1162:  MOVFF  4F,63
1166:  MOVFF  4E,62
116A:  MOVFF  49,69
116E:  MOVFF  48,68
1172:  MOVFF  47,67
1176:  MOVFF  46,66
117A:  CALL   01D8
117E:  MOVFF  03,57
1182:  MOVFF  02,56
1186:  MOVFF  01,55
118A:  MOVFF  00,54
118E:  BCF    FD8.1
1190:  MOVFF  03,69
1194:  MOVFF  02,68
1198:  MOVFF  01,67
119C:  MOVFF  00,66
11A0:  MOVLW  5E
11A2:  MOVWF  x6D
11A4:  MOVLW  50
11A6:  MOVWF  x6C
11A8:  MOVLW  63
11AA:  MOVWF  x6B
11AC:  MOVLW  7A
11AE:  MOVWF  x6A
11B0:  CALL   0424
11B4:  MOVFF  03,51
11B8:  MOVFF  02,50
11BC:  MOVFF  01,4F
11C0:  MOVFF  00,4E
....................    r = r*y + pe[4]; 
11C4:  MOVFF  51,65
11C8:  MOVFF  50,64
11CC:  MOVFF  4F,63
11D0:  MOVFF  4E,62
11D4:  MOVFF  49,69
11D8:  MOVFF  48,68
11DC:  MOVFF  47,67
11E0:  MOVFF  46,66
11E4:  CALL   01D8
11E8:  MOVFF  03,57
11EC:  MOVFF  02,56
11F0:  MOVFF  01,55
11F4:  MOVFF  00,54
11F8:  BCF    FD8.1
11FA:  MOVFF  03,69
11FE:  MOVFF  02,68
1202:  MOVFF  01,67
1206:  MOVFF  00,66
120A:  MOVLW  1A
120C:  MOVWF  x6D
120E:  MOVLW  FE
1210:  MOVWF  x6C
1212:  MOVLW  75
1214:  MOVWF  x6B
1216:  MOVLW  7C
1218:  MOVWF  x6A
121A:  CALL   0424
121E:  MOVFF  03,51
1222:  MOVFF  02,50
1226:  MOVFF  01,4F
122A:  MOVFF  00,4E
....................    r = r*y + pe[5]; 
122E:  MOVFF  51,65
1232:  MOVFF  50,64
1236:  MOVFF  4F,63
123A:  MOVFF  4E,62
123E:  MOVFF  49,69
1242:  MOVFF  48,68
1246:  MOVFF  47,67
124A:  MOVFF  46,66
124E:  CALL   01D8
1252:  MOVFF  03,57
1256:  MOVFF  02,56
125A:  MOVFF  01,55
125E:  MOVFF  00,54
1262:  BCF    FD8.1
1264:  MOVFF  03,69
1268:  MOVFF  02,68
126C:  MOVFF  01,67
1270:  MOVFF  00,66
1274:  MOVLW  18
1276:  MOVWF  x6D
1278:  MOVLW  72
127A:  MOVWF  x6C
127C:  MOVLW  31
127E:  MOVWF  x6B
1280:  MOVLW  7E
1282:  MOVWF  x6A
1284:  CALL   0424
1288:  MOVFF  03,51
128C:  MOVFF  02,50
1290:  MOVFF  01,4F
1294:  MOVFF  00,4E
....................  
....................    res = res*(1.0 + y*r); 
1298:  MOVFF  49,65
129C:  MOVFF  48,64
12A0:  MOVFF  47,63
12A4:  MOVFF  46,62
12A8:  MOVFF  51,69
12AC:  MOVFF  50,68
12B0:  MOVFF  4F,67
12B4:  MOVFF  4E,66
12B8:  CALL   01D8
12BC:  BCF    FD8.1
12BE:  CLRF   x69
12C0:  CLRF   x68
12C2:  CLRF   x67
12C4:  MOVLW  7F
12C6:  MOVWF  x66
12C8:  MOVFF  03,6D
12CC:  MOVFF  02,6C
12D0:  MOVFF  01,6B
12D4:  MOVFF  00,6A
12D8:  CALL   0424
12DC:  MOVFF  4D,65
12E0:  MOVFF  4C,64
12E4:  MOVFF  4B,63
12E8:  MOVFF  4A,62
12EC:  MOVFF  03,69
12F0:  MOVFF  02,68
12F4:  MOVFF  01,67
12F8:  MOVFF  00,66
12FC:  CALL   01D8
1300:  MOVFF  03,4D
1304:  MOVFF  02,4C
1308:  MOVFF  01,4B
130C:  MOVFF  00,4A
....................  
....................    if (s) 
1310:  BTFSS  53.0
1312:  BRA    1342
....................       res = 1.0/res; 
1314:  CLRF   5E
1316:  CLRF   5D
1318:  CLRF   5C
131A:  MOVLW  7F
131C:  MOVWF  5B
131E:  MOVFF  4D,62
1322:  MOVFF  4C,61
1326:  MOVFF  4B,60
132A:  MOVFF  4A,5F
132E:  CALL   02CA
1332:  MOVFF  03,4D
1336:  MOVFF  02,4C
133A:  MOVFF  01,4B
133E:  MOVFF  00,4A
....................    return(res); 
1342:  MOVFF  4A,00
1346:  MOVFF  4B,01
134A:  MOVFF  4C,02
134E:  MOVFF  4D,03
1352:  RETURN 0
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
*
074C:  MOVFF  45,49
0750:  MOVFF  44,48
0754:  MOVFF  43,47
0758:  MOVFF  42,46
....................  
....................    if (y != 1.0) 
075C:  MOVFF  49,65
0760:  MOVFF  48,64
0764:  MOVFF  47,63
0768:  MOVFF  46,62
076C:  CLRF   x69
076E:  CLRF   x68
0770:  CLRF   x67
0772:  MOVLW  7F
0774:  MOVWF  x66
0776:  RCALL  068E
0778:  BTFSC  FD8.2
077A:  BRA    0A72
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
077C:  CLRF   58
077E:  MOVLW  46
0780:  MOVWF  FE9
0782:  MOVFF  58,FEA
0786:  MOVLW  7E
0788:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
078A:  BSF    FD8.1
078C:  MOVFF  49,69
0790:  MOVFF  48,68
0794:  MOVFF  47,67
0798:  MOVFF  46,66
079C:  CLRF   x6D
079E:  CLRF   x6C
07A0:  CLRF   x6B
07A2:  MOVLW  7F
07A4:  MOVWF  x6A
07A6:  RCALL  0424
07A8:  MOVFF  03,5A
07AC:  MOVFF  02,59
07B0:  MOVFF  01,58
07B4:  MOVFF  00,57
07B8:  BCF    FD8.1
07BA:  MOVFF  49,69
07BE:  MOVFF  48,68
07C2:  MOVFF  47,67
07C6:  MOVFF  46,66
07CA:  CLRF   x6D
07CC:  CLRF   x6C
07CE:  CLRF   x6B
07D0:  MOVLW  7F
07D2:  MOVWF  x6A
07D4:  RCALL  0424
07D6:  MOVFF  5A,5E
07DA:  MOVFF  59,5D
07DE:  MOVFF  58,5C
07E2:  MOVFF  57,5B
07E6:  MOVFF  03,62
07EA:  MOVFF  02,61
07EE:  MOVFF  01,60
07F2:  MOVFF  00,5F
07F6:  RCALL  02CA
07F8:  MOVFF  03,49
07FC:  MOVFF  02,48
0800:  MOVFF  01,47
0804:  MOVFF  00,46
....................  
....................       y2=y*y; 
0808:  MOVFF  49,65
080C:  MOVFF  48,64
0810:  MOVFF  47,63
0814:  MOVFF  46,62
0818:  MOVFF  49,69
081C:  MOVFF  48,68
0820:  MOVFF  47,67
0824:  MOVFF  46,66
0828:  RCALL  01D8
082A:  MOVFF  03,55
082E:  MOVFF  02,54
0832:  MOVFF  01,53
0836:  MOVFF  00,52
....................  
....................       res = pl[0]*y2 + pl[1]; 
083A:  MOVLW  99
083C:  MOVWF  x65
083E:  MOVLW  47
0840:  MOVWF  x64
0842:  MOVLW  8A
0844:  MOVWF  x63
0846:  MOVLW  7F
0848:  MOVWF  x62
084A:  MOVFF  55,69
084E:  MOVFF  54,68
0852:  MOVFF  53,67
0856:  MOVFF  52,66
085A:  RCALL  01D8
085C:  MOVFF  03,5A
0860:  MOVFF  02,59
0864:  MOVFF  01,58
0868:  MOVFF  00,57
086C:  BCF    FD8.1
086E:  MOVFF  03,69
0872:  MOVFF  02,68
0876:  MOVFF  01,67
087A:  MOVFF  00,66
087E:  CLRF   x6D
0880:  CLRF   x6C
0882:  CLRF   x6B
0884:  MOVLW  80
0886:  MOVWF  x6A
0888:  RCALL  0424
088A:  MOVFF  03,4D
088E:  MOVFF  02,4C
0892:  MOVFF  01,4B
0896:  MOVFF  00,4A
....................  
....................       r = ql[0]*y2 + ql[1]; 
089A:  MOVLW  4C
089C:  MOVWF  x65
089E:  MOVLW  F3
08A0:  MOVWF  x64
08A2:  MOVLW  3A
08A4:  MOVWF  x63
08A6:  MOVLW  7B
08A8:  MOVWF  x62
08AA:  MOVFF  55,69
08AE:  MOVFF  54,68
08B2:  MOVFF  53,67
08B6:  MOVFF  52,66
08BA:  RCALL  01D8
08BC:  MOVFF  03,5A
08C0:  MOVFF  02,59
08C4:  MOVFF  01,58
08C8:  MOVFF  00,57
08CC:  BCF    FD8.1
08CE:  MOVFF  03,69
08D2:  MOVFF  02,68
08D6:  MOVFF  01,67
08DA:  MOVFF  00,66
08DE:  MOVLW  2B
08E0:  MOVWF  x6D
08E2:  MOVLW  9D
08E4:  MOVWF  x6C
08E6:  MOVLW  DF
08E8:  MOVWF  x6B
08EA:  MOVLW  7E
08EC:  MOVWF  x6A
08EE:  RCALL  0424
08F0:  MOVFF  03,51
08F4:  MOVFF  02,50
08F8:  MOVFF  01,4F
08FC:  MOVFF  00,4E
....................       r = r*y2 + 1.0; 
0900:  MOVFF  51,65
0904:  MOVFF  50,64
0908:  MOVFF  4F,63
090C:  MOVFF  4E,62
0910:  MOVFF  55,69
0914:  MOVFF  54,68
0918:  MOVFF  53,67
091C:  MOVFF  52,66
0920:  RCALL  01D8
0922:  MOVFF  03,5A
0926:  MOVFF  02,59
092A:  MOVFF  01,58
092E:  MOVFF  00,57
0932:  BCF    FD8.1
0934:  MOVFF  03,69
0938:  MOVFF  02,68
093C:  MOVFF  01,67
0940:  MOVFF  00,66
0944:  CLRF   x6D
0946:  CLRF   x6C
0948:  CLRF   x6B
094A:  MOVLW  7F
094C:  MOVWF  x6A
094E:  RCALL  0424
0950:  MOVFF  03,51
0954:  MOVFF  02,50
0958:  MOVFF  01,4F
095C:  MOVFF  00,4E
....................  
....................       res = y*res/r; 
0960:  MOVFF  49,65
0964:  MOVFF  48,64
0968:  MOVFF  47,63
096C:  MOVFF  46,62
0970:  MOVFF  4D,69
0974:  MOVFF  4C,68
0978:  MOVFF  4B,67
097C:  MOVFF  4A,66
0980:  RCALL  01D8
0982:  MOVFF  03,5A
0986:  MOVFF  02,59
098A:  MOVFF  01,58
098E:  MOVFF  00,57
0992:  MOVFF  03,5E
0996:  MOVFF  02,5D
099A:  MOVFF  01,5C
099E:  MOVFF  00,5B
09A2:  MOVFF  51,62
09A6:  MOVFF  50,61
09AA:  MOVFF  4F,60
09AE:  MOVFF  4E,5F
09B2:  RCALL  02CA
09B4:  MOVFF  03,4D
09B8:  MOVFF  02,4C
09BC:  MOVFF  01,4B
09C0:  MOVFF  00,4A
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
09C4:  CLRF   58
09C6:  MOVLW  42
09C8:  MOVWF  FE9
09CA:  MOVFF  58,FEA
09CE:  MOVLW  7E
09D0:  SUBWF  FEF,W
09D2:  MOVWF  56
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
09D4:  BTFSS  56.7
09D6:  BRA    09FC
....................          r = -(float32)-n; 
09D8:  MOVLW  00
09DA:  BSF    FD8.0
09DC:  SUBFWB 56,W
09DE:  CLRF   59
09E0:  MOVWF  58
09E2:  BTFSC  58.7
09E4:  DECF   59,F
09E6:  RCALL  0704
09E8:  MOVFF  00,4E
09EC:  MOVF   01,W
09EE:  XORLW  80
09F0:  MOVWF  4F
09F2:  MOVFF  02,50
09F6:  MOVFF  03,51
09FA:  BRA    0A18
....................       else 
....................          r = (float32)n; 
09FC:  CLRF   59
09FE:  MOVFF  56,58
0A02:  BTFSC  58.7
0A04:  DECF   59,F
0A06:  RCALL  0704
0A08:  MOVFF  03,51
0A0C:  MOVFF  02,50
0A10:  MOVFF  01,4F
0A14:  MOVFF  00,4E
....................  
....................       res += r*LN2; 
0A18:  MOVFF  51,65
0A1C:  MOVFF  50,64
0A20:  MOVFF  4F,63
0A24:  MOVFF  4E,62
0A28:  MOVLW  18
0A2A:  MOVWF  x69
0A2C:  MOVLW  72
0A2E:  MOVWF  x68
0A30:  MOVLW  31
0A32:  MOVWF  x67
0A34:  MOVLW  7E
0A36:  MOVWF  x66
0A38:  CALL   01D8
0A3C:  BCF    FD8.1
0A3E:  MOVFF  4D,69
0A42:  MOVFF  4C,68
0A46:  MOVFF  4B,67
0A4A:  MOVFF  4A,66
0A4E:  MOVFF  03,6D
0A52:  MOVFF  02,6C
0A56:  MOVFF  01,6B
0A5A:  MOVFF  00,6A
0A5E:  RCALL  0424
0A60:  MOVFF  03,4D
0A64:  MOVFF  02,4C
0A68:  MOVFF  01,4B
0A6C:  MOVFF  00,4A
....................    } 
0A70:  BRA    0A7A
....................  
....................    else 
....................       res = 0.0; 
0A72:  CLRF   4D
0A74:  CLRF   4C
0A76:  CLRF   4B
0A78:  CLRF   4A
....................  
....................    return(res); 
0A7A:  MOVFF  4A,00
0A7E:  MOVFF  4B,01
0A82:  MOVFF  4C,02
0A86:  MOVFF  4D,03
0A8A:  RETURN 0
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
*
1354:  MOVFF  39,65
1358:  MOVFF  38,64
135C:  MOVFF  37,63
1360:  MOVFF  36,62
1364:  CLRF   x69
1366:  CLRF   x68
1368:  CLRF   x67
136A:  CLRF   x66
136C:  CALL   068E
1370:  BTFSS  FD8.0
1372:  BRA    150A
1374:  MOVFF  3D,41
1378:  MOVFF  3C,40
137C:  MOVFF  3B,3F
1380:  MOVFF  3A,3E
1384:  CLRF   45
1386:  CLRF   44
1388:  CLRF   43
138A:  MOVLW  7F
138C:  MOVWF  42
138E:  RCALL  0E26
1390:  MOVFF  03,41
1394:  MOVFF  02,40
1398:  MOVFF  01,3F
139C:  MOVFF  00,3E
13A0:  MOVFF  03,65
13A4:  MOVFF  02,64
13A8:  MOVFF  01,63
13AC:  MOVFF  00,62
13B0:  CLRF   x69
13B2:  CLRF   x68
13B4:  CLRF   x67
13B6:  CLRF   x66
13B8:  CALL   068E
13BC:  BTFSS  FD8.2
13BE:  BRA    150A
....................       if(fmod(y, 2) == 0) { 
13C0:  MOVFF  3D,41
13C4:  MOVFF  3C,40
13C8:  MOVFF  3B,3F
13CC:  MOVFF  3A,3E
13D0:  CLRF   45
13D2:  CLRF   44
13D4:  CLRF   43
13D6:  MOVLW  80
13D8:  MOVWF  42
13DA:  RCALL  0E26
13DC:  MOVFF  03,41
13E0:  MOVFF  02,40
13E4:  MOVFF  01,3F
13E8:  MOVFF  00,3E
13EC:  MOVFF  03,65
13F0:  MOVFF  02,64
13F4:  MOVFF  01,63
13F8:  MOVFF  00,62
13FC:  CLRF   x69
13FE:  CLRF   x68
1400:  CLRF   x67
1402:  CLRF   x66
1404:  CALL   068E
1408:  BNZ   1488
....................          return (exp(log(-x) * y)); 
140A:  MOVFF  36,3E
140E:  MOVF   37,W
1410:  XORLW  80
1412:  MOVWF  3F
1414:  MOVFF  38,40
1418:  MOVFF  39,41
141C:  MOVFF  39,45
1420:  MOVFF  38,44
1424:  MOVWF  43
1426:  MOVFF  36,42
142A:  CALL   074C
142E:  MOVFF  03,41
1432:  MOVFF  02,40
1436:  MOVFF  01,3F
143A:  MOVFF  00,3E
143E:  MOVFF  03,65
1442:  MOVFF  02,64
1446:  MOVFF  01,63
144A:  MOVFF  00,62
144E:  MOVFF  3D,69
1452:  MOVFF  3C,68
1456:  MOVFF  3B,67
145A:  MOVFF  3A,66
145E:  CALL   01D8
1462:  MOVFF  03,41
1466:  MOVFF  02,40
146A:  MOVFF  01,3F
146E:  MOVFF  00,3E
1472:  MOVFF  03,45
1476:  MOVFF  02,44
147A:  MOVFF  01,43
147E:  MOVFF  00,42
1482:  RCALL  0F82
1484:  BRA    1626
....................       } else { 
1486:  BRA    1508
....................          return (-exp(log(-x) * y)); 
1488:  MOVFF  36,3E
148C:  MOVF   37,W
148E:  XORLW  80
1490:  MOVWF  3F
1492:  MOVFF  38,40
1496:  MOVFF  39,41
149A:  MOVFF  39,45
149E:  MOVFF  38,44
14A2:  MOVWF  43
14A4:  MOVFF  36,42
14A8:  CALL   074C
14AC:  MOVFF  03,41
14B0:  MOVFF  02,40
14B4:  MOVFF  01,3F
14B8:  MOVFF  00,3E
14BC:  MOVFF  03,65
14C0:  MOVFF  02,64
14C4:  MOVFF  01,63
14C8:  MOVFF  00,62
14CC:  MOVFF  3D,69
14D0:  MOVFF  3C,68
14D4:  MOVFF  3B,67
14D8:  MOVFF  3A,66
14DC:  CALL   01D8
14E0:  MOVFF  03,41
14E4:  MOVFF  02,40
14E8:  MOVFF  01,3F
14EC:  MOVFF  00,3E
14F0:  MOVFF  03,45
14F4:  MOVFF  02,44
14F8:  MOVFF  01,43
14FC:  MOVFF  00,42
1500:  RCALL  0F82
1502:  MOVLW  80
1504:  XORWF  01,F
1506:  BRA    1626
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
1508:  BRA    1626
150A:  MOVFF  39,65
150E:  MOVFF  38,64
1512:  MOVFF  37,63
1516:  MOVFF  36,62
151A:  CLRF   x69
151C:  CLRF   x68
151E:  CLRF   x67
1520:  CLRF   x66
1522:  CALL   068E
1526:  BNC   157E
1528:  MOVFF  3D,41
152C:  MOVFF  3C,40
1530:  MOVFF  3B,3F
1534:  MOVFF  3A,3E
1538:  CLRF   45
153A:  CLRF   44
153C:  CLRF   43
153E:  MOVLW  7F
1540:  MOVWF  42
1542:  RCALL  0E26
1544:  MOVFF  03,41
1548:  MOVFF  02,40
154C:  MOVFF  01,3F
1550:  MOVFF  00,3E
1554:  MOVFF  03,65
1558:  MOVFF  02,64
155C:  MOVFF  01,63
1560:  MOVFF  00,62
1564:  CLRF   x69
1566:  CLRF   x68
1568:  CLRF   x67
156A:  CLRF   x66
156C:  CALL   068E
1570:  BZ    157E
....................       return 0; 
1572:  CLRF   00
1574:  CLRF   01
1576:  CLRF   02
1578:  CLRF   03
157A:  BRA    1626
....................    } else { 
157C:  BRA    1626
....................       if(x != 0 || 0 >= y) { 
157E:  MOVFF  39,65
1582:  MOVFF  38,64
1586:  MOVFF  37,63
158A:  MOVFF  36,62
158E:  CLRF   x69
1590:  CLRF   x68
1592:  CLRF   x67
1594:  CLRF   x66
1596:  CALL   068E
159A:  BNZ   15BC
159C:  MOVFF  3D,65
15A0:  MOVFF  3C,64
15A4:  MOVFF  3B,63
15A8:  MOVFF  3A,62
15AC:  CLRF   x69
15AE:  CLRF   x68
15B0:  CLRF   x67
15B2:  CLRF   x66
15B4:  CALL   068E
15B8:  BC    15BC
15BA:  BNZ   1626
....................          return (exp(log(x) * y)); 
15BC:  MOVFF  39,45
15C0:  MOVFF  38,44
15C4:  MOVFF  37,43
15C8:  MOVFF  36,42
15CC:  CALL   074C
15D0:  MOVFF  03,41
15D4:  MOVFF  02,40
15D8:  MOVFF  01,3F
15DC:  MOVFF  00,3E
15E0:  MOVFF  03,65
15E4:  MOVFF  02,64
15E8:  MOVFF  01,63
15EC:  MOVFF  00,62
15F0:  MOVFF  3D,69
15F4:  MOVFF  3C,68
15F8:  MOVFF  3B,67
15FC:  MOVFF  3A,66
1600:  CALL   01D8
1604:  MOVFF  03,41
1608:  MOVFF  02,40
160C:  MOVFF  01,3F
1610:  MOVFF  00,3E
1614:  MOVFF  03,45
1618:  MOVFF  02,44
161C:  MOVFF  01,43
1620:  MOVFF  00,42
1624:  RCALL  0F82
....................       } 
....................    } 
1626:  GOTO   17C6 (RETURN)
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #fuses HS,NOWDT,PUT,NOBROWNOUT,NOLVP   // configuração dos fuses do pic  
.................... #use   delay(clock=20000000)// Informa a função delay, o clock utilizado 
*
0028:  CLRF   FEA
002A:  MOVLW  39
002C:  MOVWF  FE9
002E:  MOVF   FEF,W
0030:  BZ    004C
0032:  MOVLW  06
0034:  MOVWF  01
0036:  CLRF   00
0038:  DECFSZ 00,F
003A:  BRA    0038
003C:  DECFSZ 01,F
003E:  BRA    0036
0040:  MOVLW  7B
0042:  MOVWF  00
0044:  DECFSZ 00,F
0046:  BRA    0044
0048:  DECFSZ FEF,F
004A:  BRA    0032
004C:  RETURN 0
*
00D4:  MOVLW  03
00D6:  SUBWF  39,F
00D8:  BNC   00EC
00DA:  CLRF   FEA
00DC:  MOVLW  39
00DE:  MOVWF  FE9
00E0:  MOVF   FEF,W
00E2:  BZ    00EC
00E4:  BRA    00E8
00E6:  BRA    00E8
00E8:  DECFSZ FEF,F
00EA:  BRA    00E6
00EC:  RETURN 0
.................... #BIT Data_Pin = 0x06.7                       // Pin mapped to PORTB.7 
.................... #BIT Data_Pin_Direction = 0x86.7             // Pin direction mapped to TRISB.7 
.................... #use   fast_io(a)//modo rápido de inicialização das portas 
.................... #use   fast_io(b)//modo rápido de inicialização das portas 
.................... #use   fast_io(d)//modo rápido de inicialização das portas 
.................... #use   fast_io(e)//modo rápido de inicialização das portas 
....................  
.................... #byte   porta = 0xf80 // atribui o nome "porta" ao registrador do port 0xf80 
.................... #byte   portb = 0xf81  
.................... #byte   portd = 0xf83 
.................... #byte   porte = 0xf84 
.................... #byte   portc = 0xf82 
.................... // pinos de entrada e saida  
.................... #bit NTC = porta.0    //  Pino de leitura do NTC  
.................... #bit PIN_COOLER = portc.0  //  Pino de leitura do DHT11 
.................... #bit POT_SET_TEMP = porta.1 //Pino de leitura do potenciometro de set da temperatura  
.................... #bit POT_SET_UMI = porta.2 //Pino de leitura do potenciometro de set da umidade  
.................... #bit BOT_BLK_LTH = portb.0 // Pino do botao paraligar a luz do lcd 
.................... #bit BOT_MORE_INF = portb.1 // botao para mais informaçoes no lcd 
.................... // pinos de saida 
.................... #bit PIN_SERV = portb.3 
.................... #bit RELE_LAMP = portb.2  //  pino que acionamento do relé da lampada/aquecedor 
.................... /*#bit PIN_IN1_MOTPAS = portb.3 //  pino de controle do motor de paso via modulo  
.................... #bit PIN_IN2_MOTPAS = portb.4 //  pino de controle do motor de paso via modulo  
.................... #bit PIN_IN3_MOTPAS = portb.5 //  pino de controle do motor de paso via modulo  
.................... #bit PIN_IN4_MOTPAS = portb.6 //  pino de controle do motor de paso via modulo */ 
.................... #bit DHT11 = portb.7 // Pino de acionamento do cooler via transistor  
.................... #bit rs =porte.0 //  via do lcd que sinaliza recepção de dados ou comando  
.................... #bit enable = porte.1 // habilita o lcd 
.................... #byte DISPLAY = portd //  seleciona o port no qual o lcd esta ligado ( o mesmo valor que esta no arquivo.h) 
.................... #INCLUDE <lcd.h> // inclui a biblioteca do modulo lcd 
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *      Rotina que envia um COMANDO para o LCD                 * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void comando_lcd(int caracter) 
.................... { 
....................    rs = 0;               // seleciona o envio de um caracter 
*
000C:  BCF    F84.0
....................    portd = caracter;         // carrega o portc com o caracter 
000E:  MOVFF  38,F83
....................    enable = 1 ;            // gera pulso no enable 
0012:  BSF    F84.1
....................    delay_us(1);            // espera 1 microsegundos 
0014:  BRA    0016
0016:  BRA    0018
0018:  NOP   
....................    enable = 0;            // desce o pino de enable 
001A:  BCF    F84.1
....................  
....................    delay_us(40);            // espera mínimo 40 microsegundos 
001C:  MOVLW  42
001E:  MOVWF  00
0020:  DECFSZ 00,F
0022:  BRA    0020
0024:  NOP   
....................     
....................    return;               // retorna 
0026:  RETURN 0
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *      Rotina que envia um DADO a ser escrito no LCD              * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void escreve_lcd(int caracter) 
.................... { 
....................    rs = 1;               // seleciona o envio de um comando 
*
0096:  BSF    F84.0
....................    portd = caracter;         // carrega o portc com o valor do comando 
0098:  MOVFF  43,F83
....................    enable = 1;            // gera pulso no enable 
009C:  BSF    F84.1
....................    delay_us(1);            // espera 3 microsegundos 
009E:  BRA    00A0
00A0:  BRA    00A2
00A2:  NOP   
....................    enable = 0;            // desce o pino de enable 
00A4:  BCF    F84.1
....................  
....................    delay_us(40);            // espera mínimo 40 microsegundos 
00A6:  MOVLW  42
00A8:  MOVWF  00
00AA:  DECFSZ 00,F
00AC:  BRA    00AA
00AE:  NOP   
....................     
....................    return;               // retorna 
00B0:  RETURN 0
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *              Função para limpar o LCD                 * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void limpa_lcd() 
.................... { 
....................    comando_lcd(0x01);         // limpa lcd    
*
004E:  MOVLW  01
0050:  MOVWF  38
0052:  RCALL  000C
....................    delay_ms (2); 
0054:  MOVLW  02
0056:  MOVWF  39
0058:  RCALL  0028
....................    return; 
005A:  RETURN 0
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *           Inicialização do Display de LCD                 * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void inicializa_lcd() 
.................... { 
....................    comando_lcd(0x30);         // envia comando para inicializar display 
005C:  MOVLW  30
005E:  MOVWF  38
0060:  RCALL  000C
....................    delay_ms(4);            // espera 4 milisengundos 
0062:  MOVLW  04
0064:  MOVWF  39
0066:  RCALL  0028
....................  
....................    comando_lcd(0x30);         // envia comando para inicializar display 
0068:  MOVLW  30
006A:  MOVWF  38
006C:  RCALL  000C
....................    delay_us(100);            // espera 100 microsengundos 
006E:  MOVLW  A6
0070:  MOVWF  00
0072:  DECFSZ 00,F
0074:  BRA    0072
0076:  NOP   
....................  
....................    comando_lcd(0x30);         // envia comando para inicializar display 
0078:  MOVLW  30
007A:  MOVWF  38
007C:  RCALL  000C
....................  
....................    comando_lcd(0x38);         // liga o display, sem cursor e sem blink 
007E:  MOVLW  38
0080:  MOVWF  38
0082:  RCALL  000C
....................  
....................    limpa_lcd();            // limpa lcd 
0084:  RCALL  004E
....................  
....................    comando_lcd(0x0c);         // display sem cursor 
0086:  MOVLW  0C
0088:  MOVWF  38
008A:  RCALL  000C
....................  
....................    comando_lcd(0x06);         // desloca cursor para a direita 
008C:  MOVLW  06
008E:  MOVWF  38
0090:  RCALL  000C
....................  
....................    return;               // retorna 
0092:  GOTO   1D70 (RETURN)
.................... }    
....................  
....................  
....................  
.................... char message2[] = "RH   = 00.0 %"; //  vetor de mensagem para a umidade  
.................... short Time_out; //  variavel para as funçoes referentes ao sensor de umidade dht11 
.................... unsigned  int8 RH_byte1, RH_byte2, CheckSum; //  variaveis para as funçoes do dht11 
....................  
.................... double ntc_val = 0; // variavel responsavel por receber o valor digital do ntc 
.................... double rntc = 0; //  valor da resistencia do divisor de tensao do ntc  
.................... double b1=0;  //  variavel auxiliar para função do ntc 
.................... double c1=0;//  variavel auxiliar para função do ntc 
.................... double temp=0;//  variavel auxiliar para função do ntc 
.................... double temperatura=0;//  variavel auxiliar para função do ntc 
.................... char umidade;//  variavel auxiliar para função do ntc 
.................... const double a = 0.0011303; //  constantes fisicas do sensor ntc 10k 
.................... const double b = 0.0002339; //  constantes fisicas do sensor ntc 10k 
.................... const double c = 0.00000008863; //  constantes fisicas do sensor ntc 10k 
.................... int cont=0; 
....................  
....................  
.................... // FUNÇÃO POR INICIAR A DHT11 
....................  
.................... void start_signal(){ 
....................   Data_Pin_Direction = 0;              // Configure connection pin as output 
*
18FE:  BCF    x86.7
....................   Data_Pin = 0;                        // Connection pin output low 
1900:  BCF    06.7
....................   delay_ms(25); 
1902:  MOVLW  19
1904:  MOVWF  39
1906:  CALL   0028
....................   Data_Pin = 1;                        // Connection pin output high 
190A:  BSF    06.7
....................   delay_us(30); 
190C:  MOVLW  31
190E:  MOVWF  00
1910:  DECFSZ 00,F
1912:  BRA    1910
1914:  BRA    1916
....................   Data_Pin_Direction = 1;              // Configure connection pin as input 
1916:  BSF    x86.7
1918:  GOTO   1A22 (RETURN)
.................... } 
....................  
.................... // FUNÇAÕ POR VERIFICAR SE O SENSOR ESTA RESPONDENDO  
....................  
....................   short check_response(){ 
....................   delay_us(40); 
191C:  MOVLW  42
191E:  MOVWF  00
1920:  DECFSZ 00,F
1922:  BRA    1920
1924:  NOP   
....................   if(!Data_Pin){                     // Read and test if connection pin is low 
1926:  BTFSC  06.7
1928:  BRA    194A
....................     delay_us(80); 
192A:  MOVLW  84
192C:  MOVWF  00
192E:  DECFSZ 00,F
1930:  BRA    192E
1932:  BRA    1934
1934:  NOP   
....................     if(Data_Pin){                    // Read and test if connection pin is high 
1936:  BTFSS  06.7
1938:  BRA    194A
....................       delay_us(50); 
193A:  MOVLW  52
193C:  MOVWF  00
193E:  DECFSZ 00,F
1940:  BRA    193E
1942:  BRA    1944
1944:  NOP   
....................       return 1;} 
1946:  MOVLW  01
1948:  MOVWF  01
....................     } 
194A:  GOTO   1A24 (RETURN)
.................... } 
....................  
....................  
.................... // FUNÇÃO PARA A OBTENÇÃO DO VALOR DE HUMIDADE 
.................... unsigned int8 Read_Data(){ 
194E:  CLRF   38
....................   unsigned int8 i, k, _data = 0;     // k is used to count 1 bit reading duration 
....................   if(Time_out) 
1950:  BTFSS  18.0
1952:  BRA    1954
....................     break; 
....................   for(i = 0; i < 8; i++){ 
1954:  CLRF   36
1956:  MOVF   36,W
1958:  SUBLW  07
195A:  BNC   19E0
....................     k = 0; 
195C:  CLRF   37
....................     while(!Data_Pin){                          // Wait until pin goes high 
195E:  BTFSC  06.7
1960:  BRA    1976
....................       k++; 
1962:  INCF   37,F
....................       if (k > 100) {Time_out = 1; break;} 
1964:  MOVF   37,W
1966:  SUBLW  64
1968:  BC    196E
196A:  BSF    18.0
196C:  BRA    1976
....................       delay_us(1);} 
196E:  BRA    1970
1970:  BRA    1972
1972:  NOP   
1974:  BRA    195E
....................     delay_us(30); 
1976:  MOVLW  31
1978:  MOVWF  00
197A:  DECFSZ 00,F
197C:  BRA    197A
197E:  BRA    1980
....................     if(!Data_Pin) 
1980:  BTFSC  06.7
1982:  BRA    19A6
....................       bit_clear(_data, (7 - i));               // Clear bit (7 - i) 
1984:  MOVLW  07
1986:  BSF    FD8.0
1988:  SUBFWB 36,W
198A:  MOVWF  39
198C:  MOVLW  01
198E:  MOVWF  00
1990:  MOVF   39,W
1992:  MOVWF  01
1994:  BZ    199E
1996:  BCF    FD8.0
1998:  RLCF   00,F
199A:  DECFSZ 01,F
199C:  BRA    1996
199E:  MOVF   00,W
19A0:  XORLW  FF
19A2:  ANDWF  38,F
19A4:  BRA    19DC
....................     else{ 
....................       bit_set(_data, (7 - i));                 // Set bit (7 - i) 
19A6:  MOVLW  07
19A8:  BSF    FD8.0
19AA:  SUBFWB 36,W
19AC:  MOVWF  39
19AE:  MOVLW  01
19B0:  MOVWF  00
19B2:  MOVF   39,W
19B4:  MOVWF  01
19B6:  BZ    19C0
19B8:  BCF    FD8.0
19BA:  RLCF   00,F
19BC:  DECFSZ 01,F
19BE:  BRA    19B8
19C0:  MOVF   00,W
19C2:  IORWF  38,F
....................       while(Data_Pin){                         // Wait until pin goes low 
19C4:  BTFSS  06.7
19C6:  BRA    19DC
....................       k++; 
19C8:  INCF   37,F
....................       if (k > 100) {Time_out = 1; break;} 
19CA:  MOVF   37,W
19CC:  SUBLW  64
19CE:  BC    19D4
19D0:  BSF    18.0
19D2:  BRA    19DC
....................       delay_us(1);} 
19D4:  BRA    19D6
19D6:  BRA    19D8
19D8:  NOP   
19DA:  BRA    19C4
....................     } 
19DC:  INCF   36,F
19DE:  BRA    1956
....................   } 
....................   return _data; 
19E0:  MOVFF  38,01
19E4:  RETURN 0
.................... } 
....................  
.................... // FUNÇÃO PRINCIPAL QUE RETORNARA A UMIDADE  
....................  
.................... char dht11(){ 
....................    delay_ms(1000); 
*
1A0E:  MOVLW  04
1A10:  MOVWF  36
1A12:  MOVLW  FA
1A14:  MOVWF  39
1A16:  CALL   0028
1A1A:  DECFSZ 36,F
1A1C:  BRA    1A12
....................    Time_out = 0; 
1A1E:  BCF    18.0
....................    Start_signal(); 
1A20:  BRA    18FE
....................    if(check_response()){// If there is response from sensor 
1A22:  BRA    191C
1A24:  MOVF   01,F
1A26:  BZ    1A72
....................    RH_byte1=Read_Data();// read RH byte1 
1A28:  RCALL  194E
1A2A:  MOVFF  01,19
....................    RH_byte2=Read_Data();// read RH byte2 
1A2E:  RCALL  194E
1A30:  MOVFF  01,1A
....................    Checksum=Read_Data();// read checksum                    
1A34:  RCALL  194E
1A36:  MOVFF  01,1B
....................       if(CheckSum==((RH_Byte1+RH_Byte2)& 0xFF)){ 
1A3A:  MOVF   1A,W
1A3C:  ADDWF  19,W
1A3E:  SUBWF  1B,W
1A40:  BNZ   1A72
....................       message2[7]=RH_Byte1/10+48; 
1A42:  MOVFF  19,36
1A46:  MOVLW  0A
1A48:  MOVWF  37
1A4A:  RCALL  19E6
1A4C:  MOVLW  30
1A4E:  ADDWF  01,W
1A50:  MOVWF  11
....................              message2[8]= RH_Byte1%10+48; 
1A52:  MOVFF  19,36
1A56:  MOVLW  0A
1A58:  MOVWF  37
1A5A:  RCALL  19E6
1A5C:  MOVLW  30
1A5E:  ADDWF  00,W
1A60:  MOVWF  12
....................              message2[10] = RH_Byte2/10+48;                             
1A62:  MOVFF  1A,36
1A66:  MOVLW  0A
1A68:  MOVWF  37
1A6A:  RCALL  19E6
1A6C:  MOVLW  30
1A6E:  ADDWF  01,W
1A70:  MOVWF  14
....................        } 
....................    }  
....................    return message2; 
1A72:  MOVLW  0A
1A74:  MOVWF  01
1A76:  MOVLW  00
1A78:  MOVWF  02
1A7A:  GOTO   1D88 (RETURN)
.................... } 
....................  
....................  
....................  
....................  
.................... float ntc(){ 
.................... set_adc_channel(0); //  escolhe o pino analogico para ler   
*
162A:  MOVLW  00
162C:  MOVWF  01
162E:  MOVF   FC2,W
1630:  ANDLW  C3
1632:  IORWF  01,W
1634:  MOVWF  FC2
.................... delay_us(10); // delay para começar a conversão  
1636:  MOVLW  10
1638:  MOVWF  00
163A:  DECFSZ 00,F
163C:  BRA    163A
163E:  NOP   
.................... ntc_val = read_adc(); // le o valor na porta analogica 
1640:  BSF    FC2.1
1642:  BTFSC  FC2.1
1644:  BRA    1642
1646:  MOVFF  FC4,03
164A:  MOVFF  FC3,66
164E:  MOVFF  FC4,67
1652:  CALL   01A2
1656:  MOVFF  03,1F
165A:  MOVFF  02,1E
165E:  MOVFF  01,1D
1662:  MOVFF  00,1C
.................... ADC_done(); 
.................... ntc_val *=5; // multiplica o valor digitalizado pelo valor de tensão de alimentação 
1666:  MOVFF  1F,65
166A:  MOVFF  1E,64
166E:  MOVFF  1D,63
1672:  MOVFF  1C,62
1676:  CLRF   x69
1678:  CLRF   x68
167A:  MOVLW  20
167C:  MOVWF  x67
167E:  MOVLW  81
1680:  MOVWF  x66
1682:  CALL   01D8
1686:  MOVFF  03,1F
168A:  MOVFF  02,1E
168E:  MOVFF  01,1D
1692:  MOVFF  00,1C
.................... ntc_val/=1023;  // divide  o valor acima por 1023 
1696:  MOVFF  1F,5E
169A:  MOVFF  1E,5D
169E:  MOVFF  1D,5C
16A2:  MOVFF  1C,5B
16A6:  CLRF   x62
16A8:  MOVLW  C0
16AA:  MOVWF  x61
16AC:  MOVLW  7F
16AE:  MOVWF  x60
16B0:  MOVLW  88
16B2:  MOVWF  5F
16B4:  CALL   02CA
16B8:  MOVFF  03,1F
16BC:  MOVFF  02,1E
16C0:  MOVFF  01,1D
16C4:  MOVFF  00,1C
.................... // Inicio calculo de equação de  Steinhart & Hart  
.................... rntc=33000/ntc_val;      
16C8:  CLRF   5E
16CA:  MOVLW  E8
16CC:  MOVWF  5D
16CE:  CLRF   5C
16D0:  MOVLW  8E
16D2:  MOVWF  5B
16D4:  MOVFF  1F,62
16D8:  MOVFF  1E,61
16DC:  MOVFF  1D,60
16E0:  MOVFF  1C,5F
16E4:  CALL   02CA
16E8:  MOVFF  03,23
16EC:  MOVFF  02,22
16F0:  MOVFF  01,21
16F4:  MOVFF  00,20
....................        rntc=rntc-10000;       
16F8:  BSF    FD8.1
16FA:  MOVFF  23,69
16FE:  MOVFF  22,68
1702:  MOVFF  21,67
1706:  MOVFF  20,66
170A:  CLRF   x6D
170C:  MOVLW  40
170E:  MOVWF  x6C
1710:  MOVLW  1C
1712:  MOVWF  x6B
1714:  MOVLW  8C
1716:  MOVWF  x6A
1718:  CALL   0424
171C:  MOVFF  03,23
1720:  MOVFF  02,22
1724:  MOVFF  01,21
1728:  MOVFF  00,20
....................        b1=log(rntc);           
172C:  MOVFF  23,45
1730:  MOVFF  22,44
1734:  MOVFF  21,43
1738:  MOVFF  20,42
173C:  CALL   074C
1740:  MOVFF  03,27
1744:  MOVFF  02,26
1748:  MOVFF  01,25
174C:  MOVFF  00,24
....................        b1=b1*b;                
1750:  MOVFF  27,65
1754:  MOVFF  26,64
1758:  MOVFF  25,63
175C:  MOVFF  24,62
1760:  MOVLW  0E
1762:  MOVWF  x69
1764:  MOVLW  43
1766:  MOVWF  x68
1768:  MOVLW  75
176A:  MOVWF  x67
176C:  MOVLW  72
176E:  MOVWF  x66
1770:  CALL   01D8
1774:  MOVFF  03,27
1778:  MOVFF  02,26
177C:  MOVFF  01,25
1780:  MOVFF  00,24
....................        c1=log(rntc);           
1784:  MOVFF  23,45
1788:  MOVFF  22,44
178C:  MOVFF  21,43
1790:  MOVFF  20,42
1794:  CALL   074C
1798:  MOVFF  03,2B
179C:  MOVFF  02,2A
17A0:  MOVFF  01,29
17A4:  MOVFF  00,28
....................        c1=pow(c1,3);           
17A8:  MOVFF  2B,39
17AC:  MOVFF  2A,38
17B0:  MOVFF  29,37
17B4:  MOVFF  28,36
17B8:  CLRF   3D
17BA:  CLRF   3C
17BC:  MOVLW  40
17BE:  MOVWF  3B
17C0:  MOVLW  80
17C2:  MOVWF  3A
17C4:  BRA    1354
17C6:  MOVFF  03,2B
17CA:  MOVFF  02,2A
17CE:  MOVFF  01,29
17D2:  MOVFF  00,28
....................        c1=c1*c;                
17D6:  MOVFF  2B,65
17DA:  MOVFF  2A,64
17DE:  MOVFF  29,63
17E2:  MOVFF  28,62
17E6:  MOVLW  DC
17E8:  MOVWF  x69
17EA:  MOVLW  54
17EC:  MOVWF  x68
17EE:  MOVLW  3E
17F0:  MOVWF  x67
17F2:  MOVLW  67
17F4:  MOVWF  x66
17F6:  CALL   01D8
17FA:  MOVFF  03,2B
17FE:  MOVFF  02,2A
1802:  MOVFF  01,29
1806:  MOVFF  00,28
....................        temp=a+b1+c1;           
180A:  BCF    FD8.1
180C:  MOVLW  93
180E:  MOVWF  x69
1810:  MOVLW  26
1812:  MOVWF  x68
1814:  MOVLW  14
1816:  MOVWF  x67
1818:  MOVLW  75
181A:  MOVWF  x66
181C:  MOVFF  27,6D
1820:  MOVFF  26,6C
1824:  MOVFF  25,6B
1828:  MOVFF  24,6A
182C:  CALL   0424
1830:  MOVFF  03,39
1834:  MOVFF  02,38
1838:  MOVFF  01,37
183C:  MOVFF  00,36
1840:  BCF    FD8.1
1842:  MOVFF  03,69
1846:  MOVFF  02,68
184A:  MOVFF  01,67
184E:  MOVFF  00,66
1852:  MOVFF  2B,6D
1856:  MOVFF  2A,6C
185A:  MOVFF  29,6B
185E:  MOVFF  28,6A
1862:  CALL   0424
1866:  MOVFF  03,2F
186A:  MOVFF  02,2E
186E:  MOVFF  01,2D
1872:  MOVFF  00,2C
....................        temp=1/temp;            
1876:  CLRF   5E
1878:  CLRF   5D
187A:  CLRF   5C
187C:  MOVLW  7F
187E:  MOVWF  5B
1880:  MOVFF  2F,62
1884:  MOVFF  2E,61
1888:  MOVFF  2D,60
188C:  MOVFF  2C,5F
1890:  CALL   02CA
1894:  MOVFF  03,2F
1898:  MOVFF  02,2E
189C:  MOVFF  01,2D
18A0:  MOVFF  00,2C
....................        temp=temp-273.15; 
18A4:  BSF    FD8.1
18A6:  MOVFF  2F,69
18AA:  MOVFF  2E,68
18AE:  MOVFF  2D,67
18B2:  MOVFF  2C,66
18B6:  MOVLW  33
18B8:  MOVWF  x6D
18BA:  MOVLW  93
18BC:  MOVWF  x6C
18BE:  MOVLW  08
18C0:  MOVWF  x6B
18C2:  MOVLW  87
18C4:  MOVWF  x6A
18C6:  CALL   0424
18CA:  MOVFF  03,2F
18CE:  MOVFF  02,2E
18D2:  MOVFF  01,2D
18D6:  MOVFF  00,2C
....................        delay_ms(500); 
18DA:  MOVLW  02
18DC:  MOVWF  36
18DE:  MOVLW  FA
18E0:  MOVWF  39
18E2:  CALL   0028
18E6:  DECFSZ 36,F
18E8:  BRA    18DE
....................        return temp; 
18EA:  MOVFF  2C,00
18EE:  MOVFF  2D,01
18F2:  MOVFF  2E,02
18F6:  MOVFF  2F,03
18FA:  GOTO   1D76 (RETURN)
.................... // Fim do calculo de equação de  Steinhart & Hart 
.................... } 
....................  
....................  
.................... int tratamento_de_bouncing() { 
....................  
....................  
....................  
....................  
.................... //  Aqui será implementada uma função para o tratamento de bouncing de todos os botoes da aplicação  
....................  
....................  
....................  
....................  
....................  
....................  
.................... } 
....................  
....................  
.................... void mexeovos () { 
.................... // Essa função é responsável por controlar o servo motor que mexe os ovos 
.................... for( int j=0; j<=10; j++){  // j=50 é cerca de 5 min  
*
00EE:  CLRF   36
00F0:  MOVF   36,W
00F2:  SUBLW  0A
00F4:  BNC   019E
....................  // para garantir que a temperatura varie pouco enquanto o ovosestão mexendo faça   
....................    limpa_lcd(); 
00F6:  RCALL  004E
....................    comando_lcd(0x83); //  posiciona o cursor no endereço 0x83 
00F8:  MOVLW  83
00FA:  MOVWF  38
00FC:  RCALL  000C
....................    printf(escreve_lcd,"MEXENDO" ); 
00FE:  MOVLW  04
0100:  MOVWF  FF6
0102:  MOVLW  00
0104:  MOVWF  FF7
0106:  BRA    00B2
....................    if(j%2==0){ 
0108:  MOVF   36,W
010A:  ANDLW  01
010C:  BNZ   0112
....................    RELE_LAMP = 1; 
010E:  BSF    F81.2
....................    PIN_COOLER = 0; 
0110:  BCF    F82.0
....................    } 
....................      if(j%2!=0){ 
0112:  MOVF   36,W
0114:  ANDLW  01
0116:  BZ    011C
....................      RELE_LAMP = 0; 
0118:  BCF    F81.2
....................      PIN_COOLER =1; 
011A:  BSF    F82.0
....................      } 
.................... // termina aqui esse arficio  
....................       for(int i=0;  i<50; i++){                       
011C:  CLRF   37
011E:  MOVF   37,W
0120:  SUBLW  31
0122:  BNC   0146
....................       PIN_SERV=1; 
0124:  BSF    F81.3
....................       delay_us(800); 
0126:  MOVLW  04
0128:  MOVWF  38
012A:  MOVLW  C7
012C:  MOVWF  39
012E:  RCALL  00D4
0130:  DECFSZ 38,F
0132:  BRA    012A
....................       PIN_SERV=0; 
0134:  BCF    F81.3
....................       delay_us(19200); 
0136:  MOVLW  13
0138:  MOVWF  39
013A:  RCALL  0028
013C:  MOVLW  C8
013E:  MOVWF  39
0140:  RCALL  00D4
0142:  INCF   37,F
0144:  BRA    011E
....................       } 
....................       delay_ms(2000); 
0146:  MOVLW  08
0148:  MOVWF  38
014A:  MOVLW  FA
014C:  MOVWF  39
014E:  RCALL  0028
0150:  DECFSZ 38,F
0152:  BRA    014A
....................       for(i=0;  i<50; i++){ 
0154:  CLRF   37
0156:  MOVF   37,W
0158:  SUBLW  31
015A:  BNC   018C
....................       PIN_SERV=1; 
015C:  BSF    F81.3
....................       delay_us(1500); 
015E:  MOVLW  01
0160:  MOVWF  39
0162:  RCALL  0028
0164:  MOVLW  02
0166:  MOVWF  38
0168:  MOVLW  F9
016A:  MOVWF  39
016C:  RCALL  00D4
016E:  DECFSZ 38,F
0170:  BRA    0168
....................       PIN_SERV=0; 
0172:  BCF    F81.3
....................       delay_us(18500); 
0174:  MOVLW  12
0176:  MOVWF  39
0178:  RCALL  0028
017A:  MOVLW  02
017C:  MOVWF  38
017E:  MOVLW  F9
0180:  MOVWF  39
0182:  RCALL  00D4
0184:  DECFSZ 38,F
0186:  BRA    017E
0188:  INCF   37,F
018A:  BRA    0156
....................       } 
....................       delay_ms(2000); 
018C:  MOVLW  08
018E:  MOVWF  38
0190:  MOVLW  FA
0192:  MOVWF  39
0194:  RCALL  0028
0196:  DECFSZ 38,F
0198:  BRA    0190
019A:  INCF   36,F
019C:  BRA    00F0
....................  } 
019E:  GOTO   1D74 (RETURN)
....................     
.................... } 
....................  
.................... void main (void){ 
*
1CD0:  CLRF   FF8
1CD2:  BCF    FD0.7
1CD4:  CLRF   1F
1CD6:  CLRF   1E
1CD8:  CLRF   1D
1CDA:  CLRF   1C
1CDC:  CLRF   23
1CDE:  CLRF   22
1CE0:  CLRF   21
1CE2:  CLRF   20
1CE4:  CLRF   27
1CE6:  CLRF   26
1CE8:  CLRF   25
1CEA:  CLRF   24
1CEC:  CLRF   2B
1CEE:  CLRF   2A
1CF0:  CLRF   29
1CF2:  CLRF   28
1CF4:  CLRF   2F
1CF6:  CLRF   2E
1CF8:  CLRF   2D
1CFA:  CLRF   2C
1CFC:  CLRF   33
1CFE:  CLRF   32
1D00:  CLRF   31
1D02:  CLRF   30
1D04:  CLRF   35
1D06:  MOVF   FC1,W
1D08:  ANDLW  C0
1D0A:  IORLW  0F
1D0C:  MOVWF  FC1
1D0E:  MOVLW  07
1D10:  MOVWF  FB4
1D12:  CLRF   04
1D14:  CLRF   05
1D16:  MOVLW  52
1D18:  MOVWF  0A
1D1A:  MOVLW  48
1D1C:  MOVWF  0B
1D1E:  MOVLW  A0
1D20:  MOVWF  0C
1D22:  MOVWF  0D
1D24:  MOVWF  0E
1D26:  MOVLW  3D
1D28:  MOVWF  0F
1D2A:  MOVLW  A0
1D2C:  MOVWF  10
1D2E:  MOVLW  30
1D30:  MOVWF  11
1D32:  MOVWF  12
1D34:  MOVLW  2E
1D36:  MOVWF  13
1D38:  MOVLW  30
1D3A:  MOVWF  14
1D3C:  MOVLW  A0
1D3E:  MOVWF  15
1D40:  MOVLW  25
1D42:  MOVWF  16
1D44:  CLRF   17
.................... setup_adc(ADC_CLOCK_DIV_8); //  configura o clock utilizado para o conversor ad e o pior clock ele usa a malha RC é lenta  
1D46:  MOVF   FC0,W
1D48:  ANDLW  C0
1D4A:  IORLW  01
1D4C:  MOVWF  FC0
1D4E:  BSF    FC0.7
1D50:  BSF    FC2.0
.................... setup_adc_ports( AN0_TO_AN2 ); // selecionaos pinos A0 a A2 como pinos de sinais analogicos  
1D52:  MOVF   FC1,W
1D54:  ANDLW  C0
1D56:  IORLW  0C
1D58:  MOVWF  FC1
.................... set_tris_a(0b00001111); // verificar se pinos analogicos necessitam de definição de tris 
1D5A:  MOVLW  0F
1D5C:  MOVWF  F92
.................... set_tris_b(0b11000000);   
1D5E:  MOVLW  C0
1D60:  MOVWF  F93
.................... set_tris_c(0b00000000);// define os pinos RB0 E RB1 como entrada e os demais como saida 
1D62:  MOVLW  00
1D64:  MOVWF  F94
.................... set_tris_d(0b00000000);  //  Idem como supracitado acima  
1D66:  MOVWF  F95
.................... set_tris_e(0b00000100); 
1D68:  MOVLW  04
1D6A:  MOVWF  F96
.................... inicializa_lcd(); // função responsavel por inicializar o modulo lcd 
1D6C:  GOTO   005C
....................   mexeovos(); 
1D70:  GOTO   00EE
....................    
....................   while(true){ 
....................   temperatura = ntc(); //  le o valor  de temperatura em graus celsius que a função do ntc retorna  
1D74:  BRA    162A
1D76:  MOVFF  03,33
1D7A:  MOVFF  02,32
1D7E:  MOVFF  01,31
1D82:  MOVFF  00,30
....................   umidade = dht11(); 
1D86:  BRA    1A0E
1D88:  MOVFF  01,34
....................   comando_lcd(0x83); //  posiciona o cursor no endereço 0x83 
1D8C:  MOVLW  83
1D8E:  MOVWF  38
1D90:  CALL   000C
....................   printf(escreve_lcd,"%f\n", temperatura ); 
1D94:  MOVLW  89
1D96:  MOVWF  FE9
1D98:  MOVFF  33,39
1D9C:  MOVFF  32,38
1DA0:  MOVFF  31,37
1DA4:  MOVFF  30,36
1DA8:  MOVLW  02
1DAA:  MOVWF  3A
1DAC:  BRA    1B4C
1DAE:  MOVLW  0A
1DB0:  MOVWF  43
1DB2:  CALL   0096
....................     // implementação da rotina de controle de  temperatura  
....................    if(temperatura<=38){   //  verifica se da temperatura de menor que 38 graus e faz  a rotina  
1DB6:  MOVFF  33,65
1DBA:  MOVFF  32,64
1DBE:  MOVFF  31,63
1DC2:  MOVFF  30,62
1DC6:  CLRF   x69
1DC8:  CLRF   x68
1DCA:  MOVLW  18
1DCC:  MOVWF  x67
1DCE:  MOVLW  84
1DD0:  MOVWF  x66
1DD2:  CALL   068E
1DD6:  BC    1DDA
1DD8:  BNZ   1DDE
....................      PIN_COOLER =0 ; 
1DDA:  BCF    F82.0
....................      RELE_LAMP = 1 ; 
1DDC:  BSF    F81.2
....................     } 
....................     if(temperatura>38){ 
1DDE:  CLRF   x65
1DE0:  CLRF   x64
1DE2:  MOVLW  18
1DE4:  MOVWF  x63
1DE6:  MOVLW  84
1DE8:  MOVWF  x62
1DEA:  MOVFF  33,69
1DEE:  MOVFF  32,68
1DF2:  MOVFF  31,67
1DF6:  MOVFF  30,66
1DFA:  CALL   068E
1DFE:  BNC   1E04
....................     PIN_COOLER =1 ; 
1E00:  BSF    F82.0
....................     RELE_LAMP = 0 ;  
1E02:  BCF    F81.2
....................     } 
1E04:  BRA    1D74
....................     //delay_ms(2000);    
....................   } 
....................    
....................    
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... } 
1E06:  SLEEP 

Configuration Fuses:
   Word  1: CC3F   PLL12 CPUDIV4 USBDIV HS FCMEN IESO
   Word  2: 1E38   PUT NOBROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
