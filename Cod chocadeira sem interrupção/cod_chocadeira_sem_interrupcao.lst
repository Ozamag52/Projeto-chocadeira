CCS PCH C Compiler, Version 5.015, 5967               29-jun-17 15:38

               Filename:   C:\Users\henri\Documents\GitHub\Projeto-chocadeira\Cod chocadeira sem interrupção\cod_chocadeira_sem_interrupcao.lst

               ROM used:   7362 bytes (22%)
                           Largest free fragment is 25402
               RAM used:   87 (4%) at main() level
                           153 (7%) worst case
               Stack used: 7 locations (6 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   1B56
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  FF2.5
004A:  GOTO   0054
004E:  BTFSC  FF2.2
0050:  GOTO   0096
0054:  MOVFF  0E,00
0058:  MOVFF  0F,01
005C:  MOVFF  10,02
0060:  MOVFF  11,03
0064:  MOVFF  0C,FE9
0068:  MOVFF  07,FEA
006C:  BSF    07.7
006E:  MOVFF  08,FE1
0072:  MOVFF  09,FE2
0076:  MOVFF  0A,FD9
007A:  MOVFF  0B,FDA
007E:  MOVFF  12,FF3
0082:  MOVFF  13,FF4
0086:  MOVFF  14,FFA
008A:  MOVF   04,W
008C:  MOVFF  06,FE0
0090:  MOVFF  05,FD8
0094:  RETFIE 0
....................  
.................... #INCLUDE<18F4550.h>//   Inclui a biblioteca resposável por estabelecer os parametros do pic utilizado no projeto 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
*
00CC:  DATA 4D,45
00CE:  DATA 58,45
00D0:  DATA 4E,44
00D2:  DATA 4F,00
*
015E:  MOVLW  8E
0160:  MOVWF  00
0162:  MOVFF  88,01
0166:  MOVFF  87,02
016A:  CLRF   03
016C:  MOVF   01,F
016E:  BNZ   0182
0170:  MOVFF  02,01
0174:  CLRF   02
0176:  MOVLW  08
0178:  SUBWF  00,F
017A:  MOVF   01,F
017C:  BNZ   0182
017E:  CLRF   00
0180:  BRA    0192
0182:  BCF    FD8.0
0184:  BTFSC  01.7
0186:  BRA    0190
0188:  RLCF   02,F
018A:  RLCF   01,F
018C:  DECF   00,F
018E:  BRA    0182
0190:  BCF    01.7
0192:  RETURN 0
0194:  MOVF   x83,W
0196:  BTFSC  FD8.2
0198:  BRA    027C
019A:  MOVWF  00
019C:  MOVF   x87,W
019E:  BTFSC  FD8.2
01A0:  BRA    027C
01A2:  ADDWF  00,F
01A4:  BNC   01AE
01A6:  MOVLW  81
01A8:  ADDWF  00,F
01AA:  BC    027C
01AC:  BRA    01B6
01AE:  MOVLW  7F
01B0:  SUBWF  00,F
01B2:  BNC   027C
01B4:  BZ    027C
01B6:  MOVFF  84,8B
01BA:  MOVF   x88,W
01BC:  XORWF  x8B,F
01BE:  BSF    x84.7
01C0:  BSF    x88.7
01C2:  MOVF   x86,W
01C4:  MULWF  x8A
01C6:  MOVFF  FF4,8D
01CA:  MOVF   x85,W
01CC:  MULWF  x89
01CE:  MOVFF  FF4,03
01D2:  MOVFF  FF3,8C
01D6:  MULWF  x8A
01D8:  MOVF   FF3,W
01DA:  ADDWF  x8D,F
01DC:  MOVF   FF4,W
01DE:  ADDWFC x8C,F
01E0:  MOVLW  00
01E2:  ADDWFC 03,F
01E4:  MOVF   x86,W
01E6:  MULWF  x89
01E8:  MOVF   FF3,W
01EA:  ADDWF  x8D,F
01EC:  MOVF   FF4,W
01EE:  ADDWFC x8C,F
01F0:  MOVLW  00
01F2:  CLRF   02
01F4:  ADDWFC 03,F
01F6:  ADDWFC 02,F
01F8:  MOVF   x84,W
01FA:  MULWF  x8A
01FC:  MOVF   FF3,W
01FE:  ADDWF  x8C,F
0200:  MOVF   FF4,W
0202:  ADDWFC 03,F
0204:  MOVLW  00
0206:  ADDWFC 02,F
0208:  MOVF   x84,W
020A:  MULWF  x89
020C:  MOVF   FF3,W
020E:  ADDWF  03,F
0210:  MOVF   FF4,W
0212:  ADDWFC 02,F
0214:  MOVLW  00
0216:  CLRF   01
0218:  ADDWFC 01,F
021A:  MOVF   x86,W
021C:  MULWF  x88
021E:  MOVF   FF3,W
0220:  ADDWF  x8C,F
0222:  MOVF   FF4,W
0224:  ADDWFC 03,F
0226:  MOVLW  00
0228:  ADDWFC 02,F
022A:  ADDWFC 01,F
022C:  MOVF   x85,W
022E:  MULWF  x88
0230:  MOVF   FF3,W
0232:  ADDWF  03,F
0234:  MOVF   FF4,W
0236:  ADDWFC 02,F
0238:  MOVLW  00
023A:  ADDWFC 01,F
023C:  MOVF   x84,W
023E:  MULWF  x88
0240:  MOVF   FF3,W
0242:  ADDWF  02,F
0244:  MOVF   FF4,W
0246:  ADDWFC 01,F
0248:  INCF   00,F
024A:  BTFSC  01.7
024C:  BRA    0258
024E:  RLCF   x8C,F
0250:  RLCF   03,F
0252:  RLCF   02,F
0254:  RLCF   01,F
0256:  DECF   00,F
0258:  MOVLW  00
025A:  BTFSS  x8C.7
025C:  BRA    0272
025E:  INCF   03,F
0260:  ADDWFC 02,F
0262:  ADDWFC 01,F
0264:  MOVF   01,W
0266:  BNZ   0272
0268:  MOVF   02,W
026A:  BNZ   0272
026C:  MOVF   03,W
026E:  BNZ   0272
0270:  INCF   00,F
0272:  BTFSC  x8B.7
0274:  BSF    01.7
0276:  BTFSS  x8B.7
0278:  BCF    01.7
027A:  BRA    0284
027C:  CLRF   00
027E:  CLRF   01
0280:  CLRF   02
0282:  CLRF   03
0284:  RETURN 0
0286:  MOVF   x7C,W
0288:  BTFSC  FD8.2
028A:  BRA    03D6
028C:  MOVWF  x88
028E:  MOVF   x80,W
0290:  BTFSC  FD8.2
0292:  BRA    03D6
0294:  SUBWF  x88,F
0296:  BNC   02A2
0298:  MOVLW  7F
029A:  ADDWF  x88,F
029C:  BTFSC  FD8.0
029E:  BRA    03D6
02A0:  BRA    02AE
02A2:  MOVLW  81
02A4:  SUBWF  x88,F
02A6:  BTFSS  FD8.0
02A8:  BRA    03D6
02AA:  BTFSC  FD8.2
02AC:  BRA    03D6
02AE:  MOVFF  88,00
02B2:  CLRF   01
02B4:  CLRF   02
02B6:  CLRF   03
02B8:  CLRF   x87
02BA:  MOVFF  7D,86
02BE:  BSF    x86.7
02C0:  MOVFF  7E,85
02C4:  MOVFF  7F,84
02C8:  MOVLW  19
02CA:  MOVWF  x88
02CC:  MOVF   x83,W
02CE:  SUBWF  x84,F
02D0:  BC    02EC
02D2:  MOVLW  01
02D4:  SUBWF  x85,F
02D6:  BC    02EC
02D8:  SUBWF  x86,F
02DA:  BC    02EC
02DC:  SUBWF  x87,F
02DE:  BC    02EC
02E0:  INCF   x87,F
02E2:  INCF   x86,F
02E4:  INCF   x85,F
02E6:  MOVF   x83,W
02E8:  ADDWF  x84,F
02EA:  BRA    033C
02EC:  MOVF   x82,W
02EE:  SUBWF  x85,F
02F0:  BC    0316
02F2:  MOVLW  01
02F4:  SUBWF  x86,F
02F6:  BC    0316
02F8:  SUBWF  x87,F
02FA:  BC    0316
02FC:  INCF   x87,F
02FE:  INCF   x86,F
0300:  MOVF   x82,W
0302:  ADDWF  x85,F
0304:  MOVF   x83,W
0306:  ADDWF  x84,F
0308:  BNC   033C
030A:  INCF   x85,F
030C:  BNZ   033C
030E:  INCF   x86,F
0310:  BNZ   033C
0312:  INCF   x87,F
0314:  BRA    033C
0316:  MOVF   x81,W
0318:  IORLW  80
031A:  SUBWF  x86,F
031C:  BC    033A
031E:  MOVLW  01
0320:  SUBWF  x87,F
0322:  BC    033A
0324:  INCF   x87,F
0326:  MOVF   x81,W
0328:  IORLW  80
032A:  ADDWF  x86,F
032C:  MOVF   x82,W
032E:  ADDWF  x85,F
0330:  BNC   0304
0332:  INCF   x86,F
0334:  BNZ   0304
0336:  INCF   x87,F
0338:  BRA    0304
033A:  BSF    03.0
033C:  DECFSZ x88,F
033E:  BRA    0342
0340:  BRA    0358
0342:  BCF    FD8.0
0344:  RLCF   x84,F
0346:  RLCF   x85,F
0348:  RLCF   x86,F
034A:  RLCF   x87,F
034C:  BCF    FD8.0
034E:  RLCF   03,F
0350:  RLCF   02,F
0352:  RLCF   01,F
0354:  RLCF   x89,F
0356:  BRA    02CC
0358:  BTFSS  x89.0
035A:  BRA    0368
035C:  BCF    FD8.0
035E:  RRCF   01,F
0360:  RRCF   02,F
0362:  RRCF   03,F
0364:  RRCF   x89,F
0366:  BRA    036C
0368:  DECF   00,F
036A:  BZ    03D6
036C:  BTFSC  x89.7
036E:  BRA    03AC
0370:  BCF    FD8.0
0372:  RLCF   x84,F
0374:  RLCF   x85,F
0376:  RLCF   x86,F
0378:  RLCF   x87,F
037A:  MOVF   x83,W
037C:  SUBWF  x84,F
037E:  BC    038E
0380:  MOVLW  01
0382:  SUBWF  x85,F
0384:  BC    038E
0386:  SUBWF  x86,F
0388:  BC    038E
038A:  SUBWF  x87,F
038C:  BNC   03C2
038E:  MOVF   x82,W
0390:  SUBWF  x85,F
0392:  BC    039E
0394:  MOVLW  01
0396:  SUBWF  x86,F
0398:  BC    039E
039A:  SUBWF  x87,F
039C:  BNC   03C2
039E:  MOVF   x81,W
03A0:  IORLW  80
03A2:  SUBWF  x86,F
03A4:  BC    03AC
03A6:  MOVLW  01
03A8:  SUBWF  x87,F
03AA:  BNC   03C2
03AC:  INCF   03,F
03AE:  BNZ   03C2
03B0:  INCF   02,F
03B2:  BNZ   03C2
03B4:  INCF   01,F
03B6:  BNZ   03C2
03B8:  INCF   00,F
03BA:  BZ    03D6
03BC:  RRCF   01,F
03BE:  RRCF   02,F
03C0:  RRCF   03,F
03C2:  MOVFF  7D,88
03C6:  MOVF   x81,W
03C8:  XORWF  x88,F
03CA:  BTFSS  x88.7
03CC:  BRA    03D2
03CE:  BSF    01.7
03D0:  BRA    03DE
03D2:  BCF    01.7
03D4:  BRA    03DE
03D6:  CLRF   00
03D8:  CLRF   01
03DA:  CLRF   02
03DC:  CLRF   03
03DE:  RETURN 0
03E0:  MOVLW  80
03E2:  BTFSC  FD8.1
03E4:  XORWF  x8C,F
03E6:  CLRF   x91
03E8:  CLRF   x92
03EA:  MOVFF  88,90
03EE:  MOVF   x8C,W
03F0:  XORWF  x90,F
03F2:  MOVF   x87,W
03F4:  BTFSC  FD8.2
03F6:  BRA    05B0
03F8:  MOVWF  x8F
03FA:  MOVWF  00
03FC:  MOVF   x8B,W
03FE:  BTFSC  FD8.2
0400:  BRA    05C2
0402:  SUBWF  x8F,F
0404:  BTFSC  FD8.2
0406:  BRA    050A
0408:  BNC   0484
040A:  MOVFF  8C,95
040E:  BSF    x95.7
0410:  MOVFF  8D,94
0414:  MOVFF  8E,93
0418:  CLRF   x92
041A:  BCF    FD8.0
041C:  RRCF   x95,F
041E:  RRCF   x94,F
0420:  RRCF   x93,F
0422:  RRCF   x92,F
0424:  DECFSZ x8F,F
0426:  BRA    0418
0428:  BTFSS  x90.7
042A:  BRA    0432
042C:  BSF    x91.0
042E:  BRA    05EA
0430:  BCF    x91.0
0432:  BCF    x8F.0
0434:  BSF    x91.4
0436:  CLRF   FEA
0438:  MOVLW  8A
043A:  MOVWF  FE9
043C:  BRA    0610
043E:  BCF    x91.4
0440:  BTFSC  x90.7
0442:  BRA    0458
0444:  BTFSS  x8F.0
0446:  BRA    046E
0448:  RRCF   x95,F
044A:  RRCF   x94,F
044C:  RRCF   x93,F
044E:  RRCF   x92,F
0450:  INCF   00,F
0452:  BTFSC  FD8.2
0454:  BRA    05E0
0456:  BRA    046E
0458:  BTFSC  x95.7
045A:  BRA    0474
045C:  BCF    FD8.0
045E:  RLCF   x92,F
0460:  RLCF   x93,F
0462:  RLCF   x94,F
0464:  RLCF   x95,F
0466:  DECF   00,F
0468:  BTFSC  FD8.2
046A:  BRA    05E0
046C:  BRA    0458
046E:  BSF    x91.6
0470:  BRA    0548
0472:  BCF    x91.6
0474:  MOVFF  88,90
0478:  BTFSS  x88.7
047A:  BRA    0480
047C:  BSF    x95.7
047E:  BRA    05D2
0480:  BCF    x95.7
0482:  BRA    05D2
0484:  MOVFF  8B,8F
0488:  MOVFF  8B,00
048C:  MOVF   x87,W
048E:  SUBWF  x8F,F
0490:  MOVFF  88,95
0494:  BSF    x95.7
0496:  MOVFF  89,94
049A:  MOVFF  8A,93
049E:  CLRF   x92
04A0:  BCF    FD8.0
04A2:  RRCF   x95,F
04A4:  RRCF   x94,F
04A6:  RRCF   x93,F
04A8:  RRCF   x92,F
04AA:  DECFSZ x8F,F
04AC:  BRA    049E
04AE:  BTFSS  x90.7
04B0:  BRA    04B8
04B2:  BSF    x91.1
04B4:  BRA    05EA
04B6:  BCF    x91.1
04B8:  BCF    x8F.0
04BA:  BSF    x91.5
04BC:  CLRF   FEA
04BE:  MOVLW  8E
04C0:  MOVWF  FE9
04C2:  BRA    0610
04C4:  BCF    x91.5
04C6:  BTFSC  x90.7
04C8:  BRA    04DE
04CA:  BTFSS  x8F.0
04CC:  BRA    04F4
04CE:  RRCF   x95,F
04D0:  RRCF   x94,F
04D2:  RRCF   x93,F
04D4:  RRCF   x92,F
04D6:  INCF   00,F
04D8:  BTFSC  FD8.2
04DA:  BRA    05E0
04DC:  BRA    04F4
04DE:  BTFSC  x95.7
04E0:  BRA    04FA
04E2:  BCF    FD8.0
04E4:  RLCF   x92,F
04E6:  RLCF   x93,F
04E8:  RLCF   x94,F
04EA:  RLCF   x95,F
04EC:  DECF   00,F
04EE:  BTFSC  FD8.2
04F0:  BRA    05E0
04F2:  BRA    04DE
04F4:  BSF    x91.7
04F6:  BRA    0548
04F8:  BCF    x91.7
04FA:  MOVFF  8C,90
04FE:  BTFSS  x8C.7
0500:  BRA    0506
0502:  BSF    x95.7
0504:  BRA    05D2
0506:  BCF    x95.7
0508:  BRA    05D2
050A:  MOVFF  8C,95
050E:  BSF    x95.7
0510:  MOVFF  8D,94
0514:  MOVFF  8E,93
0518:  BTFSS  x90.7
051A:  BRA    0524
051C:  BCF    x95.7
051E:  BSF    x91.2
0520:  BRA    05EA
0522:  BCF    x91.2
0524:  CLRF   x92
0526:  BCF    x8F.0
0528:  CLRF   FEA
052A:  MOVLW  8A
052C:  MOVWF  FE9
052E:  BRA    0610
0530:  BTFSC  x90.7
0532:  BRA    056C
0534:  MOVFF  88,90
0538:  BTFSS  x8F.0
053A:  BRA    0548
053C:  RRCF   x95,F
053E:  RRCF   x94,F
0540:  RRCF   x93,F
0542:  RRCF   x92,F
0544:  INCF   00,F
0546:  BZ    05E0
0548:  BTFSS  x92.7
054A:  BRA    0562
054C:  INCF   x93,F
054E:  BNZ   0562
0550:  INCF   x94,F
0552:  BNZ   0562
0554:  INCF   x95,F
0556:  BNZ   0562
0558:  RRCF   x95,F
055A:  RRCF   x94,F
055C:  RRCF   x93,F
055E:  INCF   00,F
0560:  BZ    05E0
0562:  BTFSC  x91.6
0564:  BRA    0472
0566:  BTFSC  x91.7
0568:  BRA    04F8
056A:  BRA    05A4
056C:  MOVLW  80
056E:  XORWF  x95,F
0570:  BTFSS  x95.7
0572:  BRA    057C
0574:  BRA    05EA
0576:  MOVFF  8C,90
057A:  BRA    0590
057C:  MOVFF  88,90
0580:  MOVF   x95,F
0582:  BNZ   0590
0584:  MOVF   x94,F
0586:  BNZ   0590
0588:  MOVF   x93,F
058A:  BNZ   0590
058C:  CLRF   00
058E:  BRA    05D2
0590:  BTFSC  x95.7
0592:  BRA    05A4
0594:  BCF    FD8.0
0596:  RLCF   x92,F
0598:  RLCF   x93,F
059A:  RLCF   x94,F
059C:  RLCF   x95,F
059E:  DECFSZ 00,F
05A0:  BRA    0590
05A2:  BRA    05E0
05A4:  BTFSS  x90.7
05A6:  BRA    05AC
05A8:  BSF    x95.7
05AA:  BRA    05D2
05AC:  BCF    x95.7
05AE:  BRA    05D2
05B0:  MOVFF  8B,00
05B4:  MOVFF  8C,95
05B8:  MOVFF  8D,94
05BC:  MOVFF  8E,93
05C0:  BRA    05D2
05C2:  MOVFF  87,00
05C6:  MOVFF  88,95
05CA:  MOVFF  89,94
05CE:  MOVFF  8A,93
05D2:  MOVFF  95,01
05D6:  MOVFF  94,02
05DA:  MOVFF  93,03
05DE:  BRA    0648
05E0:  CLRF   00
05E2:  CLRF   01
05E4:  CLRF   02
05E6:  CLRF   03
05E8:  BRA    0648
05EA:  CLRF   x92
05EC:  COMF   x93,F
05EE:  COMF   x94,F
05F0:  COMF   x95,F
05F2:  COMF   x92,F
05F4:  INCF   x92,F
05F6:  BNZ   0602
05F8:  INCF   x93,F
05FA:  BNZ   0602
05FC:  INCF   x94,F
05FE:  BNZ   0602
0600:  INCF   x95,F
0602:  BTFSC  x91.0
0604:  BRA    0430
0606:  BTFSC  x91.1
0608:  BRA    04B6
060A:  BTFSC  x91.2
060C:  BRA    0522
060E:  BRA    0576
0610:  MOVF   FEF,W
0612:  ADDWF  x93,F
0614:  BNC   0620
0616:  INCF   x94,F
0618:  BNZ   0620
061A:  INCF   x95,F
061C:  BTFSC  FD8.2
061E:  BSF    x8F.0
0620:  MOVF   FED,F
0622:  MOVF   FEF,W
0624:  ADDWF  x94,F
0626:  BNC   062E
0628:  INCF   x95,F
062A:  BTFSC  FD8.2
062C:  BSF    x8F.0
062E:  MOVF   FED,F
0630:  MOVF   FEF,W
0632:  BTFSC  FEF.7
0634:  BRA    0638
0636:  XORLW  80
0638:  ADDWF  x95,F
063A:  BTFSC  FD8.0
063C:  BSF    x8F.0
063E:  BTFSC  x91.4
0640:  BRA    043E
0642:  BTFSC  x91.5
0644:  BRA    04C4
0646:  BRA    0530
0648:  RETURN 0
064A:  MOVFF  84,8B
064E:  MOVF   x88,W
0650:  XORWF  x8B,F
0652:  BTFSS  x8B.7
0654:  BRA    0660
0656:  BCF    FD8.2
0658:  BCF    FD8.0
065A:  BTFSC  x84.7
065C:  BSF    FD8.0
065E:  BRA    06BE
0660:  MOVFF  84,8B
0664:  MOVFF  87,8C
0668:  MOVF   x83,W
066A:  SUBWF  x8C,F
066C:  BZ    067A
066E:  BTFSS  x8B.7
0670:  BRA    06BE
0672:  MOVF   FD8,W
0674:  XORLW  01
0676:  MOVWF  FD8
0678:  BRA    06BE
067A:  MOVFF  88,8C
067E:  MOVF   x84,W
0680:  SUBWF  x8C,F
0682:  BZ    0690
0684:  BTFSS  x8B.7
0686:  BRA    06BE
0688:  MOVF   FD8,W
068A:  XORLW  01
068C:  MOVWF  FD8
068E:  BRA    06BE
0690:  MOVFF  89,8C
0694:  MOVF   x85,W
0696:  SUBWF  x8C,F
0698:  BZ    06A6
069A:  BTFSS  x8B.7
069C:  BRA    06BE
069E:  MOVF   FD8,W
06A0:  XORLW  01
06A2:  MOVWF  FD8
06A4:  BRA    06BE
06A6:  MOVFF  8A,8C
06AA:  MOVF   x86,W
06AC:  SUBWF  x8C,F
06AE:  BZ    06BC
06B0:  BTFSS  x8B.7
06B2:  BRA    06BE
06B4:  MOVF   FD8,W
06B6:  XORLW  01
06B8:  MOVWF  FD8
06BA:  BRA    06BE
06BC:  BCF    FD8.0
06BE:  RETURN 0
06C0:  MOVLW  8E
06C2:  MOVWF  00
06C4:  MOVFF  7A,01
06C8:  MOVFF  79,02
06CC:  CLRF   03
06CE:  BTFSS  x7A.7
06D0:  BRA    06DC
06D2:  COMF   01,F
06D4:  COMF   02,F
06D6:  INCF   02,F
06D8:  BNZ   06DC
06DA:  INCF   01,F
06DC:  MOVF   01,F
06DE:  BNZ   06F2
06E0:  MOVFF  02,01
06E4:  CLRF   02
06E6:  MOVLW  08
06E8:  SUBWF  00,F
06EA:  MOVF   01,F
06EC:  BNZ   06F2
06EE:  CLRF   00
06F0:  BRA    0706
06F2:  BCF    FD8.0
06F4:  BTFSC  01.7
06F6:  BRA    0700
06F8:  RLCF   02,F
06FA:  RLCF   01,F
06FC:  DECF   00,F
06FE:  BRA    06F2
0700:  BTFSC  x7A.7
0702:  BRA    0706
0704:  BCF    01.7
0706:  RETURN 0
*
0A48:  MOVLW  8E
0A4A:  MOVWF  00
0A4C:  MOVF   x83,W
0A4E:  SUBWF  00,F
0A50:  MOVFF  84,02
0A54:  MOVFF  85,01
0A58:  BSF    02.7
0A5A:  MOVF   00,F
0A5C:  BZ    0A70
0A5E:  BCF    FD8.0
0A60:  MOVF   02,F
0A62:  BNZ   0A68
0A64:  MOVF   01,F
0A66:  BZ    0A70
0A68:  RRCF   02,F
0A6A:  RRCF   01,F
0A6C:  DECFSZ 00,F
0A6E:  BRA    0A5E
0A70:  BTFSS  x84.7
0A72:  BRA    0A7E
0A74:  COMF   01,F
0A76:  COMF   02,F
0A78:  INCF   01,F
0A7A:  BTFSC  FD8.2
0A7C:  INCF   02,F
0A7E:  RETURN 0
*
199E:  MOVF   58,W
19A0:  CLRF   01
19A2:  SUBWF  57,W
19A4:  BC    19AC
19A6:  MOVFF  57,00
19AA:  BRA    19C4
19AC:  CLRF   00
19AE:  MOVLW  08
19B0:  MOVWF  59
19B2:  RLCF   57,F
19B4:  RLCF   00,F
19B6:  MOVF   58,W
19B8:  SUBWF  00,W
19BA:  BTFSC  FD8.0
19BC:  MOVWF  00
19BE:  RLCF   01,F
19C0:  DECFSZ 59,F
19C2:  BRA    19B2
19C4:  RETURN 0
*
1A52:  MOVF   FEF,F
1A54:  BZ    1A74
1A56:  MOVFF  FEA,58
1A5A:  MOVFF  FE9,57
1A5E:  MOVFF  FEF,5A
1A62:  RCALL  1A36
1A64:  MOVFF  58,FEA
1A68:  MOVFF  57,FE9
1A6C:  INCF   FE9,F
1A6E:  BTFSC  FD8.2
1A70:  INCF   FEA,F
1A72:  BRA    1A52
1A74:  GOTO   1C6A (RETURN)
1A78:  TBLRD*+
1A7A:  MOVF   FF5,F
1A7C:  BZ    1A96
1A7E:  MOVFF  FF6,58
1A82:  MOVFF  FF7,59
1A86:  MOVFF  FF5,5A
1A8A:  RCALL  1A36
1A8C:  MOVFF  58,FF6
1A90:  MOVFF  59,FF7
1A94:  BRA    1A78
1A96:  GOTO   1ACA (RETURN)
....................  
.................... #list 
....................  
.................... #DEVICE ADC =10  // seleciona o conversor a/d com 10 bits 
.................... #INCLUDE <stdlib.h>   
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <math.h> //  Inclui a biblioteca responsavel por fornecer funções de calculos matematicos  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
0A80:  BCF    x82.0
....................    y = x; 
0A82:  MOVFF  76,7B
0A86:  MOVFF  75,7A
0A8A:  MOVFF  74,79
0A8E:  MOVFF  73,78
....................  
....................    if (x < 0) 
0A92:  MOVFF  76,86
0A96:  MOVFF  75,85
0A9A:  MOVFF  74,84
0A9E:  MOVFF  73,83
0AA2:  CLRF   x8A
0AA4:  CLRF   x89
0AA6:  CLRF   x88
0AA8:  CLRF   x87
0AAA:  RCALL  064A
0AAC:  BNC   0AB6
....................    { 
....................       s = 1; 
0AAE:  BSF    x82.0
....................       y = -y; 
0AB0:  MOVF   x79,W
0AB2:  XORLW  80
0AB4:  MOVWF  x79
....................    } 
....................  
....................    if (y <= 32768.0) 
0AB6:  MOVFF  7B,86
0ABA:  MOVFF  7A,85
0ABE:  MOVFF  79,84
0AC2:  MOVFF  78,83
0AC6:  CLRF   x8A
0AC8:  CLRF   x89
0ACA:  CLRF   x88
0ACC:  MOVLW  8E
0ACE:  MOVWF  x87
0AD0:  RCALL  064A
0AD2:  BC    0AD6
0AD4:  BNZ   0B06
....................       res = (float32)(unsigned int16)y; 
0AD6:  MOVFF  7B,86
0ADA:  MOVFF  7A,85
0ADE:  MOVFF  79,84
0AE2:  MOVFF  78,83
0AE6:  RCALL  0A48
0AE8:  MOVFF  02,88
0AEC:  MOVFF  01,87
0AF0:  CALL   015E
0AF4:  MOVFF  03,7F
0AF8:  MOVFF  02,7E
0AFC:  MOVFF  01,7D
0B00:  MOVFF  00,7C
0B04:  BRA    0C90
....................  
....................  else if (y < 10000000.0) 
0B06:  MOVFF  7B,86
0B0A:  MOVFF  7A,85
0B0E:  MOVFF  79,84
0B12:  MOVFF  78,83
0B16:  MOVLW  80
0B18:  MOVWF  x8A
0B1A:  MOVLW  96
0B1C:  MOVWF  x89
0B1E:  MOVLW  18
0B20:  MOVWF  x88
0B22:  MOVLW  96
0B24:  MOVWF  x87
0B26:  RCALL  064A
0B28:  BTFSS  FD8.0
0B2A:  BRA    0C80
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
0B2C:  MOVFF  7B,86
0B30:  MOVFF  7A,85
0B34:  MOVFF  79,84
0B38:  MOVFF  78,83
0B3C:  CLRF   x8A
0B3E:  CLRF   x89
0B40:  CLRF   x88
0B42:  MOVLW  70
0B44:  MOVWF  x87
0B46:  CALL   0194
0B4A:  MOVFF  03,86
0B4E:  MOVFF  02,85
0B52:  MOVFF  01,84
0B56:  MOVFF  00,83
0B5A:  RCALL  0A48
0B5C:  MOVFF  02,81
0B60:  MOVFF  01,80
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
0B64:  MOVFF  7B,86
0B68:  MOVFF  7A,85
0B6C:  MOVFF  79,84
0B70:  MOVFF  78,83
0B74:  CLRF   x8A
0B76:  CLRF   x89
0B78:  CLRF   x88
0B7A:  MOVLW  70
0B7C:  MOVWF  x87
0B7E:  CALL   0194
0B82:  MOVFF  03,86
0B86:  MOVFF  02,85
0B8A:  MOVFF  01,84
0B8E:  MOVFF  00,83
0B92:  MOVFF  81,88
0B96:  MOVFF  80,87
0B9A:  CALL   015E
0B9E:  BSF    FD8.1
0BA0:  MOVFF  86,8A
0BA4:  MOVFF  85,89
0BA8:  MOVFF  84,88
0BAC:  MOVFF  83,87
0BB0:  MOVFF  03,8E
0BB4:  MOVFF  02,8D
0BB8:  MOVFF  01,8C
0BBC:  MOVFF  00,8B
0BC0:  RCALL  03E0
0BC2:  CLRF   x86
0BC4:  CLRF   x85
0BC6:  CLRF   x84
0BC8:  MOVLW  8E
0BCA:  MOVWF  x83
0BCC:  MOVFF  03,8A
0BD0:  MOVFF  02,89
0BD4:  MOVFF  01,88
0BD8:  MOVFF  00,87
0BDC:  CALL   0194
0BE0:  MOVFF  03,7B
0BE4:  MOVFF  02,7A
0BE8:  MOVFF  01,79
0BEC:  MOVFF  00,78
....................       res = 32768.0*(float32)l; 
0BF0:  MOVFF  81,88
0BF4:  MOVFF  80,87
0BF8:  CALL   015E
0BFC:  CLRF   x86
0BFE:  CLRF   x85
0C00:  CLRF   x84
0C02:  MOVLW  8E
0C04:  MOVWF  x83
0C06:  MOVFF  03,8A
0C0A:  MOVFF  02,89
0C0E:  MOVFF  01,88
0C12:  MOVFF  00,87
0C16:  CALL   0194
0C1A:  MOVFF  03,7F
0C1E:  MOVFF  02,7E
0C22:  MOVFF  01,7D
0C26:  MOVFF  00,7C
....................       res += (float32)(unsigned int16)y; 
0C2A:  MOVFF  7B,86
0C2E:  MOVFF  7A,85
0C32:  MOVFF  79,84
0C36:  MOVFF  78,83
0C3A:  RCALL  0A48
0C3C:  MOVFF  02,88
0C40:  MOVFF  01,87
0C44:  CALL   015E
0C48:  BCF    FD8.1
0C4A:  MOVFF  7F,8A
0C4E:  MOVFF  7E,89
0C52:  MOVFF  7D,88
0C56:  MOVFF  7C,87
0C5A:  MOVFF  03,8E
0C5E:  MOVFF  02,8D
0C62:  MOVFF  01,8C
0C66:  MOVFF  00,8B
0C6A:  CALL   03E0
0C6E:  MOVFF  03,7F
0C72:  MOVFF  02,7E
0C76:  MOVFF  01,7D
0C7A:  MOVFF  00,7C
....................    } 
0C7E:  BRA    0C90
....................  
....................  else 
....................   res = y; 
0C80:  MOVFF  7B,7F
0C84:  MOVFF  7A,7E
0C88:  MOVFF  79,7D
0C8C:  MOVFF  78,7C
....................  
....................  y = y - (float32)(unsigned int16)y; 
0C90:  MOVFF  7B,86
0C94:  MOVFF  7A,85
0C98:  MOVFF  79,84
0C9C:  MOVFF  78,83
0CA0:  RCALL  0A48
0CA2:  MOVFF  02,88
0CA6:  MOVFF  01,87
0CAA:  CALL   015E
0CAE:  BSF    FD8.1
0CB0:  MOVFF  7B,8A
0CB4:  MOVFF  7A,89
0CB8:  MOVFF  79,88
0CBC:  MOVFF  78,87
0CC0:  MOVFF  03,8E
0CC4:  MOVFF  02,8D
0CC8:  MOVFF  01,8C
0CCC:  MOVFF  00,8B
0CD0:  CALL   03E0
0CD4:  MOVFF  03,7B
0CD8:  MOVFF  02,7A
0CDC:  MOVFF  01,79
0CE0:  MOVFF  00,78
....................  
....................  if (s) 
0CE4:  BTFSS  x82.0
0CE6:  BRA    0CEE
....................   res = -res; 
0CE8:  MOVF   x7D,W
0CEA:  XORLW  80
0CEC:  MOVWF  x7D
....................  
....................  if (y != 0) 
0CEE:  MOVFF  7B,86
0CF2:  MOVFF  7A,85
0CF6:  MOVFF  79,84
0CFA:  MOVFF  78,83
0CFE:  CLRF   x8A
0D00:  CLRF   x89
0D02:  CLRF   x88
0D04:  CLRF   x87
0D06:  RCALL  064A
0D08:  BZ    0D7A
....................  { 
....................   if (s == 1 && n == 0) 
0D0A:  BTFSS  x82.0
0D0C:  BRA    0D42
0D0E:  MOVF   x77,F
0D10:  BNZ   0D42
....................    res -= 1.0; 
0D12:  BSF    FD8.1
0D14:  MOVFF  7F,8A
0D18:  MOVFF  7E,89
0D1C:  MOVFF  7D,88
0D20:  MOVFF  7C,87
0D24:  CLRF   x8E
0D26:  CLRF   x8D
0D28:  CLRF   x8C
0D2A:  MOVLW  7F
0D2C:  MOVWF  x8B
0D2E:  CALL   03E0
0D32:  MOVFF  03,7F
0D36:  MOVFF  02,7E
0D3A:  MOVFF  01,7D
0D3E:  MOVFF  00,7C
....................  
....................   if (s == 0 && n == 1) 
0D42:  BTFSC  x82.0
0D44:  BRA    0D7A
0D46:  DECFSZ x77,W
0D48:  BRA    0D7A
....................    res += 1.0; 
0D4A:  BCF    FD8.1
0D4C:  MOVFF  7F,8A
0D50:  MOVFF  7E,89
0D54:  MOVFF  7D,88
0D58:  MOVFF  7C,87
0D5C:  CLRF   x8E
0D5E:  CLRF   x8D
0D60:  CLRF   x8C
0D62:  MOVLW  7F
0D64:  MOVWF  x8B
0D66:  CALL   03E0
0D6A:  MOVFF  03,7F
0D6E:  MOVFF  02,7E
0D72:  MOVFF  01,7D
0D76:  MOVFF  00,7C
....................  } 
....................  if (x == 0) 
0D7A:  MOVFF  76,86
0D7E:  MOVFF  75,85
0D82:  MOVFF  74,84
0D86:  MOVFF  73,83
0D8A:  CLRF   x8A
0D8C:  CLRF   x89
0D8E:  CLRF   x88
0D90:  CLRF   x87
0D92:  RCALL  064A
0D94:  BNZ   0D9E
....................     res = 0; 
0D96:  CLRF   x7F
0D98:  CLRF   x7E
0D9A:  CLRF   x7D
0D9C:  CLRF   x7C
....................  
....................  return (res); 
0D9E:  MOVFF  7C,00
0DA2:  MOVFF  7D,01
0DA6:  MOVFF  7E,02
0DAA:  MOVFF  7F,03
0DAE:  RETURN 0
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
*
0DCA:  MOVFF  72,76
0DCE:  MOVFF  71,75
0DD2:  MOVFF  70,74
0DD6:  MOVFF  6F,73
0DDA:  CLRF   x77
0DDC:  RCALL  0A80
0DDE:  GOTO   0EE0 (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
0DB0:  MOVFF  72,76
0DB4:  MOVFF  71,75
0DB8:  MOVFF  70,74
0DBC:  MOVFF  6F,73
0DC0:  MOVLW  01
0DC2:  MOVWF  x77
0DC4:  RCALL  0A80
0DC6:  GOTO   0E98 (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
*
0DE2:  MOVFF  66,86
0DE6:  MOVFF  65,85
0DEA:  MOVFF  64,84
0DEE:  MOVFF  63,83
0DF2:  CLRF   x8A
0DF4:  CLRF   x89
0DF6:  CLRF   x88
0DF8:  CLRF   x87
0DFA:  RCALL  064A
0DFC:  BTFSC  FD8.2
0DFE:  BRA    0F3C
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
0E00:  MOVFF  62,7F
0E04:  MOVFF  61,7E
0E08:  MOVFF  60,7D
0E0C:  MOVFF  5F,7C
0E10:  MOVFF  66,83
0E14:  MOVFF  65,82
0E18:  MOVFF  64,81
0E1C:  MOVFF  63,80
0E20:  CALL   0286
0E24:  MOVFF  03,6E
0E28:  MOVFF  02,6D
0E2C:  MOVFF  01,6C
0E30:  MOVFF  00,6B
0E34:  MOVFF  03,86
0E38:  MOVFF  02,85
0E3C:  MOVFF  01,84
0E40:  MOVFF  00,83
0E44:  CLRF   x8A
0E46:  CLRF   x89
0E48:  CLRF   x88
0E4A:  CLRF   x87
0E4C:  CALL   064A
0E50:  BNC   0E9A
0E52:  MOVFF  62,7F
0E56:  MOVFF  61,7E
0E5A:  MOVFF  60,7D
0E5E:  MOVFF  5F,7C
0E62:  MOVFF  66,83
0E66:  MOVFF  65,82
0E6A:  MOVFF  64,81
0E6E:  MOVFF  63,80
0E72:  CALL   0286
0E76:  MOVFF  03,6E
0E7A:  MOVFF  02,6D
0E7E:  MOVFF  01,6C
0E82:  MOVFF  00,6B
0E86:  MOVFF  03,72
0E8A:  MOVFF  02,71
0E8E:  MOVFF  01,70
0E92:  MOVFF  00,6F
0E96:  BRA    0DB0
0E98:  BRA    0EE0
0E9A:  MOVFF  62,7F
0E9E:  MOVFF  61,7E
0EA2:  MOVFF  60,7D
0EA6:  MOVFF  5F,7C
0EAA:  MOVFF  66,83
0EAE:  MOVFF  65,82
0EB2:  MOVFF  64,81
0EB6:  MOVFF  63,80
0EBA:  CALL   0286
0EBE:  MOVFF  03,6E
0EC2:  MOVFF  02,6D
0EC6:  MOVFF  01,6C
0ECA:  MOVFF  00,6B
0ECE:  MOVFF  03,72
0ED2:  MOVFF  02,71
0ED6:  MOVFF  01,70
0EDA:  MOVFF  00,6F
0EDE:  BRA    0DCA
0EE0:  MOVFF  03,6A
0EE4:  MOVFF  02,69
0EE8:  MOVFF  01,68
0EEC:  MOVFF  00,67
....................       return(x-(i*y)); 
0EF0:  MOVFF  6A,86
0EF4:  MOVFF  69,85
0EF8:  MOVFF  68,84
0EFC:  MOVFF  67,83
0F00:  MOVFF  66,8A
0F04:  MOVFF  65,89
0F08:  MOVFF  64,88
0F0C:  MOVFF  63,87
0F10:  CALL   0194
0F14:  BSF    FD8.1
0F16:  MOVFF  62,8A
0F1A:  MOVFF  61,89
0F1E:  MOVFF  60,88
0F22:  MOVFF  5F,87
0F26:  MOVFF  03,8E
0F2A:  MOVFF  02,8D
0F2E:  MOVFF  01,8C
0F32:  MOVFF  00,8B
0F36:  CALL   03E0
0F3A:  BRA    0F3C
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
0F3C:  RETURN 0
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
0F3E:  MOVFF  66,86
0F42:  MOVFF  65,85
0F46:  MOVFF  64,84
0F4A:  MOVFF  63,83
0F4E:  MOVLW  3B
0F50:  MOVWF  x8A
0F52:  MOVLW  AA
0F54:  MOVWF  x89
0F56:  MOVLW  38
0F58:  MOVWF  x88
0F5A:  MOVLW  7F
0F5C:  MOVWF  x87
0F5E:  CALL   0194
0F62:  MOVFF  03,86
0F66:  MOVFF  02,85
0F6A:  MOVFF  01,84
0F6E:  MOVFF  00,83
0F72:  RCALL  0A48
0F74:  MOVFF  01,73
....................    s = 0; 
0F78:  BCF    x74.0
....................    y = x; 
0F7A:  MOVFF  66,6A
0F7E:  MOVFF  65,69
0F82:  MOVFF  64,68
0F86:  MOVFF  63,67
....................  
....................    if (x < 0) 
0F8A:  MOVFF  66,86
0F8E:  MOVFF  65,85
0F92:  MOVFF  64,84
0F96:  MOVFF  63,83
0F9A:  CLRF   x8A
0F9C:  CLRF   x89
0F9E:  CLRF   x88
0FA0:  CLRF   x87
0FA2:  CALL   064A
0FA6:  BNC   0FB2
....................    { 
....................       s = 1; 
0FA8:  BSF    x74.0
....................       n = -n; 
0FAA:  NEGF   x73
....................       y = -y; 
0FAC:  MOVF   x68,W
0FAE:  XORLW  80
0FB0:  MOVWF  x68
....................    } 
....................  
....................    res = 0.0; 
0FB2:  CLRF   x6E
0FB4:  CLRF   x6D
0FB6:  CLRF   x6C
0FB8:  CLRF   x6B
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
0FBA:  CLRF   x76
0FBC:  MOVLW  6B
0FBE:  MOVWF  FE9
0FC0:  MOVFF  76,FEA
0FC4:  MOVLW  7F
0FC6:  ADDWF  x73,W
0FC8:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
0FCA:  MOVFF  6A,86
0FCE:  MOVFF  69,85
0FD2:  MOVFF  68,84
0FD6:  MOVFF  67,83
0FDA:  MOVLW  3B
0FDC:  MOVWF  x8A
0FDE:  MOVLW  AA
0FE0:  MOVWF  x89
0FE2:  MOVLW  38
0FE4:  MOVWF  x88
0FE6:  MOVLW  7F
0FE8:  MOVWF  x87
0FEA:  CALL   0194
0FEE:  MOVFF  03,78
0FF2:  MOVFF  02,77
0FF6:  MOVFF  01,76
0FFA:  MOVFF  00,75
0FFE:  CLRF   x7A
1000:  MOVFF  73,79
1004:  BTFSC  x79.7
1006:  DECF   x7A,F
1008:  CALL   06C0
100C:  BSF    FD8.1
100E:  MOVFF  78,8A
1012:  MOVFF  77,89
1016:  MOVFF  76,88
101A:  MOVFF  75,87
101E:  MOVFF  03,8E
1022:  MOVFF  02,8D
1026:  MOVFF  01,8C
102A:  MOVFF  00,8B
102E:  CALL   03E0
1032:  MOVFF  03,6A
1036:  MOVFF  02,69
103A:  MOVFF  01,68
103E:  MOVFF  00,67
....................  
....................    r = pe[0]*y + pe[1]; 
1042:  MOVLW  7C
1044:  MOVWF  x86
1046:  MOVLW  88
1048:  MOVWF  x85
104A:  MOVLW  59
104C:  MOVWF  x84
104E:  MOVLW  72
1050:  MOVWF  x83
1052:  MOVFF  6A,8A
1056:  MOVFF  69,89
105A:  MOVFF  68,88
105E:  MOVFF  67,87
1062:  CALL   0194
1066:  MOVFF  03,78
106A:  MOVFF  02,77
106E:  MOVFF  01,76
1072:  MOVFF  00,75
1076:  BCF    FD8.1
1078:  MOVFF  03,8A
107C:  MOVFF  02,89
1080:  MOVFF  01,88
1084:  MOVFF  00,87
1088:  MOVLW  E0
108A:  MOVWF  x8E
108C:  MOVLW  97
108E:  MOVWF  x8D
1090:  MOVLW  26
1092:  MOVWF  x8C
1094:  MOVLW  75
1096:  MOVWF  x8B
1098:  CALL   03E0
109C:  MOVFF  03,72
10A0:  MOVFF  02,71
10A4:  MOVFF  01,70
10A8:  MOVFF  00,6F
....................    r = r*y + pe[2]; 
10AC:  MOVFF  72,86
10B0:  MOVFF  71,85
10B4:  MOVFF  70,84
10B8:  MOVFF  6F,83
10BC:  MOVFF  6A,8A
10C0:  MOVFF  69,89
10C4:  MOVFF  68,88
10C8:  MOVFF  67,87
10CC:  CALL   0194
10D0:  MOVFF  03,78
10D4:  MOVFF  02,77
10D8:  MOVFF  01,76
10DC:  MOVFF  00,75
10E0:  BCF    FD8.1
10E2:  MOVFF  03,8A
10E6:  MOVFF  02,89
10EA:  MOVFF  01,88
10EE:  MOVFF  00,87
10F2:  MOVLW  C4
10F4:  MOVWF  x8E
10F6:  MOVLW  1D
10F8:  MOVWF  x8D
10FA:  MOVLW  1E
10FC:  MOVWF  x8C
10FE:  MOVLW  78
1100:  MOVWF  x8B
1102:  CALL   03E0
1106:  MOVFF  03,72
110A:  MOVFF  02,71
110E:  MOVFF  01,70
1112:  MOVFF  00,6F
....................    r = r*y + pe[3]; 
1116:  MOVFF  72,86
111A:  MOVFF  71,85
111E:  MOVFF  70,84
1122:  MOVFF  6F,83
1126:  MOVFF  6A,8A
112A:  MOVFF  69,89
112E:  MOVFF  68,88
1132:  MOVFF  67,87
1136:  CALL   0194
113A:  MOVFF  03,78
113E:  MOVFF  02,77
1142:  MOVFF  01,76
1146:  MOVFF  00,75
114A:  BCF    FD8.1
114C:  MOVFF  03,8A
1150:  MOVFF  02,89
1154:  MOVFF  01,88
1158:  MOVFF  00,87
115C:  MOVLW  5E
115E:  MOVWF  x8E
1160:  MOVLW  50
1162:  MOVWF  x8D
1164:  MOVLW  63
1166:  MOVWF  x8C
1168:  MOVLW  7A
116A:  MOVWF  x8B
116C:  CALL   03E0
1170:  MOVFF  03,72
1174:  MOVFF  02,71
1178:  MOVFF  01,70
117C:  MOVFF  00,6F
....................    r = r*y + pe[4]; 
1180:  MOVFF  72,86
1184:  MOVFF  71,85
1188:  MOVFF  70,84
118C:  MOVFF  6F,83
1190:  MOVFF  6A,8A
1194:  MOVFF  69,89
1198:  MOVFF  68,88
119C:  MOVFF  67,87
11A0:  CALL   0194
11A4:  MOVFF  03,78
11A8:  MOVFF  02,77
11AC:  MOVFF  01,76
11B0:  MOVFF  00,75
11B4:  BCF    FD8.1
11B6:  MOVFF  03,8A
11BA:  MOVFF  02,89
11BE:  MOVFF  01,88
11C2:  MOVFF  00,87
11C6:  MOVLW  1A
11C8:  MOVWF  x8E
11CA:  MOVLW  FE
11CC:  MOVWF  x8D
11CE:  MOVLW  75
11D0:  MOVWF  x8C
11D2:  MOVLW  7C
11D4:  MOVWF  x8B
11D6:  CALL   03E0
11DA:  MOVFF  03,72
11DE:  MOVFF  02,71
11E2:  MOVFF  01,70
11E6:  MOVFF  00,6F
....................    r = r*y + pe[5]; 
11EA:  MOVFF  72,86
11EE:  MOVFF  71,85
11F2:  MOVFF  70,84
11F6:  MOVFF  6F,83
11FA:  MOVFF  6A,8A
11FE:  MOVFF  69,89
1202:  MOVFF  68,88
1206:  MOVFF  67,87
120A:  CALL   0194
120E:  MOVFF  03,78
1212:  MOVFF  02,77
1216:  MOVFF  01,76
121A:  MOVFF  00,75
121E:  BCF    FD8.1
1220:  MOVFF  03,8A
1224:  MOVFF  02,89
1228:  MOVFF  01,88
122C:  MOVFF  00,87
1230:  MOVLW  18
1232:  MOVWF  x8E
1234:  MOVLW  72
1236:  MOVWF  x8D
1238:  MOVLW  31
123A:  MOVWF  x8C
123C:  MOVLW  7E
123E:  MOVWF  x8B
1240:  CALL   03E0
1244:  MOVFF  03,72
1248:  MOVFF  02,71
124C:  MOVFF  01,70
1250:  MOVFF  00,6F
....................  
....................    res = res*(1.0 + y*r); 
1254:  MOVFF  6A,86
1258:  MOVFF  69,85
125C:  MOVFF  68,84
1260:  MOVFF  67,83
1264:  MOVFF  72,8A
1268:  MOVFF  71,89
126C:  MOVFF  70,88
1270:  MOVFF  6F,87
1274:  CALL   0194
1278:  BCF    FD8.1
127A:  CLRF   x8A
127C:  CLRF   x89
127E:  CLRF   x88
1280:  MOVLW  7F
1282:  MOVWF  x87
1284:  MOVFF  03,8E
1288:  MOVFF  02,8D
128C:  MOVFF  01,8C
1290:  MOVFF  00,8B
1294:  CALL   03E0
1298:  MOVFF  6E,86
129C:  MOVFF  6D,85
12A0:  MOVFF  6C,84
12A4:  MOVFF  6B,83
12A8:  MOVFF  03,8A
12AC:  MOVFF  02,89
12B0:  MOVFF  01,88
12B4:  MOVFF  00,87
12B8:  CALL   0194
12BC:  MOVFF  03,6E
12C0:  MOVFF  02,6D
12C4:  MOVFF  01,6C
12C8:  MOVFF  00,6B
....................  
....................    if (s) 
12CC:  BTFSS  x74.0
12CE:  BRA    12FE
....................       res = 1.0/res; 
12D0:  CLRF   x7F
12D2:  CLRF   x7E
12D4:  CLRF   x7D
12D6:  MOVLW  7F
12D8:  MOVWF  x7C
12DA:  MOVFF  6E,83
12DE:  MOVFF  6D,82
12E2:  MOVFF  6C,81
12E6:  MOVFF  6B,80
12EA:  CALL   0286
12EE:  MOVFF  03,6E
12F2:  MOVFF  02,6D
12F6:  MOVFF  01,6C
12FA:  MOVFF  00,6B
....................    return(res); 
12FE:  MOVFF  6B,00
1302:  MOVFF  6C,01
1306:  MOVFF  6D,02
130A:  MOVFF  6E,03
130E:  RETURN 0
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
*
0708:  MOVFF  66,6A
070C:  MOVFF  65,69
0710:  MOVFF  64,68
0714:  MOVFF  63,67
....................  
....................    if (y != 1.0) 
0718:  MOVFF  6A,86
071C:  MOVFF  69,85
0720:  MOVFF  68,84
0724:  MOVFF  67,83
0728:  CLRF   x8A
072A:  CLRF   x89
072C:  CLRF   x88
072E:  MOVLW  7F
0730:  MOVWF  x87
0732:  RCALL  064A
0734:  BTFSC  FD8.2
0736:  BRA    0A2E
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
0738:  CLRF   x79
073A:  MOVLW  67
073C:  MOVWF  FE9
073E:  MOVFF  79,FEA
0742:  MOVLW  7E
0744:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
0746:  BSF    FD8.1
0748:  MOVFF  6A,8A
074C:  MOVFF  69,89
0750:  MOVFF  68,88
0754:  MOVFF  67,87
0758:  CLRF   x8E
075A:  CLRF   x8D
075C:  CLRF   x8C
075E:  MOVLW  7F
0760:  MOVWF  x8B
0762:  RCALL  03E0
0764:  MOVFF  03,7B
0768:  MOVFF  02,7A
076C:  MOVFF  01,79
0770:  MOVFF  00,78
0774:  BCF    FD8.1
0776:  MOVFF  6A,8A
077A:  MOVFF  69,89
077E:  MOVFF  68,88
0782:  MOVFF  67,87
0786:  CLRF   x8E
0788:  CLRF   x8D
078A:  CLRF   x8C
078C:  MOVLW  7F
078E:  MOVWF  x8B
0790:  RCALL  03E0
0792:  MOVFF  7B,7F
0796:  MOVFF  7A,7E
079A:  MOVFF  79,7D
079E:  MOVFF  78,7C
07A2:  MOVFF  03,83
07A6:  MOVFF  02,82
07AA:  MOVFF  01,81
07AE:  MOVFF  00,80
07B2:  RCALL  0286
07B4:  MOVFF  03,6A
07B8:  MOVFF  02,69
07BC:  MOVFF  01,68
07C0:  MOVFF  00,67
....................  
....................       y2=y*y; 
07C4:  MOVFF  6A,86
07C8:  MOVFF  69,85
07CC:  MOVFF  68,84
07D0:  MOVFF  67,83
07D4:  MOVFF  6A,8A
07D8:  MOVFF  69,89
07DC:  MOVFF  68,88
07E0:  MOVFF  67,87
07E4:  RCALL  0194
07E6:  MOVFF  03,76
07EA:  MOVFF  02,75
07EE:  MOVFF  01,74
07F2:  MOVFF  00,73
....................  
....................       res = pl[0]*y2 + pl[1]; 
07F6:  MOVLW  99
07F8:  MOVWF  x86
07FA:  MOVLW  47
07FC:  MOVWF  x85
07FE:  MOVLW  8A
0800:  MOVWF  x84
0802:  MOVLW  7F
0804:  MOVWF  x83
0806:  MOVFF  76,8A
080A:  MOVFF  75,89
080E:  MOVFF  74,88
0812:  MOVFF  73,87
0816:  RCALL  0194
0818:  MOVFF  03,7B
081C:  MOVFF  02,7A
0820:  MOVFF  01,79
0824:  MOVFF  00,78
0828:  BCF    FD8.1
082A:  MOVFF  03,8A
082E:  MOVFF  02,89
0832:  MOVFF  01,88
0836:  MOVFF  00,87
083A:  CLRF   x8E
083C:  CLRF   x8D
083E:  CLRF   x8C
0840:  MOVLW  80
0842:  MOVWF  x8B
0844:  RCALL  03E0
0846:  MOVFF  03,6E
084A:  MOVFF  02,6D
084E:  MOVFF  01,6C
0852:  MOVFF  00,6B
....................  
....................       r = ql[0]*y2 + ql[1]; 
0856:  MOVLW  4C
0858:  MOVWF  x86
085A:  MOVLW  F3
085C:  MOVWF  x85
085E:  MOVLW  3A
0860:  MOVWF  x84
0862:  MOVLW  7B
0864:  MOVWF  x83
0866:  MOVFF  76,8A
086A:  MOVFF  75,89
086E:  MOVFF  74,88
0872:  MOVFF  73,87
0876:  RCALL  0194
0878:  MOVFF  03,7B
087C:  MOVFF  02,7A
0880:  MOVFF  01,79
0884:  MOVFF  00,78
0888:  BCF    FD8.1
088A:  MOVFF  03,8A
088E:  MOVFF  02,89
0892:  MOVFF  01,88
0896:  MOVFF  00,87
089A:  MOVLW  2B
089C:  MOVWF  x8E
089E:  MOVLW  9D
08A0:  MOVWF  x8D
08A2:  MOVLW  DF
08A4:  MOVWF  x8C
08A6:  MOVLW  7E
08A8:  MOVWF  x8B
08AA:  RCALL  03E0
08AC:  MOVFF  03,72
08B0:  MOVFF  02,71
08B4:  MOVFF  01,70
08B8:  MOVFF  00,6F
....................       r = r*y2 + 1.0; 
08BC:  MOVFF  72,86
08C0:  MOVFF  71,85
08C4:  MOVFF  70,84
08C8:  MOVFF  6F,83
08CC:  MOVFF  76,8A
08D0:  MOVFF  75,89
08D4:  MOVFF  74,88
08D8:  MOVFF  73,87
08DC:  RCALL  0194
08DE:  MOVFF  03,7B
08E2:  MOVFF  02,7A
08E6:  MOVFF  01,79
08EA:  MOVFF  00,78
08EE:  BCF    FD8.1
08F0:  MOVFF  03,8A
08F4:  MOVFF  02,89
08F8:  MOVFF  01,88
08FC:  MOVFF  00,87
0900:  CLRF   x8E
0902:  CLRF   x8D
0904:  CLRF   x8C
0906:  MOVLW  7F
0908:  MOVWF  x8B
090A:  RCALL  03E0
090C:  MOVFF  03,72
0910:  MOVFF  02,71
0914:  MOVFF  01,70
0918:  MOVFF  00,6F
....................  
....................       res = y*res/r; 
091C:  MOVFF  6A,86
0920:  MOVFF  69,85
0924:  MOVFF  68,84
0928:  MOVFF  67,83
092C:  MOVFF  6E,8A
0930:  MOVFF  6D,89
0934:  MOVFF  6C,88
0938:  MOVFF  6B,87
093C:  RCALL  0194
093E:  MOVFF  03,7B
0942:  MOVFF  02,7A
0946:  MOVFF  01,79
094A:  MOVFF  00,78
094E:  MOVFF  03,7F
0952:  MOVFF  02,7E
0956:  MOVFF  01,7D
095A:  MOVFF  00,7C
095E:  MOVFF  72,83
0962:  MOVFF  71,82
0966:  MOVFF  70,81
096A:  MOVFF  6F,80
096E:  RCALL  0286
0970:  MOVFF  03,6E
0974:  MOVFF  02,6D
0978:  MOVFF  01,6C
097C:  MOVFF  00,6B
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
0980:  CLRF   x79
0982:  MOVLW  63
0984:  MOVWF  FE9
0986:  MOVFF  79,FEA
098A:  MOVLW  7E
098C:  SUBWF  FEF,W
098E:  MOVWF  x77
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
0990:  BTFSS  x77.7
0992:  BRA    09B8
....................          r = -(float32)-n; 
0994:  MOVLW  00
0996:  BSF    FD8.0
0998:  SUBFWB x77,W
099A:  CLRF   x7A
099C:  MOVWF  x79
099E:  BTFSC  x79.7
09A0:  DECF   x7A,F
09A2:  RCALL  06C0
09A4:  MOVFF  00,6F
09A8:  MOVF   01,W
09AA:  XORLW  80
09AC:  MOVWF  x70
09AE:  MOVFF  02,71
09B2:  MOVFF  03,72
09B6:  BRA    09D4
....................       else 
....................          r = (float32)n; 
09B8:  CLRF   x7A
09BA:  MOVFF  77,79
09BE:  BTFSC  x79.7
09C0:  DECF   x7A,F
09C2:  RCALL  06C0
09C4:  MOVFF  03,72
09C8:  MOVFF  02,71
09CC:  MOVFF  01,70
09D0:  MOVFF  00,6F
....................  
....................       res += r*LN2; 
09D4:  MOVFF  72,86
09D8:  MOVFF  71,85
09DC:  MOVFF  70,84
09E0:  MOVFF  6F,83
09E4:  MOVLW  18
09E6:  MOVWF  x8A
09E8:  MOVLW  72
09EA:  MOVWF  x89
09EC:  MOVLW  31
09EE:  MOVWF  x88
09F0:  MOVLW  7E
09F2:  MOVWF  x87
09F4:  CALL   0194
09F8:  BCF    FD8.1
09FA:  MOVFF  6E,8A
09FE:  MOVFF  6D,89
0A02:  MOVFF  6C,88
0A06:  MOVFF  6B,87
0A0A:  MOVFF  03,8E
0A0E:  MOVFF  02,8D
0A12:  MOVFF  01,8C
0A16:  MOVFF  00,8B
0A1A:  RCALL  03E0
0A1C:  MOVFF  03,6E
0A20:  MOVFF  02,6D
0A24:  MOVFF  01,6C
0A28:  MOVFF  00,6B
....................    } 
0A2C:  BRA    0A36
....................  
....................    else 
....................       res = 0.0; 
0A2E:  CLRF   x6E
0A30:  CLRF   x6D
0A32:  CLRF   x6C
0A34:  CLRF   x6B
....................  
....................    return(res); 
0A36:  MOVFF  6B,00
0A3A:  MOVFF  6C,01
0A3E:  MOVFF  6D,02
0A42:  MOVFF  6E,03
0A46:  RETURN 0
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
*
1310:  MOVFF  5A,86
1314:  MOVFF  59,85
1318:  MOVFF  58,84
131C:  MOVFF  57,83
1320:  CLRF   x8A
1322:  CLRF   x89
1324:  CLRF   x88
1326:  CLRF   x87
1328:  CALL   064A
132C:  BTFSS  FD8.0
132E:  BRA    14C6
1330:  MOVFF  5E,62
1334:  MOVFF  5D,61
1338:  MOVFF  5C,60
133C:  MOVFF  5B,5F
1340:  CLRF   x66
1342:  CLRF   x65
1344:  CLRF   x64
1346:  MOVLW  7F
1348:  MOVWF  x63
134A:  RCALL  0DE2
134C:  MOVFF  03,62
1350:  MOVFF  02,61
1354:  MOVFF  01,60
1358:  MOVFF  00,5F
135C:  MOVFF  03,86
1360:  MOVFF  02,85
1364:  MOVFF  01,84
1368:  MOVFF  00,83
136C:  CLRF   x8A
136E:  CLRF   x89
1370:  CLRF   x88
1372:  CLRF   x87
1374:  CALL   064A
1378:  BTFSS  FD8.2
137A:  BRA    14C6
....................       if(fmod(y, 2) == 0) { 
137C:  MOVFF  5E,62
1380:  MOVFF  5D,61
1384:  MOVFF  5C,60
1388:  MOVFF  5B,5F
138C:  CLRF   x66
138E:  CLRF   x65
1390:  CLRF   x64
1392:  MOVLW  80
1394:  MOVWF  x63
1396:  RCALL  0DE2
1398:  MOVFF  03,62
139C:  MOVFF  02,61
13A0:  MOVFF  01,60
13A4:  MOVFF  00,5F
13A8:  MOVFF  03,86
13AC:  MOVFF  02,85
13B0:  MOVFF  01,84
13B4:  MOVFF  00,83
13B8:  CLRF   x8A
13BA:  CLRF   x89
13BC:  CLRF   x88
13BE:  CLRF   x87
13C0:  CALL   064A
13C4:  BNZ   1444
....................          return (exp(log(-x) * y)); 
13C6:  MOVFF  57,5F
13CA:  MOVF   58,W
13CC:  XORLW  80
13CE:  MOVWF  x60
13D0:  MOVFF  59,61
13D4:  MOVFF  5A,62
13D8:  MOVFF  5A,66
13DC:  MOVFF  59,65
13E0:  MOVWF  x64
13E2:  MOVFF  57,63
13E6:  CALL   0708
13EA:  MOVFF  03,62
13EE:  MOVFF  02,61
13F2:  MOVFF  01,60
13F6:  MOVFF  00,5F
13FA:  MOVFF  03,86
13FE:  MOVFF  02,85
1402:  MOVFF  01,84
1406:  MOVFF  00,83
140A:  MOVFF  5E,8A
140E:  MOVFF  5D,89
1412:  MOVFF  5C,88
1416:  MOVFF  5B,87
141A:  CALL   0194
141E:  MOVFF  03,62
1422:  MOVFF  02,61
1426:  MOVFF  01,60
142A:  MOVFF  00,5F
142E:  MOVFF  03,66
1432:  MOVFF  02,65
1436:  MOVFF  01,64
143A:  MOVFF  00,63
143E:  RCALL  0F3E
1440:  BRA    15E2
....................       } else { 
1442:  BRA    14C4
....................          return (-exp(log(-x) * y)); 
1444:  MOVFF  57,5F
1448:  MOVF   58,W
144A:  XORLW  80
144C:  MOVWF  x60
144E:  MOVFF  59,61
1452:  MOVFF  5A,62
1456:  MOVFF  5A,66
145A:  MOVFF  59,65
145E:  MOVWF  x64
1460:  MOVFF  57,63
1464:  CALL   0708
1468:  MOVFF  03,62
146C:  MOVFF  02,61
1470:  MOVFF  01,60
1474:  MOVFF  00,5F
1478:  MOVFF  03,86
147C:  MOVFF  02,85
1480:  MOVFF  01,84
1484:  MOVFF  00,83
1488:  MOVFF  5E,8A
148C:  MOVFF  5D,89
1490:  MOVFF  5C,88
1494:  MOVFF  5B,87
1498:  CALL   0194
149C:  MOVFF  03,62
14A0:  MOVFF  02,61
14A4:  MOVFF  01,60
14A8:  MOVFF  00,5F
14AC:  MOVFF  03,66
14B0:  MOVFF  02,65
14B4:  MOVFF  01,64
14B8:  MOVFF  00,63
14BC:  RCALL  0F3E
14BE:  MOVLW  80
14C0:  XORWF  01,F
14C2:  BRA    15E2
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
14C4:  BRA    15E2
14C6:  MOVFF  5A,86
14CA:  MOVFF  59,85
14CE:  MOVFF  58,84
14D2:  MOVFF  57,83
14D6:  CLRF   x8A
14D8:  CLRF   x89
14DA:  CLRF   x88
14DC:  CLRF   x87
14DE:  CALL   064A
14E2:  BNC   153A
14E4:  MOVFF  5E,62
14E8:  MOVFF  5D,61
14EC:  MOVFF  5C,60
14F0:  MOVFF  5B,5F
14F4:  CLRF   x66
14F6:  CLRF   x65
14F8:  CLRF   x64
14FA:  MOVLW  7F
14FC:  MOVWF  x63
14FE:  RCALL  0DE2
1500:  MOVFF  03,62
1504:  MOVFF  02,61
1508:  MOVFF  01,60
150C:  MOVFF  00,5F
1510:  MOVFF  03,86
1514:  MOVFF  02,85
1518:  MOVFF  01,84
151C:  MOVFF  00,83
1520:  CLRF   x8A
1522:  CLRF   x89
1524:  CLRF   x88
1526:  CLRF   x87
1528:  CALL   064A
152C:  BZ    153A
....................       return 0; 
152E:  CLRF   00
1530:  CLRF   01
1532:  CLRF   02
1534:  CLRF   03
1536:  BRA    15E2
....................    } else { 
1538:  BRA    15E2
....................       if(x != 0 || 0 >= y) { 
153A:  MOVFF  5A,86
153E:  MOVFF  59,85
1542:  MOVFF  58,84
1546:  MOVFF  57,83
154A:  CLRF   x8A
154C:  CLRF   x89
154E:  CLRF   x88
1550:  CLRF   x87
1552:  CALL   064A
1556:  BNZ   1578
1558:  MOVFF  5E,86
155C:  MOVFF  5D,85
1560:  MOVFF  5C,84
1564:  MOVFF  5B,83
1568:  CLRF   x8A
156A:  CLRF   x89
156C:  CLRF   x88
156E:  CLRF   x87
1570:  CALL   064A
1574:  BC    1578
1576:  BNZ   15E2
....................          return (exp(log(x) * y)); 
1578:  MOVFF  5A,66
157C:  MOVFF  59,65
1580:  MOVFF  58,64
1584:  MOVFF  57,63
1588:  CALL   0708
158C:  MOVFF  03,62
1590:  MOVFF  02,61
1594:  MOVFF  01,60
1598:  MOVFF  00,5F
159C:  MOVFF  03,86
15A0:  MOVFF  02,85
15A4:  MOVFF  01,84
15A8:  MOVFF  00,83
15AC:  MOVFF  5E,8A
15B0:  MOVFF  5D,89
15B4:  MOVFF  5C,88
15B8:  MOVFF  5B,87
15BC:  CALL   0194
15C0:  MOVFF  03,62
15C4:  MOVFF  02,61
15C8:  MOVFF  01,60
15CC:  MOVFF  00,5F
15D0:  MOVFF  03,66
15D4:  MOVFF  02,65
15D8:  MOVFF  01,64
15DC:  MOVFF  00,63
15E0:  RCALL  0F3E
....................       } 
....................    } 
15E2:  GOTO   178A (RETURN)
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #fuses HS,NOWDT,PUT,NOBROWNOUT,NOLVP   // configuração dos fuses do pic  
.................... #use   delay(clock=20000000)// Informa a função delay, o clock utilizado 
*
00F0:  CLRF   FEA
00F2:  MOVLW  59
00F4:  MOVWF  FE9
00F6:  MOVF   FEF,W
00F8:  BZ    0114
00FA:  MOVLW  06
00FC:  MOVWF  01
00FE:  CLRF   00
0100:  DECFSZ 00,F
0102:  BRA    0100
0104:  DECFSZ 01,F
0106:  BRA    00FE
0108:  MOVLW  7B
010A:  MOVWF  00
010C:  DECFSZ 00,F
010E:  BRA    010C
0110:  DECFSZ FEF,F
0112:  BRA    00FA
0114:  RETURN 0
*
1A9A:  MOVLW  03
1A9C:  SUBWF  59,F
1A9E:  BNC   1AB2
1AA0:  CLRF   FEA
1AA2:  MOVLW  59
1AA4:  MOVWF  FE9
1AA6:  MOVF   FEF,W
1AA8:  BZ    1AB2
1AAA:  BRA    1AAE
1AAC:  BRA    1AAE
1AAE:  DECFSZ FEF,F
1AB0:  BRA    1AAC
1AB2:  RETURN 0
....................  
.................... //#BIT Data_Pin_Direction = 0xf93.7             // Pin direction mapped to TRISB.7 
.................... #use   fast_io(a)//modo rápido de inicialização das portas 
.................... #use   fast_io(b)//modo rápido de inicialização das portas 
.................... #use   fast_io(d)//modo rápido de inicialização das portas 
.................... #use   fast_io(e)//modo rápido de inicialização das portas 
....................  
.................... #byte   porta = 0xf80 // atribui o nome "porta" ao registrador do port 0xf80 
.................... #byte   portb = 0xf81  
.................... #byte   portd = 0xf83 
.................... #byte   porte = 0xf84 
.................... #byte   portc = 0xf82 
.................... // pinos de entrada e saida  
.................... #bit NTC = porta.0    //  Pino de leitura do NTC  
.................... #bit PIN_COOLER = portc.0  //  Pino de leitura do DHT11 
.................... #bit POT_SET_TEMP = porta.1 //Pino de leitura do potenciometro de set da temperatura  
.................... #bit POT_SET_UMI = porta.2 //Pino de leitura do potenciometro de set da umidade  
.................... #bit BOT_BLK_LTH = portb.0 // Pino do botao paraligar a luz do lcd 
.................... #bit BOT_MORE_INF = portb.1 // botao para mais informaçoes no lcd 
.................... #BIT Data_Pin = portb.7                       // Pin mapped to PORTB.7 
.................... // pinos de saida 
.................... #bit PIN_SERV = portb.3 
.................... #bit RELE_LAMP = portb.2  //  pino que acionamento do relé da lampada/aquecedor 
.................... //#bit DHT11 = portb.7  
.................... #bit rs =porte.0 //  via do lcd que sinaliza recepção de dados ou comando  
.................... #bit enable = porte.1 // habilita o lcd 
.................... #byte DISPLAY = portd //  seleciona o port no qual o lcd esta ligado ( o mesmo valor que esta no arquivo.h) 
.................... #INCLUDE <lcd.h> // inclui a biblioteca do modulo lcd 
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *      Rotina que envia um COMANDO para o LCD                 * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void comando_lcd(int caracter) 
.................... { 
....................    rs = 0;               // seleciona o envio de um caracter 
*
00D4:  BCF    F84.0
....................    portd = caracter;         // carrega o portc com o caracter 
00D6:  MOVFF  58,F83
....................    enable = 1 ;            // gera pulso no enable 
00DA:  BSF    F84.1
....................    delay_us(1);            // espera 1 microsegundos 
00DC:  BRA    00DE
00DE:  BRA    00E0
00E0:  NOP   
....................    enable = 0;            // desce o pino de enable 
00E2:  BCF    F84.1
....................  
....................    delay_us(40);            // espera mínimo 40 microsegundos 
00E4:  MOVLW  42
00E6:  MOVWF  00
00E8:  DECFSZ 00,F
00EA:  BRA    00E8
00EC:  NOP   
....................     
....................    return;               // retorna 
00EE:  RETURN 0
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *      Rotina que envia um DADO a ser escrito no LCD              * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void escreve_lcd(int caracter) 
.................... { 
....................    rs = 1;               // seleciona o envio de um comando 
*
1A36:  BSF    F84.0
....................    portd = caracter;         // carrega o portc com o valor do comando 
1A38:  MOVFF  5A,F83
....................    enable = 1;            // gera pulso no enable 
1A3C:  BSF    F84.1
....................    delay_us(1);            // espera 3 microsegundos 
1A3E:  BRA    1A40
1A40:  BRA    1A42
1A42:  NOP   
....................    enable = 0;            // desce o pino de enable 
1A44:  BCF    F84.1
....................  
....................    delay_us(40);            // espera mínimo 40 microsegundos 
1A46:  MOVLW  42
1A48:  MOVWF  00
1A4A:  DECFSZ 00,F
1A4C:  BRA    1A4A
1A4E:  NOP   
....................     
....................    return;               // retorna 
1A50:  RETURN 0
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *              Função para limpar o LCD                 * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void limpa_lcd() 
.................... { 
....................    comando_lcd(0x01);         // limpa lcd    
*
0116:  MOVLW  01
0118:  MOVWF  58
011A:  RCALL  00D4
....................    delay_ms (2); 
011C:  MOVLW  02
011E:  MOVWF  59
0120:  RCALL  00F0
....................    return; 
0122:  RETURN 0
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *           Inicialização do Display de LCD                 * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void inicializa_lcd() 
.................... { 
....................    comando_lcd(0x30);         // envia comando para inicializar display 
0124:  MOVLW  30
0126:  MOVWF  58
0128:  RCALL  00D4
....................    delay_ms(4);            // espera 4 milisengundos 
012A:  MOVLW  04
012C:  MOVWF  59
012E:  RCALL  00F0
....................  
....................    comando_lcd(0x30);         // envia comando para inicializar display 
0130:  MOVLW  30
0132:  MOVWF  58
0134:  RCALL  00D4
....................    delay_us(100);            // espera 100 microsengundos 
0136:  MOVLW  A6
0138:  MOVWF  00
013A:  DECFSZ 00,F
013C:  BRA    013A
013E:  NOP   
....................  
....................    comando_lcd(0x30);         // envia comando para inicializar display 
0140:  MOVLW  30
0142:  MOVWF  58
0144:  RCALL  00D4
....................  
....................    comando_lcd(0x38);         // liga o display, sem cursor e sem blink 
0146:  MOVLW  38
0148:  MOVWF  58
014A:  RCALL  00D4
....................  
....................    limpa_lcd();            // limpa lcd 
014C:  RCALL  0116
....................  
....................    comando_lcd(0x0c);         // display sem cursor 
014E:  MOVLW  0C
0150:  MOVWF  58
0152:  RCALL  00D4
....................  
....................    comando_lcd(0x06);         // desloca cursor para a direita 
0154:  MOVLW  06
0156:  MOVWF  58
0158:  RCALL  00D4
....................  
....................    return;               // retorna 
015A:  GOTO   1C2E (RETURN)
.................... }    
....................  
....................  
....................  
.................... char message2[] = "RH   = 00.0 %"; //  vetor de mensagem para a umidade  
.................... short Time_out; //  variavel para as funçoes referentes ao sensor de umidade dht11 
.................... unsigned  int8 RH_byte1, RH_byte2, CheckSum; //  variaveis para as funçoes do dht11 
....................  
.................... float ntc_val = 0; // variavel responsavel por receber o valor digital do ntc 
.................... float rntc = 0; //  valor da resistencia do divisor de tensao do ntc  
.................... float b1=0;  //  variavel auxiliar para função do ntc 
.................... float c1=0;//  variavel auxiliar para função do ntc 
.................... float temp=0;//  variavel auxiliar para função do ntc 
.................... float temperatura=0;//  variavel auxiliar para função do ntc 
.................... char umidade;//  variavel auxiliar para função do ntc 
....................  double a = 0.0011303; //  constantes fisicas do sensor ntc 10k 
....................  double b = 0.0002339; //  constantes fisicas do sensor ntc 10k 
....................  double c = 0.00000008863; //  constantes fisicas do sensor ntc 10k 
.................... int cont=0; 
.................... long int cont_int = 0; 
.................... int horas=0; 
.................... #int_timer0 
.................... void trata_tmr0 () 
.................... { 
....................    set_timer0(131 + get_timer0()); 
*
0096:  MOVF   FD6,W
0098:  MOVFF  FD7,03
009C:  ADDLW  83
009E:  MOVWF  x97
00A0:  MOVLW  00
00A2:  ADDWFC FD7,W
00A4:  MOVWF  FD7
00A6:  MOVFF  97,FD6
....................    cont_int++; 
00AA:  INCF   54,F
00AC:  BTFSC  FD8.2
00AE:  INCF   55,F
....................    if(cont_int > 37440)  
00B0:  MOVF   55,W
00B2:  SUBLW  91
00B4:  BC    00C6
00B6:  XORLW  FF
00B8:  BNZ   00C0
00BA:  MOVF   54,W
00BC:  SUBLW  40
00BE:  BC    00C6
....................    { 
....................       cont_int = 0; 
00C0:  CLRF   55
00C2:  CLRF   54
....................       horas++;       
00C4:  INCF   56,F
....................    } 
....................     
....................   
00C6:  BCF    FF2.2
00C8:  GOTO   0054
.................... } 
....................  
....................  
....................  
.................... // FUNÇÃO POR INICIAR A DHT11 
....................  
.................... void start_signal(){ 
....................   set_tris_b(0b01000000);//Data_Pin_Direction = 0;              // Configure connection pin as output 
*
18B2:  MOVLW  40
18B4:  MOVWF  F93
....................   Data_Pin = 0;                        // Connection pin output low 
18B6:  BCF    F81.7
....................   delay_ms(25); 
18B8:  MOVLW  19
18BA:  MOVWF  59
18BC:  CALL   00F0
....................   Data_Pin = 1;                        // Connection pin output high 
18C0:  BSF    F81.7
....................   delay_us(30); 
18C2:  MOVLW  31
18C4:  MOVWF  00
18C6:  DECFSZ 00,F
18C8:  BRA    18C6
18CA:  BRA    18CC
....................   set_tris_b(0b11000000);//Data_Pin_Direction = 1;              // Configure connection pin as input 
18CC:  MOVLW  C0
18CE:  MOVWF  F93
18D0:  GOTO   19DA (RETURN)
.................... } 
....................  
.................... // FUNÇAÕ POR VERIFICAR SE O SENSOR ESTA RESPONDENDO  
....................  
....................   short check_response(){ 
....................   delay_us(40); 
18D4:  MOVLW  42
18D6:  MOVWF  00
18D8:  DECFSZ 00,F
18DA:  BRA    18D8
18DC:  NOP   
....................   if(!Data_Pin){                     // Read and test if connection pin is low 
18DE:  BTFSC  F81.7
18E0:  BRA    1902
....................     delay_us(80); 
18E2:  MOVLW  84
18E4:  MOVWF  00
18E6:  DECFSZ 00,F
18E8:  BRA    18E6
18EA:  BRA    18EC
18EC:  NOP   
....................     if(Data_Pin){                    // Read and test if connection pin is high 
18EE:  BTFSS  F81.7
18F0:  BRA    1902
....................       delay_us(50); 
18F2:  MOVLW  52
18F4:  MOVWF  00
18F6:  DECFSZ 00,F
18F8:  BRA    18F6
18FA:  BRA    18FC
18FC:  NOP   
....................       return 1;} 
18FE:  MOVLW  01
1900:  MOVWF  01
....................     } 
1902:  GOTO   19DC (RETURN)
.................... } 
....................  
....................  
.................... // FUNÇÃO PARA A OBTENÇÃO DO VALOR DE HUMIDADE 
.................... unsigned int8 Read_Data(){ 
1906:  CLRF   59
....................   unsigned int8 i, k, _data = 0;     // k is used to count 1 bit reading duration 
....................   if(Time_out) 
1908:  BTFSS  2A.0
190A:  BRA    190C
....................     break; 
....................   for(i = 0; i < 8; i++){ 
190C:  CLRF   57
190E:  MOVF   57,W
1910:  SUBLW  07
1912:  BNC   1998
....................     k = 0; 
1914:  CLRF   58
....................     while(!Data_Pin){                          // Wait until pin goes high 
1916:  BTFSC  F81.7
1918:  BRA    192E
....................       k++; 
191A:  INCF   58,F
....................       if (k > 100) {Time_out = 1; break;} 
191C:  MOVF   58,W
191E:  SUBLW  64
1920:  BC    1926
1922:  BSF    2A.0
1924:  BRA    192E
....................       delay_us(1);} 
1926:  BRA    1928
1928:  BRA    192A
192A:  NOP   
192C:  BRA    1916
....................     delay_us(30); 
192E:  MOVLW  31
1930:  MOVWF  00
1932:  DECFSZ 00,F
1934:  BRA    1932
1936:  BRA    1938
....................     if(!Data_Pin) 
1938:  BTFSC  F81.7
193A:  BRA    195E
....................       bit_clear(_data, (7 - i));               // Clear bit (7 - i) 
193C:  MOVLW  07
193E:  BSF    FD8.0
1940:  SUBFWB 57,W
1942:  MOVWF  5A
1944:  MOVLW  01
1946:  MOVWF  00
1948:  MOVF   5A,W
194A:  MOVWF  01
194C:  BZ    1956
194E:  BCF    FD8.0
1950:  RLCF   00,F
1952:  DECFSZ 01,F
1954:  BRA    194E
1956:  MOVF   00,W
1958:  XORLW  FF
195A:  ANDWF  59,F
195C:  BRA    1994
....................     else{ 
....................       bit_set(_data, (7 - i));                 // Set bit (7 - i) 
195E:  MOVLW  07
1960:  BSF    FD8.0
1962:  SUBFWB 57,W
1964:  MOVWF  5A
1966:  MOVLW  01
1968:  MOVWF  00
196A:  MOVF   5A,W
196C:  MOVWF  01
196E:  BZ    1978
1970:  BCF    FD8.0
1972:  RLCF   00,F
1974:  DECFSZ 01,F
1976:  BRA    1970
1978:  MOVF   00,W
197A:  IORWF  59,F
....................       while(Data_Pin){                         // Wait until pin goes low 
197C:  BTFSS  F81.7
197E:  BRA    1994
....................       k++; 
1980:  INCF   58,F
....................       if (k > 100) {Time_out = 1; break;} 
1982:  MOVF   58,W
1984:  SUBLW  64
1986:  BC    198C
1988:  BSF    2A.0
198A:  BRA    1994
....................       delay_us(1);} 
198C:  BRA    198E
198E:  BRA    1990
1990:  NOP   
1992:  BRA    197C
....................     } 
1994:  INCF   57,F
1996:  BRA    190E
....................   } 
....................   return _data; 
1998:  MOVFF  59,01
199C:  RETURN 0
.................... } 
....................  
.................... // FUNÇÃO PRINCIPAL QUE RETORNARA A UMIDADE  
....................  
.................... char dht11(){ 
....................    delay_ms(1000); 
*
19C6:  MOVLW  04
19C8:  MOVWF  57
19CA:  MOVLW  FA
19CC:  MOVWF  59
19CE:  CALL   00F0
19D2:  DECFSZ 57,F
19D4:  BRA    19CA
....................    Time_out = 0; 
19D6:  BCF    2A.0
....................    Start_signal(); 
19D8:  BRA    18B2
....................    if(check_response()){// If there is response from sensor 
19DA:  BRA    18D4
19DC:  MOVF   01,F
19DE:  BZ    1A2A
....................    RH_byte1=Read_Data();// read RH byte1 
19E0:  RCALL  1906
19E2:  MOVFF  01,2B
....................    RH_byte2=Read_Data();// read RH byte2 
19E6:  RCALL  1906
19E8:  MOVFF  01,2C
....................    Checksum=Read_Data();// read checksum                    
19EC:  RCALL  1906
19EE:  MOVFF  01,2D
....................       if(CheckSum==((RH_Byte1+RH_Byte2)& 0xFF)){ 
19F2:  MOVF   2C,W
19F4:  ADDWF  2B,W
19F6:  SUBWF  2D,W
19F8:  BNZ   1A2A
....................               message2[7]=RH_Byte1/10+48; 
19FA:  MOVFF  2B,57
19FE:  MOVLW  0A
1A00:  MOVWF  58
1A02:  RCALL  199E
1A04:  MOVLW  30
1A06:  ADDWF  01,W
1A08:  MOVWF  23
....................              message2[8]= RH_Byte1%10+48; 
1A0A:  MOVFF  2B,57
1A0E:  MOVLW  0A
1A10:  MOVWF  58
1A12:  RCALL  199E
1A14:  MOVLW  30
1A16:  ADDWF  00,W
1A18:  MOVWF  24
....................              message2[10] = RH_Byte2/10+48;   
1A1A:  MOVFF  2C,57
1A1E:  MOVLW  0A
1A20:  MOVWF  58
1A22:  RCALL  199E
1A24:  MOVLW  30
1A26:  ADDWF  01,W
1A28:  MOVWF  26
....................               
....................        } 
....................    }  
....................    return message2; 
1A2A:  MOVLW  1C
1A2C:  MOVWF  01
1A2E:  MOVLW  00
1A30:  MOVWF  02
1A32:  GOTO   1C52 (RETURN)
.................... } 
....................  
....................  
....................  
....................  
.................... float ntc(){ 
.................... set_adc_channel(0); //  escolhe o pino analogico para ler   
*
15E6:  MOVLW  00
15E8:  MOVWF  01
15EA:  MOVF   FC2,W
15EC:  ANDLW  C3
15EE:  IORWF  01,W
15F0:  MOVWF  FC2
.................... delay_us(10); // delay para começar a conversão 
15F2:  MOVLW  10
15F4:  MOVWF  00
15F6:  DECFSZ 00,F
15F8:  BRA    15F6
15FA:  NOP   
.................... read_adc(ADC_START_ONLY ); 
15FC:  BSF    FC2.1
.................... while(!adc_done()){ 
15FE:  BTFSS  FC2.1
1600:  BRA    1604
1602:  BRA    15FE
.................... } 
.................... ntc_val = read_adc(ADC_READ_ONLY ); // le o valor na porta analogica 
1604:  BTFSC  FC2.1
1606:  BRA    1604
1608:  MOVFF  FC4,03
160C:  MOVFF  FC3,87
1610:  MOVFF  FC4,88
1614:  CALL   015E
1618:  MOVFF  03,31
161C:  MOVFF  02,30
1620:  MOVFF  01,2F
1624:  MOVFF  00,2E
.................... ntc_val *=5; // multiplica o valor digitalizado pelo valor de tensão de alimentação 
1628:  MOVFF  31,86
162C:  MOVFF  30,85
1630:  MOVFF  2F,84
1634:  MOVFF  2E,83
1638:  CLRF   x8A
163A:  CLRF   x89
163C:  MOVLW  20
163E:  MOVWF  x88
1640:  MOVLW  81
1642:  MOVWF  x87
1644:  CALL   0194
1648:  MOVFF  03,31
164C:  MOVFF  02,30
1650:  MOVFF  01,2F
1654:  MOVFF  00,2E
.................... ntc_val/=1023;  // divide  o valor acima por 1023 
1658:  MOVFF  31,7F
165C:  MOVFF  30,7E
1660:  MOVFF  2F,7D
1664:  MOVFF  2E,7C
1668:  CLRF   x83
166A:  MOVLW  C0
166C:  MOVWF  x82
166E:  MOVLW  7F
1670:  MOVWF  x81
1672:  MOVLW  88
1674:  MOVWF  x80
1676:  CALL   0286
167A:  MOVFF  03,31
167E:  MOVFF  02,30
1682:  MOVFF  01,2F
1686:  MOVFF  00,2E
.................... // Inicio calculo de equação de  Steinhart & Hart  
.................... rntc=50000/ntc_val;      
168A:  CLRF   x7F
168C:  MOVLW  50
168E:  MOVWF  x7E
1690:  MOVLW  43
1692:  MOVWF  x7D
1694:  MOVLW  8E
1696:  MOVWF  x7C
1698:  MOVFF  31,83
169C:  MOVFF  30,82
16A0:  MOVFF  2F,81
16A4:  MOVFF  2E,80
16A8:  CALL   0286
16AC:  MOVFF  03,35
16B0:  MOVFF  02,34
16B4:  MOVFF  01,33
16B8:  MOVFF  00,32
....................        rntc=rntc-10000;       
16BC:  BSF    FD8.1
16BE:  MOVFF  35,8A
16C2:  MOVFF  34,89
16C6:  MOVFF  33,88
16CA:  MOVFF  32,87
16CE:  CLRF   x8E
16D0:  MOVLW  40
16D2:  MOVWF  x8D
16D4:  MOVLW  1C
16D6:  MOVWF  x8C
16D8:  MOVLW  8C
16DA:  MOVWF  x8B
16DC:  CALL   03E0
16E0:  MOVFF  03,35
16E4:  MOVFF  02,34
16E8:  MOVFF  01,33
16EC:  MOVFF  00,32
....................        b1=log(rntc);           
16F0:  MOVFF  35,66
16F4:  MOVFF  34,65
16F8:  MOVFF  33,64
16FC:  MOVFF  32,63
1700:  CALL   0708
1704:  MOVFF  03,39
1708:  MOVFF  02,38
170C:  MOVFF  01,37
1710:  MOVFF  00,36
....................        b1=b1*b;                
1714:  MOVFF  39,86
1718:  MOVFF  38,85
171C:  MOVFF  37,84
1720:  MOVFF  36,83
1724:  MOVFF  4E,8A
1728:  MOVFF  4D,89
172C:  MOVFF  4C,88
1730:  MOVFF  4B,87
1734:  CALL   0194
1738:  MOVFF  03,39
173C:  MOVFF  02,38
1740:  MOVFF  01,37
1744:  MOVFF  00,36
....................        c1=log(rntc);           
1748:  MOVFF  35,66
174C:  MOVFF  34,65
1750:  MOVFF  33,64
1754:  MOVFF  32,63
1758:  CALL   0708
175C:  MOVFF  03,3D
1760:  MOVFF  02,3C
1764:  MOVFF  01,3B
1768:  MOVFF  00,3A
....................        c1=pow(c1,3);           
176C:  MOVFF  3D,5A
1770:  MOVFF  3C,59
1774:  MOVFF  3B,58
1778:  MOVFF  3A,57
177C:  CLRF   5E
177E:  CLRF   5D
1780:  MOVLW  40
1782:  MOVWF  5C
1784:  MOVLW  80
1786:  MOVWF  5B
1788:  BRA    1310
178A:  MOVFF  03,3D
178E:  MOVFF  02,3C
1792:  MOVFF  01,3B
1796:  MOVFF  00,3A
....................        c1=c1*c;                
179A:  MOVFF  3D,86
179E:  MOVFF  3C,85
17A2:  MOVFF  3B,84
17A6:  MOVFF  3A,83
17AA:  MOVFF  52,8A
17AE:  MOVFF  51,89
17B2:  MOVFF  50,88
17B6:  MOVFF  4F,87
17BA:  CALL   0194
17BE:  MOVFF  03,3D
17C2:  MOVFF  02,3C
17C6:  MOVFF  01,3B
17CA:  MOVFF  00,3A
....................        temp=a+b1+c1;           
17CE:  BCF    FD8.1
17D0:  MOVFF  4A,8A
17D4:  MOVFF  49,89
17D8:  MOVFF  48,88
17DC:  MOVFF  47,87
17E0:  MOVFF  39,8E
17E4:  MOVFF  38,8D
17E8:  MOVFF  37,8C
17EC:  MOVFF  36,8B
17F0:  CALL   03E0
17F4:  MOVFF  03,5A
17F8:  MOVFF  02,59
17FC:  MOVFF  01,58
1800:  MOVFF  00,57
1804:  BCF    FD8.1
1806:  MOVFF  03,8A
180A:  MOVFF  02,89
180E:  MOVFF  01,88
1812:  MOVFF  00,87
1816:  MOVFF  3D,8E
181A:  MOVFF  3C,8D
181E:  MOVFF  3B,8C
1822:  MOVFF  3A,8B
1826:  CALL   03E0
182A:  MOVFF  03,41
182E:  MOVFF  02,40
1832:  MOVFF  01,3F
1836:  MOVFF  00,3E
....................        temp=1/temp;            
183A:  CLRF   x7F
183C:  CLRF   x7E
183E:  CLRF   x7D
1840:  MOVLW  7F
1842:  MOVWF  x7C
1844:  MOVFF  41,83
1848:  MOVFF  40,82
184C:  MOVFF  3F,81
1850:  MOVFF  3E,80
1854:  CALL   0286
1858:  MOVFF  03,41
185C:  MOVFF  02,40
1860:  MOVFF  01,3F
1864:  MOVFF  00,3E
....................        temp=temp-273.15; 
1868:  BSF    FD8.1
186A:  MOVFF  41,8A
186E:  MOVFF  40,89
1872:  MOVFF  3F,88
1876:  MOVFF  3E,87
187A:  MOVLW  33
187C:  MOVWF  x8E
187E:  MOVLW  93
1880:  MOVWF  x8D
1882:  MOVLW  08
1884:  MOVWF  x8C
1886:  MOVLW  87
1888:  MOVWF  x8B
188A:  CALL   03E0
188E:  MOVFF  03,41
1892:  MOVFF  02,40
1896:  MOVFF  01,3F
189A:  MOVFF  00,3E
....................        return temp; 
189E:  MOVFF  3E,00
18A2:  MOVFF  3F,01
18A6:  MOVFF  40,02
18AA:  MOVFF  41,03
18AE:  GOTO   1C40 (RETURN)
.................... // Fim do calculo de equação de  Steinhart & Hart 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... void mexeovos () {  
....................    limpa_lcd(); 
*
1AB4:  CALL   0116
....................    comando_lcd(0x83); //  posiciona o cursor no endereço 0x83 
1AB8:  MOVLW  83
1ABA:  MOVWF  58
1ABC:  CALL   00D4
....................    printf(escreve_lcd,"MEXENDO" ); 
1AC0:  MOVLW  CC
1AC2:  MOVWF  FF6
1AC4:  MOVLW  00
1AC6:  MOVWF  FF7
1AC8:  BRA    1A78
....................       for(int i=0;  i<50; i++){                       
1ACA:  CLRF   57
1ACC:  MOVF   57,W
1ACE:  SUBLW  31
1AD0:  BNC   1AF6
....................       PIN_SERV=1; 
1AD2:  BSF    F81.3
....................       delay_us(800); 
1AD4:  MOVLW  04
1AD6:  MOVWF  58
1AD8:  MOVLW  C7
1ADA:  MOVWF  59
1ADC:  RCALL  1A9A
1ADE:  DECFSZ 58,F
1AE0:  BRA    1AD8
....................       PIN_SERV=0; 
1AE2:  BCF    F81.3
....................       delay_us(19200); 
1AE4:  MOVLW  13
1AE6:  MOVWF  59
1AE8:  CALL   00F0
1AEC:  MOVLW  C8
1AEE:  MOVWF  59
1AF0:  RCALL  1A9A
1AF2:  INCF   57,F
1AF4:  BRA    1ACC
....................       } 
....................       delay_ms(2000); 
1AF6:  MOVLW  08
1AF8:  MOVWF  58
1AFA:  MOVLW  FA
1AFC:  MOVWF  59
1AFE:  CALL   00F0
1B02:  DECFSZ 58,F
1B04:  BRA    1AFA
....................       for(i=0;  i<50; i++){ 
1B06:  CLRF   57
1B08:  MOVF   57,W
1B0A:  SUBLW  31
1B0C:  BNC   1B42
....................       PIN_SERV=1; 
1B0E:  BSF    F81.3
....................       delay_us(1500); 
1B10:  MOVLW  01
1B12:  MOVWF  59
1B14:  CALL   00F0
1B18:  MOVLW  02
1B1A:  MOVWF  58
1B1C:  MOVLW  F9
1B1E:  MOVWF  59
1B20:  RCALL  1A9A
1B22:  DECFSZ 58,F
1B24:  BRA    1B1C
....................       PIN_SERV=0; 
1B26:  BCF    F81.3
....................       delay_us(18500); 
1B28:  MOVLW  12
1B2A:  MOVWF  59
1B2C:  CALL   00F0
1B30:  MOVLW  02
1B32:  MOVWF  58
1B34:  MOVLW  F9
1B36:  MOVWF  59
1B38:  RCALL  1A9A
1B3A:  DECFSZ 58,F
1B3C:  BRA    1B34
1B3E:  INCF   57,F
1B40:  BRA    1B08
....................       } 
....................       delay_ms(2000); 
1B42:  MOVLW  08
1B44:  MOVWF  58
1B46:  MOVLW  FA
1B48:  MOVWF  59
1B4A:  CALL   00F0
1B4E:  DECFSZ 58,F
1B50:  BRA    1B46
1B52:  GOTO   1C72 (RETURN)
....................     
.................... } 
....................  
.................... void main (void){ 
1B56:  CLRF   FF8
1B58:  BCF    FD0.7
1B5A:  BSF    07.7
1B5C:  CLRF   31
1B5E:  CLRF   30
1B60:  CLRF   2F
1B62:  CLRF   2E
1B64:  CLRF   35
1B66:  CLRF   34
1B68:  CLRF   33
1B6A:  CLRF   32
1B6C:  CLRF   39
1B6E:  CLRF   38
1B70:  CLRF   37
1B72:  CLRF   36
1B74:  CLRF   3D
1B76:  CLRF   3C
1B78:  CLRF   3B
1B7A:  CLRF   3A
1B7C:  CLRF   41
1B7E:  CLRF   40
1B80:  CLRF   3F
1B82:  CLRF   3E
1B84:  CLRF   45
1B86:  CLRF   44
1B88:  CLRF   43
1B8A:  CLRF   42
1B8C:  MOVLW  93
1B8E:  MOVWF  4A
1B90:  MOVLW  26
1B92:  MOVWF  49
1B94:  MOVLW  14
1B96:  MOVWF  48
1B98:  MOVLW  75
1B9A:  MOVWF  47
1B9C:  MOVLW  0E
1B9E:  MOVWF  4E
1BA0:  MOVLW  43
1BA2:  MOVWF  4D
1BA4:  MOVLW  75
1BA6:  MOVWF  4C
1BA8:  MOVLW  72
1BAA:  MOVWF  4B
1BAC:  MOVLW  DC
1BAE:  MOVWF  52
1BB0:  MOVLW  54
1BB2:  MOVWF  51
1BB4:  MOVLW  3E
1BB6:  MOVWF  50
1BB8:  MOVLW  67
1BBA:  MOVWF  4F
1BBC:  CLRF   53
1BBE:  CLRF   55
1BC0:  CLRF   54
1BC2:  CLRF   56
1BC4:  MOVF   FC1,W
1BC6:  ANDLW  C0
1BC8:  IORLW  0F
1BCA:  MOVWF  FC1
1BCC:  MOVLW  07
1BCE:  MOVWF  FB4
1BD0:  CLRF   16
1BD2:  CLRF   17
1BD4:  MOVLW  52
1BD6:  MOVWF  1C
1BD8:  MOVLW  48
1BDA:  MOVWF  1D
1BDC:  MOVLW  A0
1BDE:  MOVWF  1E
1BE0:  MOVWF  1F
1BE2:  MOVWF  20
1BE4:  MOVLW  3D
1BE6:  MOVWF  21
1BE8:  MOVLW  A0
1BEA:  MOVWF  22
1BEC:  MOVLW  30
1BEE:  MOVWF  23
1BF0:  MOVWF  24
1BF2:  MOVLW  2E
1BF4:  MOVWF  25
1BF6:  MOVLW  30
1BF8:  MOVWF  26
1BFA:  MOVLW  A0
1BFC:  MOVWF  27
1BFE:  MOVLW  25
1C00:  MOVWF  28
1C02:  CLRF   29
.................... setup_adc(ADC_CLOCK_DIV_32); //  configura o clock utilizado para o conversor ad e o pior clock ele usa a malha RC é lenta  
1C04:  MOVF   FC0,W
1C06:  ANDLW  C0
1C08:  IORLW  02
1C0A:  MOVWF  FC0
1C0C:  BSF    FC0.7
1C0E:  BSF    FC2.0
.................... setup_adc_ports( AN0_TO_AN2 ); // selecionaos pinos A0 a A2 como pinos de sinais analogicos  
1C10:  MOVF   FC1,W
1C12:  ANDLW  C0
1C14:  IORLW  0C
1C16:  MOVWF  FC1
.................... set_tris_a(0b00001111); // verificar se pinos analogicos necessitam de definição de tris 
1C18:  MOVLW  0F
1C1A:  MOVWF  F92
.................... set_tris_b(0b11000000);   
1C1C:  MOVLW  C0
1C1E:  MOVWF  F93
.................... set_tris_c(0b00000000);// define os pinos RB0 E RB1 como entrada e os demais como saida 
1C20:  MOVLW  00
1C22:  MOVWF  F94
.................... set_tris_d(0b00000000);  //  Idem como supracitado acima  
1C24:  MOVWF  F95
.................... set_tris_e(0b00000100); 
1C26:  MOVLW  04
1C28:  MOVWF  F96
.................... inicializa_lcd(); // função responsavel por inicializar o modulo lcd 
1C2A:  GOTO   0124
.................... // CONFIGURA?+O DO TIMER0 
....................    setup_timer_0 (RTCC_INTERNAL | RTCC_8_BIT | RTCC_DIV_64); 
1C2E:  MOVLW  C5
1C30:  MOVWF  FD5
....................    set_timer0(131); 
1C32:  CLRF   FD7
1C34:  MOVLW  83
1C36:  MOVWF  FD6
....................    enable_interrupts(GLOBAL);//chave principal das interrup??es 
1C38:  MOVLW  C0
1C3A:  IORWF  FF2,F
....................    enable_interrupts(int_timer0); // interrup??o do TIMER 0 
1C3C:  BSF    FF2.5
....................    
....................   while(true){ 
....................   temperatura = ntc(); //  le o valor  de temperatura em graus celsius que a função do ntc retorna  
1C3E:  BRA    15E6
1C40:  MOVFF  03,45
1C44:  MOVFF  02,44
1C48:  MOVFF  01,43
1C4C:  MOVFF  00,42
....................   umidade = dht11(); 
1C50:  BRA    19C6
1C52:  MOVFF  01,46
.................... limpa_lcd(); 
1C56:  CALL   0116
....................  comando_lcd(0x83); //  posiciona o cursor no endereço 0x83 
1C5A:  MOVLW  83
1C5C:  MOVWF  58
1C5E:  CALL   00D4
.................... printf(escreve_lcd,"%s",message2); 
1C62:  CLRF   FEA
1C64:  MOVLW  1C
1C66:  MOVWF  FE9
1C68:  BRA    1A52
....................  
....................    if(horas == 3){ 
1C6A:  MOVF   56,W
1C6C:  SUBLW  03
1C6E:  BNZ   1C74
....................     mexeovos(); 
1C70:  BRA    1AB4
....................     horas=0; 
1C72:  CLRF   56
....................     } 
....................     
....................     // implementação da rotina de controle de  temperatura  
....................    if(temperatura<=38){   //  verifica se da temperatura de menor que 38 graus e faz  a rotina  
1C74:  MOVFF  45,86
1C78:  MOVFF  44,85
1C7C:  MOVFF  43,84
1C80:  MOVFF  42,83
1C84:  CLRF   x8A
1C86:  CLRF   x89
1C88:  MOVLW  18
1C8A:  MOVWF  x88
1C8C:  MOVLW  84
1C8E:  MOVWF  x87
1C90:  CALL   064A
1C94:  BC    1C98
1C96:  BNZ   1C9C
....................      PIN_COOLER =0 ; 
1C98:  BCF    F82.0
....................      RELE_LAMP = 1 ; 
1C9A:  BSF    F81.2
....................     } 
....................     if(temperatura>38){ 
1C9C:  CLRF   x86
1C9E:  CLRF   x85
1CA0:  MOVLW  18
1CA2:  MOVWF  x84
1CA4:  MOVLW  84
1CA6:  MOVWF  x83
1CA8:  MOVFF  45,8A
1CAC:  MOVFF  44,89
1CB0:  MOVFF  43,88
1CB4:  MOVFF  42,87
1CB8:  CALL   064A
1CBC:  BNC   1CC2
....................     PIN_COOLER =1 ; 
1CBE:  BSF    F82.0
....................     RELE_LAMP = 0 ;  
1CC0:  BCF    F81.2
....................     } 
1CC2:  BRA    1C3E
....................     //delay_ms(2000);    
....................   } 
....................    
....................    
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... } 
1CC4:  SLEEP 

Configuration Fuses:
   Word  1: CC3F   PLL12 CPUDIV4 USBDIV HS FCMEN IESO
   Word  2: 1E38   PUT NOBROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
