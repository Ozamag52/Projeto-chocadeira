CCS PCH C Compiler, Version 5.015, 5967               28-jun-17 16:37

               Filename:   C:\Users\henri\Documents\GitHub\Projeto-chocadeira\Cod chocadeira sem interrupção\cod_chocadeira_sem_interrupcao.lst

               ROM used:   7470 bytes (23%)
                           Largest free fragment is 25298
               RAM used:   66 (3%) at main() level
                           130 (6%) worst case
               Stack used: 6 locations
               Stack size: 31

*
0000:  GOTO   1BD2
....................  
.................... #INCLUDE<18F4550.h>//   Inclui a biblioteca resposável por estabelecer os parametros do pic utilizado no projeto 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
0004:  DATA 4D,45
0006:  DATA 58,45
0008:  DATA 4E,44
000A:  DATA 4F,00
*
0098:  MOVLW  8E
009A:  MOVWF  00
009C:  MOVFF  73,01
00A0:  MOVFF  72,02
00A4:  CLRF   03
00A6:  MOVF   01,F
00A8:  BNZ   00BC
00AA:  MOVFF  02,01
00AE:  CLRF   02
00B0:  MOVLW  08
00B2:  SUBWF  00,F
00B4:  MOVF   01,F
00B6:  BNZ   00BC
00B8:  CLRF   00
00BA:  BRA    00CC
00BC:  BCF    FD8.0
00BE:  BTFSC  01.7
00C0:  BRA    00CA
00C2:  RLCF   02,F
00C4:  RLCF   01,F
00C6:  DECF   00,F
00C8:  BRA    00BC
00CA:  BCF    01.7
00CC:  RETURN 0
00CE:  MOVF   x6E,W
00D0:  BTFSC  FD8.2
00D2:  BRA    01B6
00D4:  MOVWF  00
00D6:  MOVF   x72,W
00D8:  BTFSC  FD8.2
00DA:  BRA    01B6
00DC:  ADDWF  00,F
00DE:  BNC   00E8
00E0:  MOVLW  81
00E2:  ADDWF  00,F
00E4:  BC    01B6
00E6:  BRA    00F0
00E8:  MOVLW  7F
00EA:  SUBWF  00,F
00EC:  BNC   01B6
00EE:  BZ    01B6
00F0:  MOVFF  6F,76
00F4:  MOVF   x73,W
00F6:  XORWF  x76,F
00F8:  BSF    x6F.7
00FA:  BSF    x73.7
00FC:  MOVF   x71,W
00FE:  MULWF  x75
0100:  MOVFF  FF4,78
0104:  MOVF   x70,W
0106:  MULWF  x74
0108:  MOVFF  FF4,03
010C:  MOVFF  FF3,77
0110:  MULWF  x75
0112:  MOVF   FF3,W
0114:  ADDWF  x78,F
0116:  MOVF   FF4,W
0118:  ADDWFC x77,F
011A:  MOVLW  00
011C:  ADDWFC 03,F
011E:  MOVF   x71,W
0120:  MULWF  x74
0122:  MOVF   FF3,W
0124:  ADDWF  x78,F
0126:  MOVF   FF4,W
0128:  ADDWFC x77,F
012A:  MOVLW  00
012C:  CLRF   02
012E:  ADDWFC 03,F
0130:  ADDWFC 02,F
0132:  MOVF   x6F,W
0134:  MULWF  x75
0136:  MOVF   FF3,W
0138:  ADDWF  x77,F
013A:  MOVF   FF4,W
013C:  ADDWFC 03,F
013E:  MOVLW  00
0140:  ADDWFC 02,F
0142:  MOVF   x6F,W
0144:  MULWF  x74
0146:  MOVF   FF3,W
0148:  ADDWF  03,F
014A:  MOVF   FF4,W
014C:  ADDWFC 02,F
014E:  MOVLW  00
0150:  CLRF   01
0152:  ADDWFC 01,F
0154:  MOVF   x71,W
0156:  MULWF  x73
0158:  MOVF   FF3,W
015A:  ADDWF  x77,F
015C:  MOVF   FF4,W
015E:  ADDWFC 03,F
0160:  MOVLW  00
0162:  ADDWFC 02,F
0164:  ADDWFC 01,F
0166:  MOVF   x70,W
0168:  MULWF  x73
016A:  MOVF   FF3,W
016C:  ADDWF  03,F
016E:  MOVF   FF4,W
0170:  ADDWFC 02,F
0172:  MOVLW  00
0174:  ADDWFC 01,F
0176:  MOVF   x6F,W
0178:  MULWF  x73
017A:  MOVF   FF3,W
017C:  ADDWF  02,F
017E:  MOVF   FF4,W
0180:  ADDWFC 01,F
0182:  INCF   00,F
0184:  BTFSC  01.7
0186:  BRA    0192
0188:  RLCF   x77,F
018A:  RLCF   03,F
018C:  RLCF   02,F
018E:  RLCF   01,F
0190:  DECF   00,F
0192:  MOVLW  00
0194:  BTFSS  x77.7
0196:  BRA    01AC
0198:  INCF   03,F
019A:  ADDWFC 02,F
019C:  ADDWFC 01,F
019E:  MOVF   01,W
01A0:  BNZ   01AC
01A2:  MOVF   02,W
01A4:  BNZ   01AC
01A6:  MOVF   03,W
01A8:  BNZ   01AC
01AA:  INCF   00,F
01AC:  BTFSC  x76.7
01AE:  BSF    01.7
01B0:  BTFSS  x76.7
01B2:  BCF    01.7
01B4:  BRA    01BE
01B6:  CLRF   00
01B8:  CLRF   01
01BA:  CLRF   02
01BC:  CLRF   03
01BE:  RETURN 0
01C0:  MOVF   x67,W
01C2:  BTFSC  FD8.2
01C4:  BRA    0310
01C6:  MOVWF  x73
01C8:  MOVF   x6B,W
01CA:  BTFSC  FD8.2
01CC:  BRA    0310
01CE:  SUBWF  x73,F
01D0:  BNC   01DC
01D2:  MOVLW  7F
01D4:  ADDWF  x73,F
01D6:  BTFSC  FD8.0
01D8:  BRA    0310
01DA:  BRA    01E8
01DC:  MOVLW  81
01DE:  SUBWF  x73,F
01E0:  BTFSS  FD8.0
01E2:  BRA    0310
01E4:  BTFSC  FD8.2
01E6:  BRA    0310
01E8:  MOVFF  73,00
01EC:  CLRF   01
01EE:  CLRF   02
01F0:  CLRF   03
01F2:  CLRF   x72
01F4:  MOVFF  68,71
01F8:  BSF    x71.7
01FA:  MOVFF  69,70
01FE:  MOVFF  6A,6F
0202:  MOVLW  19
0204:  MOVWF  x73
0206:  MOVF   x6E,W
0208:  SUBWF  x6F,F
020A:  BC    0226
020C:  MOVLW  01
020E:  SUBWF  x70,F
0210:  BC    0226
0212:  SUBWF  x71,F
0214:  BC    0226
0216:  SUBWF  x72,F
0218:  BC    0226
021A:  INCF   x72,F
021C:  INCF   x71,F
021E:  INCF   x70,F
0220:  MOVF   x6E,W
0222:  ADDWF  x6F,F
0224:  BRA    0276
0226:  MOVF   x6D,W
0228:  SUBWF  x70,F
022A:  BC    0250
022C:  MOVLW  01
022E:  SUBWF  x71,F
0230:  BC    0250
0232:  SUBWF  x72,F
0234:  BC    0250
0236:  INCF   x72,F
0238:  INCF   x71,F
023A:  MOVF   x6D,W
023C:  ADDWF  x70,F
023E:  MOVF   x6E,W
0240:  ADDWF  x6F,F
0242:  BNC   0276
0244:  INCF   x70,F
0246:  BNZ   0276
0248:  INCF   x71,F
024A:  BNZ   0276
024C:  INCF   x72,F
024E:  BRA    0276
0250:  MOVF   x6C,W
0252:  IORLW  80
0254:  SUBWF  x71,F
0256:  BC    0274
0258:  MOVLW  01
025A:  SUBWF  x72,F
025C:  BC    0274
025E:  INCF   x72,F
0260:  MOVF   x6C,W
0262:  IORLW  80
0264:  ADDWF  x71,F
0266:  MOVF   x6D,W
0268:  ADDWF  x70,F
026A:  BNC   023E
026C:  INCF   x71,F
026E:  BNZ   023E
0270:  INCF   x72,F
0272:  BRA    023E
0274:  BSF    03.0
0276:  DECFSZ x73,F
0278:  BRA    027C
027A:  BRA    0292
027C:  BCF    FD8.0
027E:  RLCF   x6F,F
0280:  RLCF   x70,F
0282:  RLCF   x71,F
0284:  RLCF   x72,F
0286:  BCF    FD8.0
0288:  RLCF   03,F
028A:  RLCF   02,F
028C:  RLCF   01,F
028E:  RLCF   x74,F
0290:  BRA    0206
0292:  BTFSS  x74.0
0294:  BRA    02A2
0296:  BCF    FD8.0
0298:  RRCF   01,F
029A:  RRCF   02,F
029C:  RRCF   03,F
029E:  RRCF   x74,F
02A0:  BRA    02A6
02A2:  DECF   00,F
02A4:  BZ    0310
02A6:  BTFSC  x74.7
02A8:  BRA    02E6
02AA:  BCF    FD8.0
02AC:  RLCF   x6F,F
02AE:  RLCF   x70,F
02B0:  RLCF   x71,F
02B2:  RLCF   x72,F
02B4:  MOVF   x6E,W
02B6:  SUBWF  x6F,F
02B8:  BC    02C8
02BA:  MOVLW  01
02BC:  SUBWF  x70,F
02BE:  BC    02C8
02C0:  SUBWF  x71,F
02C2:  BC    02C8
02C4:  SUBWF  x72,F
02C6:  BNC   02FC
02C8:  MOVF   x6D,W
02CA:  SUBWF  x70,F
02CC:  BC    02D8
02CE:  MOVLW  01
02D0:  SUBWF  x71,F
02D2:  BC    02D8
02D4:  SUBWF  x72,F
02D6:  BNC   02FC
02D8:  MOVF   x6C,W
02DA:  IORLW  80
02DC:  SUBWF  x71,F
02DE:  BC    02E6
02E0:  MOVLW  01
02E2:  SUBWF  x72,F
02E4:  BNC   02FC
02E6:  INCF   03,F
02E8:  BNZ   02FC
02EA:  INCF   02,F
02EC:  BNZ   02FC
02EE:  INCF   01,F
02F0:  BNZ   02FC
02F2:  INCF   00,F
02F4:  BZ    0310
02F6:  RRCF   01,F
02F8:  RRCF   02,F
02FA:  RRCF   03,F
02FC:  MOVFF  68,73
0300:  MOVF   x6C,W
0302:  XORWF  x73,F
0304:  BTFSS  x73.7
0306:  BRA    030C
0308:  BSF    01.7
030A:  BRA    0318
030C:  BCF    01.7
030E:  BRA    0318
0310:  CLRF   00
0312:  CLRF   01
0314:  CLRF   02
0316:  CLRF   03
0318:  RETURN 0
031A:  MOVLW  80
031C:  BTFSC  FD8.1
031E:  XORWF  x77,F
0320:  CLRF   x7C
0322:  CLRF   x7D
0324:  MOVFF  73,7B
0328:  MOVF   x77,W
032A:  XORWF  x7B,F
032C:  MOVF   x72,W
032E:  BTFSC  FD8.2
0330:  BRA    04EA
0332:  MOVWF  x7A
0334:  MOVWF  00
0336:  MOVF   x76,W
0338:  BTFSC  FD8.2
033A:  BRA    04FC
033C:  SUBWF  x7A,F
033E:  BTFSC  FD8.2
0340:  BRA    0444
0342:  BNC   03BE
0344:  MOVFF  77,80
0348:  BSF    x80.7
034A:  MOVFF  78,7F
034E:  MOVFF  79,7E
0352:  CLRF   x7D
0354:  BCF    FD8.0
0356:  RRCF   x80,F
0358:  RRCF   x7F,F
035A:  RRCF   x7E,F
035C:  RRCF   x7D,F
035E:  DECFSZ x7A,F
0360:  BRA    0352
0362:  BTFSS  x7B.7
0364:  BRA    036C
0366:  BSF    x7C.0
0368:  BRA    0524
036A:  BCF    x7C.0
036C:  BCF    x7A.0
036E:  BSF    x7C.4
0370:  CLRF   FEA
0372:  MOVLW  75
0374:  MOVWF  FE9
0376:  BRA    054A
0378:  BCF    x7C.4
037A:  BTFSC  x7B.7
037C:  BRA    0392
037E:  BTFSS  x7A.0
0380:  BRA    03A8
0382:  RRCF   x80,F
0384:  RRCF   x7F,F
0386:  RRCF   x7E,F
0388:  RRCF   x7D,F
038A:  INCF   00,F
038C:  BTFSC  FD8.2
038E:  BRA    051A
0390:  BRA    03A8
0392:  BTFSC  x80.7
0394:  BRA    03AE
0396:  BCF    FD8.0
0398:  RLCF   x7D,F
039A:  RLCF   x7E,F
039C:  RLCF   x7F,F
039E:  RLCF   x80,F
03A0:  DECF   00,F
03A2:  BTFSC  FD8.2
03A4:  BRA    051A
03A6:  BRA    0392
03A8:  BSF    x7C.6
03AA:  BRA    0482
03AC:  BCF    x7C.6
03AE:  MOVFF  73,7B
03B2:  BTFSS  x73.7
03B4:  BRA    03BA
03B6:  BSF    x80.7
03B8:  BRA    050C
03BA:  BCF    x80.7
03BC:  BRA    050C
03BE:  MOVFF  76,7A
03C2:  MOVFF  76,00
03C6:  MOVF   x72,W
03C8:  SUBWF  x7A,F
03CA:  MOVFF  73,80
03CE:  BSF    x80.7
03D0:  MOVFF  74,7F
03D4:  MOVFF  75,7E
03D8:  CLRF   x7D
03DA:  BCF    FD8.0
03DC:  RRCF   x80,F
03DE:  RRCF   x7F,F
03E0:  RRCF   x7E,F
03E2:  RRCF   x7D,F
03E4:  DECFSZ x7A,F
03E6:  BRA    03D8
03E8:  BTFSS  x7B.7
03EA:  BRA    03F2
03EC:  BSF    x7C.1
03EE:  BRA    0524
03F0:  BCF    x7C.1
03F2:  BCF    x7A.0
03F4:  BSF    x7C.5
03F6:  CLRF   FEA
03F8:  MOVLW  79
03FA:  MOVWF  FE9
03FC:  BRA    054A
03FE:  BCF    x7C.5
0400:  BTFSC  x7B.7
0402:  BRA    0418
0404:  BTFSS  x7A.0
0406:  BRA    042E
0408:  RRCF   x80,F
040A:  RRCF   x7F,F
040C:  RRCF   x7E,F
040E:  RRCF   x7D,F
0410:  INCF   00,F
0412:  BTFSC  FD8.2
0414:  BRA    051A
0416:  BRA    042E
0418:  BTFSC  x80.7
041A:  BRA    0434
041C:  BCF    FD8.0
041E:  RLCF   x7D,F
0420:  RLCF   x7E,F
0422:  RLCF   x7F,F
0424:  RLCF   x80,F
0426:  DECF   00,F
0428:  BTFSC  FD8.2
042A:  BRA    051A
042C:  BRA    0418
042E:  BSF    x7C.7
0430:  BRA    0482
0432:  BCF    x7C.7
0434:  MOVFF  77,7B
0438:  BTFSS  x77.7
043A:  BRA    0440
043C:  BSF    x80.7
043E:  BRA    050C
0440:  BCF    x80.7
0442:  BRA    050C
0444:  MOVFF  77,80
0448:  BSF    x80.7
044A:  MOVFF  78,7F
044E:  MOVFF  79,7E
0452:  BTFSS  x7B.7
0454:  BRA    045E
0456:  BCF    x80.7
0458:  BSF    x7C.2
045A:  BRA    0524
045C:  BCF    x7C.2
045E:  CLRF   x7D
0460:  BCF    x7A.0
0462:  CLRF   FEA
0464:  MOVLW  75
0466:  MOVWF  FE9
0468:  BRA    054A
046A:  BTFSC  x7B.7
046C:  BRA    04A6
046E:  MOVFF  73,7B
0472:  BTFSS  x7A.0
0474:  BRA    0482
0476:  RRCF   x80,F
0478:  RRCF   x7F,F
047A:  RRCF   x7E,F
047C:  RRCF   x7D,F
047E:  INCF   00,F
0480:  BZ    051A
0482:  BTFSS  x7D.7
0484:  BRA    049C
0486:  INCF   x7E,F
0488:  BNZ   049C
048A:  INCF   x7F,F
048C:  BNZ   049C
048E:  INCF   x80,F
0490:  BNZ   049C
0492:  RRCF   x80,F
0494:  RRCF   x7F,F
0496:  RRCF   x7E,F
0498:  INCF   00,F
049A:  BZ    051A
049C:  BTFSC  x7C.6
049E:  BRA    03AC
04A0:  BTFSC  x7C.7
04A2:  BRA    0432
04A4:  BRA    04DE
04A6:  MOVLW  80
04A8:  XORWF  x80,F
04AA:  BTFSS  x80.7
04AC:  BRA    04B6
04AE:  BRA    0524
04B0:  MOVFF  77,7B
04B4:  BRA    04CA
04B6:  MOVFF  73,7B
04BA:  MOVF   x80,F
04BC:  BNZ   04CA
04BE:  MOVF   x7F,F
04C0:  BNZ   04CA
04C2:  MOVF   x7E,F
04C4:  BNZ   04CA
04C6:  CLRF   00
04C8:  BRA    050C
04CA:  BTFSC  x80.7
04CC:  BRA    04DE
04CE:  BCF    FD8.0
04D0:  RLCF   x7D,F
04D2:  RLCF   x7E,F
04D4:  RLCF   x7F,F
04D6:  RLCF   x80,F
04D8:  DECFSZ 00,F
04DA:  BRA    04CA
04DC:  BRA    051A
04DE:  BTFSS  x7B.7
04E0:  BRA    04E6
04E2:  BSF    x80.7
04E4:  BRA    050C
04E6:  BCF    x80.7
04E8:  BRA    050C
04EA:  MOVFF  76,00
04EE:  MOVFF  77,80
04F2:  MOVFF  78,7F
04F6:  MOVFF  79,7E
04FA:  BRA    050C
04FC:  MOVFF  72,00
0500:  MOVFF  73,80
0504:  MOVFF  74,7F
0508:  MOVFF  75,7E
050C:  MOVFF  80,01
0510:  MOVFF  7F,02
0514:  MOVFF  7E,03
0518:  BRA    0582
051A:  CLRF   00
051C:  CLRF   01
051E:  CLRF   02
0520:  CLRF   03
0522:  BRA    0582
0524:  CLRF   x7D
0526:  COMF   x7E,F
0528:  COMF   x7F,F
052A:  COMF   x80,F
052C:  COMF   x7D,F
052E:  INCF   x7D,F
0530:  BNZ   053C
0532:  INCF   x7E,F
0534:  BNZ   053C
0536:  INCF   x7F,F
0538:  BNZ   053C
053A:  INCF   x80,F
053C:  BTFSC  x7C.0
053E:  BRA    036A
0540:  BTFSC  x7C.1
0542:  BRA    03F0
0544:  BTFSC  x7C.2
0546:  BRA    045C
0548:  BRA    04B0
054A:  MOVF   FEF,W
054C:  ADDWF  x7E,F
054E:  BNC   055A
0550:  INCF   x7F,F
0552:  BNZ   055A
0554:  INCF   x80,F
0556:  BTFSC  FD8.2
0558:  BSF    x7A.0
055A:  MOVF   FED,F
055C:  MOVF   FEF,W
055E:  ADDWF  x7F,F
0560:  BNC   0568
0562:  INCF   x80,F
0564:  BTFSC  FD8.2
0566:  BSF    x7A.0
0568:  MOVF   FED,F
056A:  MOVF   FEF,W
056C:  BTFSC  FEF.7
056E:  BRA    0572
0570:  XORLW  80
0572:  ADDWF  x80,F
0574:  BTFSC  FD8.0
0576:  BSF    x7A.0
0578:  BTFSC  x7C.4
057A:  BRA    0378
057C:  BTFSC  x7C.5
057E:  BRA    03FE
0580:  BRA    046A
0582:  RETURN 0
0584:  MOVFF  6F,76
0588:  MOVF   x73,W
058A:  XORWF  x76,F
058C:  BTFSS  x76.7
058E:  BRA    059A
0590:  BCF    FD8.2
0592:  BCF    FD8.0
0594:  BTFSC  x6F.7
0596:  BSF    FD8.0
0598:  BRA    05F8
059A:  MOVFF  6F,76
059E:  MOVFF  72,77
05A2:  MOVF   x6E,W
05A4:  SUBWF  x77,F
05A6:  BZ    05B4
05A8:  BTFSS  x76.7
05AA:  BRA    05F8
05AC:  MOVF   FD8,W
05AE:  XORLW  01
05B0:  MOVWF  FD8
05B2:  BRA    05F8
05B4:  MOVFF  73,77
05B8:  MOVF   x6F,W
05BA:  SUBWF  x77,F
05BC:  BZ    05CA
05BE:  BTFSS  x76.7
05C0:  BRA    05F8
05C2:  MOVF   FD8,W
05C4:  XORLW  01
05C6:  MOVWF  FD8
05C8:  BRA    05F8
05CA:  MOVFF  74,77
05CE:  MOVF   x70,W
05D0:  SUBWF  x77,F
05D2:  BZ    05E0
05D4:  BTFSS  x76.7
05D6:  BRA    05F8
05D8:  MOVF   FD8,W
05DA:  XORLW  01
05DC:  MOVWF  FD8
05DE:  BRA    05F8
05E0:  MOVFF  75,77
05E4:  MOVF   x71,W
05E6:  SUBWF  x77,F
05E8:  BZ    05F6
05EA:  BTFSS  x76.7
05EC:  BRA    05F8
05EE:  MOVF   FD8,W
05F0:  XORLW  01
05F2:  MOVWF  FD8
05F4:  BRA    05F8
05F6:  BCF    FD8.0
05F8:  RETURN 0
05FA:  MOVLW  8E
05FC:  MOVWF  00
05FE:  MOVFF  65,01
0602:  MOVFF  64,02
0606:  CLRF   03
0608:  BTFSS  x65.7
060A:  BRA    0616
060C:  COMF   01,F
060E:  COMF   02,F
0610:  INCF   02,F
0612:  BNZ   0616
0614:  INCF   01,F
0616:  MOVF   01,F
0618:  BNZ   062C
061A:  MOVFF  02,01
061E:  CLRF   02
0620:  MOVLW  08
0622:  SUBWF  00,F
0624:  MOVF   01,F
0626:  BNZ   062C
0628:  CLRF   00
062A:  BRA    0640
062C:  BCF    FD8.0
062E:  BTFSC  01.7
0630:  BRA    063A
0632:  RLCF   02,F
0634:  RLCF   01,F
0636:  DECF   00,F
0638:  BRA    062C
063A:  BTFSC  x65.7
063C:  BRA    0640
063E:  BCF    01.7
0640:  RETURN 0
*
0982:  MOVLW  8E
0984:  MOVWF  00
0986:  MOVF   x6E,W
0988:  SUBWF  00,F
098A:  MOVFF  6F,02
098E:  MOVFF  70,01
0992:  BSF    02.7
0994:  MOVF   00,F
0996:  BZ    09AA
0998:  BCF    FD8.0
099A:  MOVF   02,F
099C:  BNZ   09A2
099E:  MOVF   01,F
09A0:  BZ    09AA
09A2:  RRCF   02,F
09A4:  RRCF   01,F
09A6:  DECFSZ 00,F
09A8:  BRA    0998
09AA:  BTFSS  x6F.7
09AC:  BRA    09B8
09AE:  COMF   01,F
09B0:  COMF   02,F
09B2:  INCF   01,F
09B4:  BTFSC  FD8.2
09B6:  INCF   02,F
09B8:  RETURN 0
*
18D4:  MOVF   43,W
18D6:  CLRF   01
18D8:  SUBWF  42,W
18DA:  BC    18E2
18DC:  MOVFF  42,00
18E0:  BRA    18FA
18E2:  CLRF   00
18E4:  MOVLW  08
18E6:  MOVWF  44
18E8:  RLCF   42,F
18EA:  RLCF   00,F
18EC:  MOVF   43,W
18EE:  SUBWF  00,W
18F0:  BTFSC  FD8.0
18F2:  MOVWF  00
18F4:  RLCF   01,F
18F6:  DECFSZ 44,F
18F8:  BRA    18E8
18FA:  RETURN 0
*
196C:  MOVF   4F,W
196E:  SUBLW  B6
1970:  MOVWF  4F
1972:  CLRF   03
1974:  MOVFF  50,53
1978:  BSF    50.7
197A:  BCF    FD8.0
197C:  RRCF   50,F
197E:  RRCF   51,F
1980:  RRCF   52,F
1982:  RRCF   03,F
1984:  RRCF   02,F
1986:  RRCF   01,F
1988:  RRCF   00,F
198A:  DECFSZ 4F,F
198C:  BRA    197A
198E:  BTFSS  53.7
1990:  BRA    19A8
1992:  COMF   00,F
1994:  COMF   01,F
1996:  COMF   02,F
1998:  COMF   03,F
199A:  INCF   00,F
199C:  BTFSC  FD8.2
199E:  INCF   01,F
19A0:  BTFSC  FD8.2
19A2:  INCF   02,F
19A4:  BTFSC  FD8.2
19A6:  INCF   03,F
19A8:  GOTO   1AA6 (RETURN)
19AC:  BTFSC  FD8.1
19AE:  BRA    19B6
19B0:  CLRF   FEA
19B2:  MOVLW  57
19B4:  MOVWF  FE9
19B6:  CLRF   00
19B8:  CLRF   01
19BA:  CLRF   02
19BC:  CLRF   03
19BE:  CLRF   57
19C0:  CLRF   58
19C2:  CLRF   59
19C4:  CLRF   5A
19C6:  MOVF   56,W
19C8:  IORWF  55,W
19CA:  IORWF  54,W
19CC:  IORWF  53,W
19CE:  BZ    1A28
19D0:  MOVLW  20
19D2:  MOVWF  5B
19D4:  BCF    FD8.0
19D6:  RLCF   4F,F
19D8:  RLCF   50,F
19DA:  RLCF   51,F
19DC:  RLCF   52,F
19DE:  RLCF   57,F
19E0:  RLCF   58,F
19E2:  RLCF   59,F
19E4:  RLCF   5A,F
19E6:  MOVF   56,W
19E8:  SUBWF  5A,W
19EA:  BNZ   19FC
19EC:  MOVF   55,W
19EE:  SUBWF  59,W
19F0:  BNZ   19FC
19F2:  MOVF   54,W
19F4:  SUBWF  58,W
19F6:  BNZ   19FC
19F8:  MOVF   53,W
19FA:  SUBWF  57,W
19FC:  BNC   1A1C
19FE:  MOVF   53,W
1A00:  SUBWF  57,F
1A02:  MOVF   54,W
1A04:  BTFSS  FD8.0
1A06:  INCFSZ 54,W
1A08:  SUBWF  58,F
1A0A:  MOVF   55,W
1A0C:  BTFSS  FD8.0
1A0E:  INCFSZ 55,W
1A10:  SUBWF  59,F
1A12:  MOVF   56,W
1A14:  BTFSS  FD8.0
1A16:  INCFSZ 56,W
1A18:  SUBWF  5A,F
1A1A:  BSF    FD8.0
1A1C:  RLCF   00,F
1A1E:  RLCF   01,F
1A20:  RLCF   02,F
1A22:  RLCF   03,F
1A24:  DECFSZ 5B,F
1A26:  BRA    19D4
1A28:  MOVFF  57,FEF
1A2C:  MOVFF  58,FEC
1A30:  MOVFF  59,FEC
1A34:  MOVFF  5A,FEC
1A38:  RETURN 0
*
1A56:  MOVF   FE9,W
1A58:  MOVWF  47
1A5A:  MOVF   46,W
1A5C:  MOVWF  49
1A5E:  BZ    1A94
1A60:  MOVFF  45,71
1A64:  MOVFF  44,70
1A68:  MOVFF  43,6F
1A6C:  MOVFF  42,6E
1A70:  CLRF   x75
1A72:  CLRF   x74
1A74:  MOVLW  20
1A76:  MOVWF  x73
1A78:  MOVLW  82
1A7A:  MOVWF  x72
1A7C:  CALL   00CE
1A80:  MOVFF  03,45
1A84:  MOVFF  02,44
1A88:  MOVFF  01,43
1A8C:  MOVFF  00,42
1A90:  DECFSZ 49,F
1A92:  BRA    1A60
1A94:  MOVFF  45,52
1A98:  MOVFF  44,51
1A9C:  MOVFF  43,50
1AA0:  MOVFF  42,4F
1AA4:  BRA    196C
1AA6:  MOVFF  03,45
1AAA:  MOVFF  02,44
1AAE:  MOVFF  01,43
1AB2:  MOVFF  00,42
1AB6:  BTFSS  45.7
1AB8:  BRA    1AD4
1ABA:  DECF   47,F
1ABC:  BSF    47.5
1ABE:  COMF   42,F
1AC0:  COMF   43,F
1AC2:  COMF   44,F
1AC4:  COMF   45,F
1AC6:  INCF   42,F
1AC8:  BTFSC  FD8.2
1ACA:  INCF   43,F
1ACC:  BTFSC  FD8.2
1ACE:  INCF   44,F
1AD0:  BTFSC  FD8.2
1AD2:  INCF   45,F
1AD4:  MOVLW  3B
1AD6:  MOVWF  4E
1AD8:  MOVLW  9A
1ADA:  MOVWF  4D
1ADC:  MOVLW  CA
1ADE:  MOVWF  4C
1AE0:  CLRF   4B
1AE2:  MOVLW  0A
1AE4:  MOVWF  49
1AE6:  MOVF   46,W
1AE8:  BTFSC  FD8.2
1AEA:  INCF   47,F
1AEC:  BSF    FD8.1
1AEE:  CLRF   FEA
1AF0:  MOVLW  42
1AF2:  MOVWF  FE9
1AF4:  MOVFF  45,52
1AF8:  MOVFF  44,51
1AFC:  MOVFF  43,50
1B00:  MOVFF  42,4F
1B04:  MOVFF  4E,56
1B08:  MOVFF  4D,55
1B0C:  MOVFF  4C,54
1B10:  MOVFF  4B,53
1B14:  RCALL  19AC
1B16:  MOVF   01,W
1B18:  MOVF   00,F
1B1A:  BNZ   1B3A
1B1C:  INCF   46,W
1B1E:  SUBWF  49,W
1B20:  BZ    1B3A
1B22:  MOVF   47,W
1B24:  BZ    1B3E
1B26:  ANDLW  0F
1B28:  SUBWF  49,W
1B2A:  BZ    1B2E
1B2C:  BC    1B9C
1B2E:  BTFSC  47.7
1B30:  BRA    1B9C
1B32:  BTFSC  47.6
1B34:  BRA    1B3E
1B36:  MOVLW  20
1B38:  BRA    1B94
1B3A:  MOVLW  20
1B3C:  ANDWF  47,F
1B3E:  BTFSS  47.5
1B40:  BRA    1B5A
1B42:  BCF    47.5
1B44:  MOVF   46,W
1B46:  BTFSS  FD8.2
1B48:  DECF   47,F
1B4A:  MOVF   00,W
1B4C:  MOVWF  47
1B4E:  MOVLW  2D
1B50:  MOVWF  4F
1B52:  RCALL  1A3A
1B54:  MOVF   47,W
1B56:  MOVWF  00
1B58:  CLRF   47
1B5A:  MOVF   46,W
1B5C:  SUBWF  49,W
1B5E:  BNZ   1B74
1B60:  MOVF   00,W
1B62:  MOVWF  47
1B64:  MOVLW  2E
1B66:  MOVWF  4F
1B68:  RCALL  1A3A
1B6A:  MOVF   47,W
1B6C:  MOVWF  00
1B6E:  MOVLW  20
1B70:  ANDWF  47,F
1B72:  MOVLW  00
1B74:  MOVLW  30
1B76:  BTFSS  47.5
1B78:  BRA    1B94
1B7A:  BCF    47.5
1B7C:  MOVF   46,W
1B7E:  BTFSS  FD8.2
1B80:  DECF   47,F
1B82:  MOVF   00,W
1B84:  MOVWF  47
1B86:  MOVLW  2D
1B88:  MOVWF  4F
1B8A:  RCALL  1A3A
1B8C:  MOVF   47,W
1B8E:  MOVWF  00
1B90:  CLRF   47
1B92:  MOVLW  30
1B94:  ADDWF  00,F
1B96:  MOVFF  00,4F
1B9A:  RCALL  1A3A
1B9C:  BCF    FD8.1
1B9E:  MOVFF  4E,52
1BA2:  MOVFF  4D,51
1BA6:  MOVFF  4C,50
1BAA:  MOVFF  4B,4F
1BAE:  CLRF   56
1BB0:  CLRF   55
1BB2:  CLRF   54
1BB4:  MOVLW  0A
1BB6:  MOVWF  53
1BB8:  RCALL  19AC
1BBA:  MOVFF  03,4E
1BBE:  MOVFF  02,4D
1BC2:  MOVFF  01,4C
1BC6:  MOVFF  00,4B
1BCA:  DECFSZ 49,F
1BCC:  BRA    1AEC
1BCE:  GOTO   1CDC (RETURN)
....................  
.................... #list 
....................  
.................... #DEVICE ADC =10  // seleciona o conversor a/d com 10 bits 
.................... #INCLUDE <stdlib.h>   
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <math.h> //  Inclui a biblioteca responsavel por fornecer funções de calculos matematicos  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
09BA:  BCF    x6D.0
....................    y = x; 
09BC:  MOVFF  61,66
09C0:  MOVFF  60,65
09C4:  MOVFF  5F,64
09C8:  MOVFF  5E,63
....................  
....................    if (x < 0) 
09CC:  MOVFF  61,71
09D0:  MOVFF  60,70
09D4:  MOVFF  5F,6F
09D8:  MOVFF  5E,6E
09DC:  CLRF   x75
09DE:  CLRF   x74
09E0:  CLRF   x73
09E2:  CLRF   x72
09E4:  RCALL  0584
09E6:  BNC   09F0
....................    { 
....................       s = 1; 
09E8:  BSF    x6D.0
....................       y = -y; 
09EA:  MOVF   x64,W
09EC:  XORLW  80
09EE:  MOVWF  x64
....................    } 
....................  
....................    if (y <= 32768.0) 
09F0:  MOVFF  66,71
09F4:  MOVFF  65,70
09F8:  MOVFF  64,6F
09FC:  MOVFF  63,6E
0A00:  CLRF   x75
0A02:  CLRF   x74
0A04:  CLRF   x73
0A06:  MOVLW  8E
0A08:  MOVWF  x72
0A0A:  RCALL  0584
0A0C:  BC    0A10
0A0E:  BNZ   0A40
....................       res = (float32)(unsigned int16)y; 
0A10:  MOVFF  66,71
0A14:  MOVFF  65,70
0A18:  MOVFF  64,6F
0A1C:  MOVFF  63,6E
0A20:  RCALL  0982
0A22:  MOVFF  02,73
0A26:  MOVFF  01,72
0A2A:  CALL   0098
0A2E:  MOVFF  03,6A
0A32:  MOVFF  02,69
0A36:  MOVFF  01,68
0A3A:  MOVFF  00,67
0A3E:  BRA    0BCA
....................  
....................  else if (y < 10000000.0) 
0A40:  MOVFF  66,71
0A44:  MOVFF  65,70
0A48:  MOVFF  64,6F
0A4C:  MOVFF  63,6E
0A50:  MOVLW  80
0A52:  MOVWF  x75
0A54:  MOVLW  96
0A56:  MOVWF  x74
0A58:  MOVLW  18
0A5A:  MOVWF  x73
0A5C:  MOVLW  96
0A5E:  MOVWF  x72
0A60:  RCALL  0584
0A62:  BTFSS  FD8.0
0A64:  BRA    0BBA
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
0A66:  MOVFF  66,71
0A6A:  MOVFF  65,70
0A6E:  MOVFF  64,6F
0A72:  MOVFF  63,6E
0A76:  CLRF   x75
0A78:  CLRF   x74
0A7A:  CLRF   x73
0A7C:  MOVLW  70
0A7E:  MOVWF  x72
0A80:  CALL   00CE
0A84:  MOVFF  03,71
0A88:  MOVFF  02,70
0A8C:  MOVFF  01,6F
0A90:  MOVFF  00,6E
0A94:  RCALL  0982
0A96:  MOVFF  02,6C
0A9A:  MOVFF  01,6B
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
0A9E:  MOVFF  66,71
0AA2:  MOVFF  65,70
0AA6:  MOVFF  64,6F
0AAA:  MOVFF  63,6E
0AAE:  CLRF   x75
0AB0:  CLRF   x74
0AB2:  CLRF   x73
0AB4:  MOVLW  70
0AB6:  MOVWF  x72
0AB8:  CALL   00CE
0ABC:  MOVFF  03,71
0AC0:  MOVFF  02,70
0AC4:  MOVFF  01,6F
0AC8:  MOVFF  00,6E
0ACC:  MOVFF  6C,73
0AD0:  MOVFF  6B,72
0AD4:  CALL   0098
0AD8:  BSF    FD8.1
0ADA:  MOVFF  71,75
0ADE:  MOVFF  70,74
0AE2:  MOVFF  6F,73
0AE6:  MOVFF  6E,72
0AEA:  MOVFF  03,79
0AEE:  MOVFF  02,78
0AF2:  MOVFF  01,77
0AF6:  MOVFF  00,76
0AFA:  RCALL  031A
0AFC:  CLRF   x71
0AFE:  CLRF   x70
0B00:  CLRF   x6F
0B02:  MOVLW  8E
0B04:  MOVWF  x6E
0B06:  MOVFF  03,75
0B0A:  MOVFF  02,74
0B0E:  MOVFF  01,73
0B12:  MOVFF  00,72
0B16:  CALL   00CE
0B1A:  MOVFF  03,66
0B1E:  MOVFF  02,65
0B22:  MOVFF  01,64
0B26:  MOVFF  00,63
....................       res = 32768.0*(float32)l; 
0B2A:  MOVFF  6C,73
0B2E:  MOVFF  6B,72
0B32:  CALL   0098
0B36:  CLRF   x71
0B38:  CLRF   x70
0B3A:  CLRF   x6F
0B3C:  MOVLW  8E
0B3E:  MOVWF  x6E
0B40:  MOVFF  03,75
0B44:  MOVFF  02,74
0B48:  MOVFF  01,73
0B4C:  MOVFF  00,72
0B50:  CALL   00CE
0B54:  MOVFF  03,6A
0B58:  MOVFF  02,69
0B5C:  MOVFF  01,68
0B60:  MOVFF  00,67
....................       res += (float32)(unsigned int16)y; 
0B64:  MOVFF  66,71
0B68:  MOVFF  65,70
0B6C:  MOVFF  64,6F
0B70:  MOVFF  63,6E
0B74:  RCALL  0982
0B76:  MOVFF  02,73
0B7A:  MOVFF  01,72
0B7E:  CALL   0098
0B82:  BCF    FD8.1
0B84:  MOVFF  6A,75
0B88:  MOVFF  69,74
0B8C:  MOVFF  68,73
0B90:  MOVFF  67,72
0B94:  MOVFF  03,79
0B98:  MOVFF  02,78
0B9C:  MOVFF  01,77
0BA0:  MOVFF  00,76
0BA4:  CALL   031A
0BA8:  MOVFF  03,6A
0BAC:  MOVFF  02,69
0BB0:  MOVFF  01,68
0BB4:  MOVFF  00,67
....................    } 
0BB8:  BRA    0BCA
....................  
....................  else 
....................   res = y; 
0BBA:  MOVFF  66,6A
0BBE:  MOVFF  65,69
0BC2:  MOVFF  64,68
0BC6:  MOVFF  63,67
....................  
....................  y = y - (float32)(unsigned int16)y; 
0BCA:  MOVFF  66,71
0BCE:  MOVFF  65,70
0BD2:  MOVFF  64,6F
0BD6:  MOVFF  63,6E
0BDA:  RCALL  0982
0BDC:  MOVFF  02,73
0BE0:  MOVFF  01,72
0BE4:  CALL   0098
0BE8:  BSF    FD8.1
0BEA:  MOVFF  66,75
0BEE:  MOVFF  65,74
0BF2:  MOVFF  64,73
0BF6:  MOVFF  63,72
0BFA:  MOVFF  03,79
0BFE:  MOVFF  02,78
0C02:  MOVFF  01,77
0C06:  MOVFF  00,76
0C0A:  CALL   031A
0C0E:  MOVFF  03,66
0C12:  MOVFF  02,65
0C16:  MOVFF  01,64
0C1A:  MOVFF  00,63
....................  
....................  if (s) 
0C1E:  BTFSS  x6D.0
0C20:  BRA    0C28
....................   res = -res; 
0C22:  MOVF   x68,W
0C24:  XORLW  80
0C26:  MOVWF  x68
....................  
....................  if (y != 0) 
0C28:  MOVFF  66,71
0C2C:  MOVFF  65,70
0C30:  MOVFF  64,6F
0C34:  MOVFF  63,6E
0C38:  CLRF   x75
0C3A:  CLRF   x74
0C3C:  CLRF   x73
0C3E:  CLRF   x72
0C40:  RCALL  0584
0C42:  BZ    0CB4
....................  { 
....................   if (s == 1 && n == 0) 
0C44:  BTFSS  x6D.0
0C46:  BRA    0C7C
0C48:  MOVF   x62,F
0C4A:  BNZ   0C7C
....................    res -= 1.0; 
0C4C:  BSF    FD8.1
0C4E:  MOVFF  6A,75
0C52:  MOVFF  69,74
0C56:  MOVFF  68,73
0C5A:  MOVFF  67,72
0C5E:  CLRF   x79
0C60:  CLRF   x78
0C62:  CLRF   x77
0C64:  MOVLW  7F
0C66:  MOVWF  x76
0C68:  CALL   031A
0C6C:  MOVFF  03,6A
0C70:  MOVFF  02,69
0C74:  MOVFF  01,68
0C78:  MOVFF  00,67
....................  
....................   if (s == 0 && n == 1) 
0C7C:  BTFSC  x6D.0
0C7E:  BRA    0CB4
0C80:  DECFSZ x62,W
0C82:  BRA    0CB4
....................    res += 1.0; 
0C84:  BCF    FD8.1
0C86:  MOVFF  6A,75
0C8A:  MOVFF  69,74
0C8E:  MOVFF  68,73
0C92:  MOVFF  67,72
0C96:  CLRF   x79
0C98:  CLRF   x78
0C9A:  CLRF   x77
0C9C:  MOVLW  7F
0C9E:  MOVWF  x76
0CA0:  CALL   031A
0CA4:  MOVFF  03,6A
0CA8:  MOVFF  02,69
0CAC:  MOVFF  01,68
0CB0:  MOVFF  00,67
....................  } 
....................  if (x == 0) 
0CB4:  MOVFF  61,71
0CB8:  MOVFF  60,70
0CBC:  MOVFF  5F,6F
0CC0:  MOVFF  5E,6E
0CC4:  CLRF   x75
0CC6:  CLRF   x74
0CC8:  CLRF   x73
0CCA:  CLRF   x72
0CCC:  RCALL  0584
0CCE:  BNZ   0CD8
....................     res = 0; 
0CD0:  CLRF   x6A
0CD2:  CLRF   x69
0CD4:  CLRF   x68
0CD6:  CLRF   x67
....................  
....................  return (res); 
0CD8:  MOVFF  67,00
0CDC:  MOVFF  68,01
0CE0:  MOVFF  69,02
0CE4:  MOVFF  6A,03
0CE8:  RETURN 0
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
*
0D04:  MOVFF  5D,61
0D08:  MOVFF  5C,60
0D0C:  MOVFF  5B,5F
0D10:  MOVFF  5A,5E
0D14:  CLRF   x62
0D16:  RCALL  09BA
0D18:  GOTO   0E1A (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
0CEA:  MOVFF  5D,61
0CEE:  MOVFF  5C,60
0CF2:  MOVFF  5B,5F
0CF6:  MOVFF  5A,5E
0CFA:  MOVLW  01
0CFC:  MOVWF  x62
0CFE:  RCALL  09BA
0D00:  GOTO   0DD2 (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
*
0D1C:  MOVFF  51,71
0D20:  MOVFF  50,70
0D24:  MOVFF  4F,6F
0D28:  MOVFF  4E,6E
0D2C:  CLRF   x75
0D2E:  CLRF   x74
0D30:  CLRF   x73
0D32:  CLRF   x72
0D34:  RCALL  0584
0D36:  BTFSC  FD8.2
0D38:  BRA    0E76
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
0D3A:  MOVFF  4D,6A
0D3E:  MOVFF  4C,69
0D42:  MOVFF  4B,68
0D46:  MOVFF  4A,67
0D4A:  MOVFF  51,6E
0D4E:  MOVFF  50,6D
0D52:  MOVFF  4F,6C
0D56:  MOVFF  4E,6B
0D5A:  CALL   01C0
0D5E:  MOVFF  03,59
0D62:  MOVFF  02,58
0D66:  MOVFF  01,57
0D6A:  MOVFF  00,56
0D6E:  MOVFF  03,71
0D72:  MOVFF  02,70
0D76:  MOVFF  01,6F
0D7A:  MOVFF  00,6E
0D7E:  CLRF   x75
0D80:  CLRF   x74
0D82:  CLRF   x73
0D84:  CLRF   x72
0D86:  CALL   0584
0D8A:  BNC   0DD4
0D8C:  MOVFF  4D,6A
0D90:  MOVFF  4C,69
0D94:  MOVFF  4B,68
0D98:  MOVFF  4A,67
0D9C:  MOVFF  51,6E
0DA0:  MOVFF  50,6D
0DA4:  MOVFF  4F,6C
0DA8:  MOVFF  4E,6B
0DAC:  CALL   01C0
0DB0:  MOVFF  03,59
0DB4:  MOVFF  02,58
0DB8:  MOVFF  01,57
0DBC:  MOVFF  00,56
0DC0:  MOVFF  03,5D
0DC4:  MOVFF  02,5C
0DC8:  MOVFF  01,5B
0DCC:  MOVFF  00,5A
0DD0:  BRA    0CEA
0DD2:  BRA    0E1A
0DD4:  MOVFF  4D,6A
0DD8:  MOVFF  4C,69
0DDC:  MOVFF  4B,68
0DE0:  MOVFF  4A,67
0DE4:  MOVFF  51,6E
0DE8:  MOVFF  50,6D
0DEC:  MOVFF  4F,6C
0DF0:  MOVFF  4E,6B
0DF4:  CALL   01C0
0DF8:  MOVFF  03,59
0DFC:  MOVFF  02,58
0E00:  MOVFF  01,57
0E04:  MOVFF  00,56
0E08:  MOVFF  03,5D
0E0C:  MOVFF  02,5C
0E10:  MOVFF  01,5B
0E14:  MOVFF  00,5A
0E18:  BRA    0D04
0E1A:  MOVFF  03,55
0E1E:  MOVFF  02,54
0E22:  MOVFF  01,53
0E26:  MOVFF  00,52
....................       return(x-(i*y)); 
0E2A:  MOVFF  55,71
0E2E:  MOVFF  54,70
0E32:  MOVFF  53,6F
0E36:  MOVFF  52,6E
0E3A:  MOVFF  51,75
0E3E:  MOVFF  50,74
0E42:  MOVFF  4F,73
0E46:  MOVFF  4E,72
0E4A:  CALL   00CE
0E4E:  BSF    FD8.1
0E50:  MOVFF  4D,75
0E54:  MOVFF  4C,74
0E58:  MOVFF  4B,73
0E5C:  MOVFF  4A,72
0E60:  MOVFF  03,79
0E64:  MOVFF  02,78
0E68:  MOVFF  01,77
0E6C:  MOVFF  00,76
0E70:  CALL   031A
0E74:  BRA    0E76
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
0E76:  RETURN 0
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
0E78:  MOVFF  51,71
0E7C:  MOVFF  50,70
0E80:  MOVFF  4F,6F
0E84:  MOVFF  4E,6E
0E88:  MOVLW  3B
0E8A:  MOVWF  x75
0E8C:  MOVLW  AA
0E8E:  MOVWF  x74
0E90:  MOVLW  38
0E92:  MOVWF  x73
0E94:  MOVLW  7F
0E96:  MOVWF  x72
0E98:  CALL   00CE
0E9C:  MOVFF  03,71
0EA0:  MOVFF  02,70
0EA4:  MOVFF  01,6F
0EA8:  MOVFF  00,6E
0EAC:  RCALL  0982
0EAE:  MOVFF  01,5E
....................    s = 0; 
0EB2:  BCF    5F.0
....................    y = x; 
0EB4:  MOVFF  51,55
0EB8:  MOVFF  50,54
0EBC:  MOVFF  4F,53
0EC0:  MOVFF  4E,52
....................  
....................    if (x < 0) 
0EC4:  MOVFF  51,71
0EC8:  MOVFF  50,70
0ECC:  MOVFF  4F,6F
0ED0:  MOVFF  4E,6E
0ED4:  CLRF   x75
0ED6:  CLRF   x74
0ED8:  CLRF   x73
0EDA:  CLRF   x72
0EDC:  CALL   0584
0EE0:  BNC   0EEC
....................    { 
....................       s = 1; 
0EE2:  BSF    5F.0
....................       n = -n; 
0EE4:  NEGF   5E
....................       y = -y; 
0EE6:  MOVF   53,W
0EE8:  XORLW  80
0EEA:  MOVWF  53
....................    } 
....................  
....................    res = 0.0; 
0EEC:  CLRF   59
0EEE:  CLRF   58
0EF0:  CLRF   57
0EF2:  CLRF   56
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
0EF4:  CLRF   x61
0EF6:  MOVLW  56
0EF8:  MOVWF  FE9
0EFA:  MOVFF  61,FEA
0EFE:  MOVLW  7F
0F00:  ADDWF  5E,W
0F02:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
0F04:  MOVFF  55,71
0F08:  MOVFF  54,70
0F0C:  MOVFF  53,6F
0F10:  MOVFF  52,6E
0F14:  MOVLW  3B
0F16:  MOVWF  x75
0F18:  MOVLW  AA
0F1A:  MOVWF  x74
0F1C:  MOVLW  38
0F1E:  MOVWF  x73
0F20:  MOVLW  7F
0F22:  MOVWF  x72
0F24:  CALL   00CE
0F28:  MOVFF  03,63
0F2C:  MOVFF  02,62
0F30:  MOVFF  01,61
0F34:  MOVFF  00,60
0F38:  CLRF   x65
0F3A:  MOVFF  5E,64
0F3E:  BTFSC  x64.7
0F40:  DECF   x65,F
0F42:  CALL   05FA
0F46:  BSF    FD8.1
0F48:  MOVFF  63,75
0F4C:  MOVFF  62,74
0F50:  MOVFF  61,73
0F54:  MOVFF  60,72
0F58:  MOVFF  03,79
0F5C:  MOVFF  02,78
0F60:  MOVFF  01,77
0F64:  MOVFF  00,76
0F68:  CALL   031A
0F6C:  MOVFF  03,55
0F70:  MOVFF  02,54
0F74:  MOVFF  01,53
0F78:  MOVFF  00,52
....................  
....................    r = pe[0]*y + pe[1]; 
0F7C:  MOVLW  7C
0F7E:  MOVWF  x71
0F80:  MOVLW  88
0F82:  MOVWF  x70
0F84:  MOVLW  59
0F86:  MOVWF  x6F
0F88:  MOVLW  72
0F8A:  MOVWF  x6E
0F8C:  MOVFF  55,75
0F90:  MOVFF  54,74
0F94:  MOVFF  53,73
0F98:  MOVFF  52,72
0F9C:  CALL   00CE
0FA0:  MOVFF  03,63
0FA4:  MOVFF  02,62
0FA8:  MOVFF  01,61
0FAC:  MOVFF  00,60
0FB0:  BCF    FD8.1
0FB2:  MOVFF  03,75
0FB6:  MOVFF  02,74
0FBA:  MOVFF  01,73
0FBE:  MOVFF  00,72
0FC2:  MOVLW  E0
0FC4:  MOVWF  x79
0FC6:  MOVLW  97
0FC8:  MOVWF  x78
0FCA:  MOVLW  26
0FCC:  MOVWF  x77
0FCE:  MOVLW  75
0FD0:  MOVWF  x76
0FD2:  CALL   031A
0FD6:  MOVFF  03,5D
0FDA:  MOVFF  02,5C
0FDE:  MOVFF  01,5B
0FE2:  MOVFF  00,5A
....................    r = r*y + pe[2]; 
0FE6:  MOVFF  5D,71
0FEA:  MOVFF  5C,70
0FEE:  MOVFF  5B,6F
0FF2:  MOVFF  5A,6E
0FF6:  MOVFF  55,75
0FFA:  MOVFF  54,74
0FFE:  MOVFF  53,73
1002:  MOVFF  52,72
1006:  CALL   00CE
100A:  MOVFF  03,63
100E:  MOVFF  02,62
1012:  MOVFF  01,61
1016:  MOVFF  00,60
101A:  BCF    FD8.1
101C:  MOVFF  03,75
1020:  MOVFF  02,74
1024:  MOVFF  01,73
1028:  MOVFF  00,72
102C:  MOVLW  C4
102E:  MOVWF  x79
1030:  MOVLW  1D
1032:  MOVWF  x78
1034:  MOVLW  1E
1036:  MOVWF  x77
1038:  MOVLW  78
103A:  MOVWF  x76
103C:  CALL   031A
1040:  MOVFF  03,5D
1044:  MOVFF  02,5C
1048:  MOVFF  01,5B
104C:  MOVFF  00,5A
....................    r = r*y + pe[3]; 
1050:  MOVFF  5D,71
1054:  MOVFF  5C,70
1058:  MOVFF  5B,6F
105C:  MOVFF  5A,6E
1060:  MOVFF  55,75
1064:  MOVFF  54,74
1068:  MOVFF  53,73
106C:  MOVFF  52,72
1070:  CALL   00CE
1074:  MOVFF  03,63
1078:  MOVFF  02,62
107C:  MOVFF  01,61
1080:  MOVFF  00,60
1084:  BCF    FD8.1
1086:  MOVFF  03,75
108A:  MOVFF  02,74
108E:  MOVFF  01,73
1092:  MOVFF  00,72
1096:  MOVLW  5E
1098:  MOVWF  x79
109A:  MOVLW  50
109C:  MOVWF  x78
109E:  MOVLW  63
10A0:  MOVWF  x77
10A2:  MOVLW  7A
10A4:  MOVWF  x76
10A6:  CALL   031A
10AA:  MOVFF  03,5D
10AE:  MOVFF  02,5C
10B2:  MOVFF  01,5B
10B6:  MOVFF  00,5A
....................    r = r*y + pe[4]; 
10BA:  MOVFF  5D,71
10BE:  MOVFF  5C,70
10C2:  MOVFF  5B,6F
10C6:  MOVFF  5A,6E
10CA:  MOVFF  55,75
10CE:  MOVFF  54,74
10D2:  MOVFF  53,73
10D6:  MOVFF  52,72
10DA:  CALL   00CE
10DE:  MOVFF  03,63
10E2:  MOVFF  02,62
10E6:  MOVFF  01,61
10EA:  MOVFF  00,60
10EE:  BCF    FD8.1
10F0:  MOVFF  03,75
10F4:  MOVFF  02,74
10F8:  MOVFF  01,73
10FC:  MOVFF  00,72
1100:  MOVLW  1A
1102:  MOVWF  x79
1104:  MOVLW  FE
1106:  MOVWF  x78
1108:  MOVLW  75
110A:  MOVWF  x77
110C:  MOVLW  7C
110E:  MOVWF  x76
1110:  CALL   031A
1114:  MOVFF  03,5D
1118:  MOVFF  02,5C
111C:  MOVFF  01,5B
1120:  MOVFF  00,5A
....................    r = r*y + pe[5]; 
1124:  MOVFF  5D,71
1128:  MOVFF  5C,70
112C:  MOVFF  5B,6F
1130:  MOVFF  5A,6E
1134:  MOVFF  55,75
1138:  MOVFF  54,74
113C:  MOVFF  53,73
1140:  MOVFF  52,72
1144:  CALL   00CE
1148:  MOVFF  03,63
114C:  MOVFF  02,62
1150:  MOVFF  01,61
1154:  MOVFF  00,60
1158:  BCF    FD8.1
115A:  MOVFF  03,75
115E:  MOVFF  02,74
1162:  MOVFF  01,73
1166:  MOVFF  00,72
116A:  MOVLW  18
116C:  MOVWF  x79
116E:  MOVLW  72
1170:  MOVWF  x78
1172:  MOVLW  31
1174:  MOVWF  x77
1176:  MOVLW  7E
1178:  MOVWF  x76
117A:  CALL   031A
117E:  MOVFF  03,5D
1182:  MOVFF  02,5C
1186:  MOVFF  01,5B
118A:  MOVFF  00,5A
....................  
....................    res = res*(1.0 + y*r); 
118E:  MOVFF  55,71
1192:  MOVFF  54,70
1196:  MOVFF  53,6F
119A:  MOVFF  52,6E
119E:  MOVFF  5D,75
11A2:  MOVFF  5C,74
11A6:  MOVFF  5B,73
11AA:  MOVFF  5A,72
11AE:  CALL   00CE
11B2:  BCF    FD8.1
11B4:  CLRF   x75
11B6:  CLRF   x74
11B8:  CLRF   x73
11BA:  MOVLW  7F
11BC:  MOVWF  x72
11BE:  MOVFF  03,79
11C2:  MOVFF  02,78
11C6:  MOVFF  01,77
11CA:  MOVFF  00,76
11CE:  CALL   031A
11D2:  MOVFF  59,71
11D6:  MOVFF  58,70
11DA:  MOVFF  57,6F
11DE:  MOVFF  56,6E
11E2:  MOVFF  03,75
11E6:  MOVFF  02,74
11EA:  MOVFF  01,73
11EE:  MOVFF  00,72
11F2:  CALL   00CE
11F6:  MOVFF  03,59
11FA:  MOVFF  02,58
11FE:  MOVFF  01,57
1202:  MOVFF  00,56
....................  
....................    if (s) 
1206:  BTFSS  5F.0
1208:  BRA    1238
....................       res = 1.0/res; 
120A:  CLRF   x6A
120C:  CLRF   x69
120E:  CLRF   x68
1210:  MOVLW  7F
1212:  MOVWF  x67
1214:  MOVFF  59,6E
1218:  MOVFF  58,6D
121C:  MOVFF  57,6C
1220:  MOVFF  56,6B
1224:  CALL   01C0
1228:  MOVFF  03,59
122C:  MOVFF  02,58
1230:  MOVFF  01,57
1234:  MOVFF  00,56
....................    return(res); 
1238:  MOVFF  56,00
123C:  MOVFF  57,01
1240:  MOVFF  58,02
1244:  MOVFF  59,03
1248:  RETURN 0
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
*
0642:  MOVFF  51,55
0646:  MOVFF  50,54
064A:  MOVFF  4F,53
064E:  MOVFF  4E,52
....................  
....................    if (y != 1.0) 
0652:  MOVFF  55,71
0656:  MOVFF  54,70
065A:  MOVFF  53,6F
065E:  MOVFF  52,6E
0662:  CLRF   x75
0664:  CLRF   x74
0666:  CLRF   x73
0668:  MOVLW  7F
066A:  MOVWF  x72
066C:  RCALL  0584
066E:  BTFSC  FD8.2
0670:  BRA    0968
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
0672:  CLRF   x64
0674:  MOVLW  52
0676:  MOVWF  FE9
0678:  MOVFF  64,FEA
067C:  MOVLW  7E
067E:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
0680:  BSF    FD8.1
0682:  MOVFF  55,75
0686:  MOVFF  54,74
068A:  MOVFF  53,73
068E:  MOVFF  52,72
0692:  CLRF   x79
0694:  CLRF   x78
0696:  CLRF   x77
0698:  MOVLW  7F
069A:  MOVWF  x76
069C:  RCALL  031A
069E:  MOVFF  03,66
06A2:  MOVFF  02,65
06A6:  MOVFF  01,64
06AA:  MOVFF  00,63
06AE:  BCF    FD8.1
06B0:  MOVFF  55,75
06B4:  MOVFF  54,74
06B8:  MOVFF  53,73
06BC:  MOVFF  52,72
06C0:  CLRF   x79
06C2:  CLRF   x78
06C4:  CLRF   x77
06C6:  MOVLW  7F
06C8:  MOVWF  x76
06CA:  RCALL  031A
06CC:  MOVFF  66,6A
06D0:  MOVFF  65,69
06D4:  MOVFF  64,68
06D8:  MOVFF  63,67
06DC:  MOVFF  03,6E
06E0:  MOVFF  02,6D
06E4:  MOVFF  01,6C
06E8:  MOVFF  00,6B
06EC:  RCALL  01C0
06EE:  MOVFF  03,55
06F2:  MOVFF  02,54
06F6:  MOVFF  01,53
06FA:  MOVFF  00,52
....................  
....................       y2=y*y; 
06FE:  MOVFF  55,71
0702:  MOVFF  54,70
0706:  MOVFF  53,6F
070A:  MOVFF  52,6E
070E:  MOVFF  55,75
0712:  MOVFF  54,74
0716:  MOVFF  53,73
071A:  MOVFF  52,72
071E:  RCALL  00CE
0720:  MOVFF  03,61
0724:  MOVFF  02,60
0728:  MOVFF  01,5F
072C:  MOVFF  00,5E
....................  
....................       res = pl[0]*y2 + pl[1]; 
0730:  MOVLW  99
0732:  MOVWF  x71
0734:  MOVLW  47
0736:  MOVWF  x70
0738:  MOVLW  8A
073A:  MOVWF  x6F
073C:  MOVLW  7F
073E:  MOVWF  x6E
0740:  MOVFF  61,75
0744:  MOVFF  60,74
0748:  MOVFF  5F,73
074C:  MOVFF  5E,72
0750:  RCALL  00CE
0752:  MOVFF  03,66
0756:  MOVFF  02,65
075A:  MOVFF  01,64
075E:  MOVFF  00,63
0762:  BCF    FD8.1
0764:  MOVFF  03,75
0768:  MOVFF  02,74
076C:  MOVFF  01,73
0770:  MOVFF  00,72
0774:  CLRF   x79
0776:  CLRF   x78
0778:  CLRF   x77
077A:  MOVLW  80
077C:  MOVWF  x76
077E:  RCALL  031A
0780:  MOVFF  03,59
0784:  MOVFF  02,58
0788:  MOVFF  01,57
078C:  MOVFF  00,56
....................  
....................       r = ql[0]*y2 + ql[1]; 
0790:  MOVLW  4C
0792:  MOVWF  x71
0794:  MOVLW  F3
0796:  MOVWF  x70
0798:  MOVLW  3A
079A:  MOVWF  x6F
079C:  MOVLW  7B
079E:  MOVWF  x6E
07A0:  MOVFF  61,75
07A4:  MOVFF  60,74
07A8:  MOVFF  5F,73
07AC:  MOVFF  5E,72
07B0:  RCALL  00CE
07B2:  MOVFF  03,66
07B6:  MOVFF  02,65
07BA:  MOVFF  01,64
07BE:  MOVFF  00,63
07C2:  BCF    FD8.1
07C4:  MOVFF  03,75
07C8:  MOVFF  02,74
07CC:  MOVFF  01,73
07D0:  MOVFF  00,72
07D4:  MOVLW  2B
07D6:  MOVWF  x79
07D8:  MOVLW  9D
07DA:  MOVWF  x78
07DC:  MOVLW  DF
07DE:  MOVWF  x77
07E0:  MOVLW  7E
07E2:  MOVWF  x76
07E4:  RCALL  031A
07E6:  MOVFF  03,5D
07EA:  MOVFF  02,5C
07EE:  MOVFF  01,5B
07F2:  MOVFF  00,5A
....................       r = r*y2 + 1.0; 
07F6:  MOVFF  5D,71
07FA:  MOVFF  5C,70
07FE:  MOVFF  5B,6F
0802:  MOVFF  5A,6E
0806:  MOVFF  61,75
080A:  MOVFF  60,74
080E:  MOVFF  5F,73
0812:  MOVFF  5E,72
0816:  RCALL  00CE
0818:  MOVFF  03,66
081C:  MOVFF  02,65
0820:  MOVFF  01,64
0824:  MOVFF  00,63
0828:  BCF    FD8.1
082A:  MOVFF  03,75
082E:  MOVFF  02,74
0832:  MOVFF  01,73
0836:  MOVFF  00,72
083A:  CLRF   x79
083C:  CLRF   x78
083E:  CLRF   x77
0840:  MOVLW  7F
0842:  MOVWF  x76
0844:  RCALL  031A
0846:  MOVFF  03,5D
084A:  MOVFF  02,5C
084E:  MOVFF  01,5B
0852:  MOVFF  00,5A
....................  
....................       res = y*res/r; 
0856:  MOVFF  55,71
085A:  MOVFF  54,70
085E:  MOVFF  53,6F
0862:  MOVFF  52,6E
0866:  MOVFF  59,75
086A:  MOVFF  58,74
086E:  MOVFF  57,73
0872:  MOVFF  56,72
0876:  RCALL  00CE
0878:  MOVFF  03,66
087C:  MOVFF  02,65
0880:  MOVFF  01,64
0884:  MOVFF  00,63
0888:  MOVFF  03,6A
088C:  MOVFF  02,69
0890:  MOVFF  01,68
0894:  MOVFF  00,67
0898:  MOVFF  5D,6E
089C:  MOVFF  5C,6D
08A0:  MOVFF  5B,6C
08A4:  MOVFF  5A,6B
08A8:  RCALL  01C0
08AA:  MOVFF  03,59
08AE:  MOVFF  02,58
08B2:  MOVFF  01,57
08B6:  MOVFF  00,56
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
08BA:  CLRF   x64
08BC:  MOVLW  4E
08BE:  MOVWF  FE9
08C0:  MOVFF  64,FEA
08C4:  MOVLW  7E
08C6:  SUBWF  FEF,W
08C8:  MOVWF  x62
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
08CA:  BTFSS  x62.7
08CC:  BRA    08F2
....................          r = -(float32)-n; 
08CE:  MOVLW  00
08D0:  BSF    FD8.0
08D2:  SUBFWB x62,W
08D4:  CLRF   x65
08D6:  MOVWF  x64
08D8:  BTFSC  x64.7
08DA:  DECF   x65,F
08DC:  RCALL  05FA
08DE:  MOVFF  00,5A
08E2:  MOVF   01,W
08E4:  XORLW  80
08E6:  MOVWF  5B
08E8:  MOVFF  02,5C
08EC:  MOVFF  03,5D
08F0:  BRA    090E
....................       else 
....................          r = (float32)n; 
08F2:  CLRF   x65
08F4:  MOVFF  62,64
08F8:  BTFSC  x64.7
08FA:  DECF   x65,F
08FC:  RCALL  05FA
08FE:  MOVFF  03,5D
0902:  MOVFF  02,5C
0906:  MOVFF  01,5B
090A:  MOVFF  00,5A
....................  
....................       res += r*LN2; 
090E:  MOVFF  5D,71
0912:  MOVFF  5C,70
0916:  MOVFF  5B,6F
091A:  MOVFF  5A,6E
091E:  MOVLW  18
0920:  MOVWF  x75
0922:  MOVLW  72
0924:  MOVWF  x74
0926:  MOVLW  31
0928:  MOVWF  x73
092A:  MOVLW  7E
092C:  MOVWF  x72
092E:  CALL   00CE
0932:  BCF    FD8.1
0934:  MOVFF  59,75
0938:  MOVFF  58,74
093C:  MOVFF  57,73
0940:  MOVFF  56,72
0944:  MOVFF  03,79
0948:  MOVFF  02,78
094C:  MOVFF  01,77
0950:  MOVFF  00,76
0954:  RCALL  031A
0956:  MOVFF  03,59
095A:  MOVFF  02,58
095E:  MOVFF  01,57
0962:  MOVFF  00,56
....................    } 
0966:  BRA    0970
....................  
....................    else 
....................       res = 0.0; 
0968:  CLRF   59
096A:  CLRF   58
096C:  CLRF   57
096E:  CLRF   56
....................  
....................    return(res); 
0970:  MOVFF  56,00
0974:  MOVFF  57,01
0978:  MOVFF  58,02
097C:  MOVFF  59,03
0980:  RETURN 0
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
*
124A:  MOVFF  45,71
124E:  MOVFF  44,70
1252:  MOVFF  43,6F
1256:  MOVFF  42,6E
125A:  CLRF   x75
125C:  CLRF   x74
125E:  CLRF   x73
1260:  CLRF   x72
1262:  CALL   0584
1266:  BTFSS  FD8.0
1268:  BRA    1400
126A:  MOVFF  49,4D
126E:  MOVFF  48,4C
1272:  MOVFF  47,4B
1276:  MOVFF  46,4A
127A:  CLRF   51
127C:  CLRF   50
127E:  CLRF   4F
1280:  MOVLW  7F
1282:  MOVWF  4E
1284:  RCALL  0D1C
1286:  MOVFF  03,4D
128A:  MOVFF  02,4C
128E:  MOVFF  01,4B
1292:  MOVFF  00,4A
1296:  MOVFF  03,71
129A:  MOVFF  02,70
129E:  MOVFF  01,6F
12A2:  MOVFF  00,6E
12A6:  CLRF   x75
12A8:  CLRF   x74
12AA:  CLRF   x73
12AC:  CLRF   x72
12AE:  CALL   0584
12B2:  BTFSS  FD8.2
12B4:  BRA    1400
....................       if(fmod(y, 2) == 0) { 
12B6:  MOVFF  49,4D
12BA:  MOVFF  48,4C
12BE:  MOVFF  47,4B
12C2:  MOVFF  46,4A
12C6:  CLRF   51
12C8:  CLRF   50
12CA:  CLRF   4F
12CC:  MOVLW  80
12CE:  MOVWF  4E
12D0:  RCALL  0D1C
12D2:  MOVFF  03,4D
12D6:  MOVFF  02,4C
12DA:  MOVFF  01,4B
12DE:  MOVFF  00,4A
12E2:  MOVFF  03,71
12E6:  MOVFF  02,70
12EA:  MOVFF  01,6F
12EE:  MOVFF  00,6E
12F2:  CLRF   x75
12F4:  CLRF   x74
12F6:  CLRF   x73
12F8:  CLRF   x72
12FA:  CALL   0584
12FE:  BNZ   137E
....................          return (exp(log(-x) * y)); 
1300:  MOVFF  42,4A
1304:  MOVF   43,W
1306:  XORLW  80
1308:  MOVWF  4B
130A:  MOVFF  44,4C
130E:  MOVFF  45,4D
1312:  MOVFF  45,51
1316:  MOVFF  44,50
131A:  MOVWF  4F
131C:  MOVFF  42,4E
1320:  CALL   0642
1324:  MOVFF  03,4D
1328:  MOVFF  02,4C
132C:  MOVFF  01,4B
1330:  MOVFF  00,4A
1334:  MOVFF  03,71
1338:  MOVFF  02,70
133C:  MOVFF  01,6F
1340:  MOVFF  00,6E
1344:  MOVFF  49,75
1348:  MOVFF  48,74
134C:  MOVFF  47,73
1350:  MOVFF  46,72
1354:  CALL   00CE
1358:  MOVFF  03,4D
135C:  MOVFF  02,4C
1360:  MOVFF  01,4B
1364:  MOVFF  00,4A
1368:  MOVFF  03,51
136C:  MOVFF  02,50
1370:  MOVFF  01,4F
1374:  MOVFF  00,4E
1378:  RCALL  0E78
137A:  BRA    151C
....................       } else { 
137C:  BRA    13FE
....................          return (-exp(log(-x) * y)); 
137E:  MOVFF  42,4A
1382:  MOVF   43,W
1384:  XORLW  80
1386:  MOVWF  4B
1388:  MOVFF  44,4C
138C:  MOVFF  45,4D
1390:  MOVFF  45,51
1394:  MOVFF  44,50
1398:  MOVWF  4F
139A:  MOVFF  42,4E
139E:  CALL   0642
13A2:  MOVFF  03,4D
13A6:  MOVFF  02,4C
13AA:  MOVFF  01,4B
13AE:  MOVFF  00,4A
13B2:  MOVFF  03,71
13B6:  MOVFF  02,70
13BA:  MOVFF  01,6F
13BE:  MOVFF  00,6E
13C2:  MOVFF  49,75
13C6:  MOVFF  48,74
13CA:  MOVFF  47,73
13CE:  MOVFF  46,72
13D2:  CALL   00CE
13D6:  MOVFF  03,4D
13DA:  MOVFF  02,4C
13DE:  MOVFF  01,4B
13E2:  MOVFF  00,4A
13E6:  MOVFF  03,51
13EA:  MOVFF  02,50
13EE:  MOVFF  01,4F
13F2:  MOVFF  00,4E
13F6:  RCALL  0E78
13F8:  MOVLW  80
13FA:  XORWF  01,F
13FC:  BRA    151C
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
13FE:  BRA    151C
1400:  MOVFF  45,71
1404:  MOVFF  44,70
1408:  MOVFF  43,6F
140C:  MOVFF  42,6E
1410:  CLRF   x75
1412:  CLRF   x74
1414:  CLRF   x73
1416:  CLRF   x72
1418:  CALL   0584
141C:  BNC   1474
141E:  MOVFF  49,4D
1422:  MOVFF  48,4C
1426:  MOVFF  47,4B
142A:  MOVFF  46,4A
142E:  CLRF   51
1430:  CLRF   50
1432:  CLRF   4F
1434:  MOVLW  7F
1436:  MOVWF  4E
1438:  RCALL  0D1C
143A:  MOVFF  03,4D
143E:  MOVFF  02,4C
1442:  MOVFF  01,4B
1446:  MOVFF  00,4A
144A:  MOVFF  03,71
144E:  MOVFF  02,70
1452:  MOVFF  01,6F
1456:  MOVFF  00,6E
145A:  CLRF   x75
145C:  CLRF   x74
145E:  CLRF   x73
1460:  CLRF   x72
1462:  CALL   0584
1466:  BZ    1474
....................       return 0; 
1468:  CLRF   00
146A:  CLRF   01
146C:  CLRF   02
146E:  CLRF   03
1470:  BRA    151C
....................    } else { 
1472:  BRA    151C
....................       if(x != 0 || 0 >= y) { 
1474:  MOVFF  45,71
1478:  MOVFF  44,70
147C:  MOVFF  43,6F
1480:  MOVFF  42,6E
1484:  CLRF   x75
1486:  CLRF   x74
1488:  CLRF   x73
148A:  CLRF   x72
148C:  CALL   0584
1490:  BNZ   14B2
1492:  MOVFF  49,71
1496:  MOVFF  48,70
149A:  MOVFF  47,6F
149E:  MOVFF  46,6E
14A2:  CLRF   x75
14A4:  CLRF   x74
14A6:  CLRF   x73
14A8:  CLRF   x72
14AA:  CALL   0584
14AE:  BC    14B2
14B0:  BNZ   151C
....................          return (exp(log(x) * y)); 
14B2:  MOVFF  45,51
14B6:  MOVFF  44,50
14BA:  MOVFF  43,4F
14BE:  MOVFF  42,4E
14C2:  CALL   0642
14C6:  MOVFF  03,4D
14CA:  MOVFF  02,4C
14CE:  MOVFF  01,4B
14D2:  MOVFF  00,4A
14D6:  MOVFF  03,71
14DA:  MOVFF  02,70
14DE:  MOVFF  01,6F
14E2:  MOVFF  00,6E
14E6:  MOVFF  49,75
14EA:  MOVFF  48,74
14EE:  MOVFF  47,73
14F2:  MOVFF  46,72
14F6:  CALL   00CE
14FA:  MOVFF  03,4D
14FE:  MOVFF  02,4C
1502:  MOVFF  01,4B
1506:  MOVFF  00,4A
150A:  MOVFF  03,51
150E:  MOVFF  02,50
1512:  MOVFF  01,4F
1516:  MOVFF  00,4E
151A:  RCALL  0E78
....................       } 
....................    } 
151C:  GOTO   16C4 (RETURN)
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #fuses HS,NOWDT,PUT,NOBROWNOUT,NOLVP   // configuração dos fuses do pic  
.................... #use   delay(clock=20000000)// Informa a função delay, o clock utilizado 
*
0028:  CLRF   FEA
002A:  MOVLW  43
002C:  MOVWF  FE9
002E:  MOVF   FEF,W
0030:  BZ    004C
0032:  MOVLW  06
0034:  MOVWF  01
0036:  CLRF   00
0038:  DECFSZ 00,F
003A:  BRA    0038
003C:  DECFSZ 01,F
003E:  BRA    0036
0040:  MOVLW  7B
0042:  MOVWF  00
0044:  DECFSZ 00,F
0046:  BRA    0044
0048:  DECFSZ FEF,F
004A:  BRA    0032
004C:  RETURN 0
.................... #BIT Data_Pin = 0x06.7                       // Pin mapped to PORTB.7 
.................... #BIT Data_Pin_Direction = 0x86.7             // Pin direction mapped to TRISB.7 
.................... #use   fast_io(a)//modo rápido de inicialização das portas 
.................... #use   fast_io(b)//modo rápido de inicialização das portas 
.................... #use   fast_io(d)//modo rápido de inicialização das portas 
.................... #use   fast_io(e)//modo rápido de inicialização das portas 
....................  
.................... #byte   porta = 0xf80 // atribui o nome "porta" ao registrador do port 0xf80 
.................... #byte   portb = 0xf81  
.................... #byte   portd = 0xf83 
.................... #byte   porte = 0xf84 
.................... #byte   portc = 0xf82 
.................... // pinos de entrada e saida  
.................... #bit NTC = porta.0    //  Pino de leitura do NTC  
.................... #bit PIN_COOLER = portc.0  //  Pino de leitura do DHT11 
.................... #bit POT_SET_TEMP = porta.1 //Pino de leitura do potenciometro de set da temperatura  
.................... #bit POT_SET_UMI = porta.2 //Pino de leitura do potenciometro de set da umidade  
.................... #bit BOT_BLK_LTH = portb.0 // Pino do botao paraligar a luz do lcd 
.................... #bit BOT_MORE_INF = portb.1 // botao para mais informaçoes no lcd 
.................... // pinos de saida 
.................... #bit PIN_SERV = portb.3 
.................... #bit RELE_LAMP = portb.2  //  pino que acionamento do relé da lampada/aquecedor 
.................... #bit DHT11 = portb.7 // Pino de acionamento do cooler via transistor  
.................... #bit rs =porte.0 //  via do lcd que sinaliza recepção de dados ou comando  
.................... #bit enable = porte.1 // habilita o lcd 
.................... #byte DISPLAY = portd //  seleciona o port no qual o lcd esta ligado ( o mesmo valor que esta no arquivo.h) 
.................... #INCLUDE <lcd.h> // inclui a biblioteca do modulo lcd 
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *      Rotina que envia um COMANDO para o LCD                 * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void comando_lcd(int caracter) 
.................... { 
....................    rs = 0;               // seleciona o envio de um caracter 
*
000C:  BCF    F84.0
....................    portd = caracter;         // carrega o portc com o caracter 
000E:  MOVFF  42,F83
....................    enable = 1 ;            // gera pulso no enable 
0012:  BSF    F84.1
....................    delay_us(1);            // espera 1 microsegundos 
0014:  BRA    0016
0016:  BRA    0018
0018:  NOP   
....................    enable = 0;            // desce o pino de enable 
001A:  BCF    F84.1
....................  
....................    delay_us(40);            // espera mínimo 40 microsegundos 
001C:  MOVLW  42
001E:  MOVWF  00
0020:  DECFSZ 00,F
0022:  BRA    0020
0024:  NOP   
....................     
....................    return;               // retorna 
0026:  RETURN 0
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *      Rotina que envia um DADO a ser escrito no LCD              * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void escreve_lcd(int caracter) 
.................... { 
....................    rs = 1;               // seleciona o envio de um comando 
*
1A3A:  BSF    F84.0
....................    portd = caracter;         // carrega o portc com o valor do comando 
1A3C:  MOVFF  4F,F83
....................    enable = 1;            // gera pulso no enable 
1A40:  BSF    F84.1
....................    delay_us(1);            // espera 3 microsegundos 
1A42:  BRA    1A44
1A44:  BRA    1A46
1A46:  NOP   
....................    enable = 0;            // desce o pino de enable 
1A48:  BCF    F84.1
....................  
....................    delay_us(40);            // espera mínimo 40 microsegundos 
1A4A:  MOVLW  42
1A4C:  MOVWF  00
1A4E:  DECFSZ 00,F
1A50:  BRA    1A4E
1A52:  NOP   
....................     
....................    return;               // retorna 
1A54:  RETURN 0
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *              Função para limpar o LCD                 * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void limpa_lcd() 
.................... { 
....................    comando_lcd(0x01);         // limpa lcd    
*
004E:  MOVLW  01
0050:  MOVWF  42
0052:  RCALL  000C
....................    delay_ms (2); 
0054:  MOVLW  02
0056:  MOVWF  43
0058:  RCALL  0028
....................    return; 
005A:  GOTO   0088 (RETURN)
.................... } 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *           Inicialização do Display de LCD                 * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void inicializa_lcd() 
.................... { 
....................    comando_lcd(0x30);         // envia comando para inicializar display 
005E:  MOVLW  30
0060:  MOVWF  42
0062:  RCALL  000C
....................    delay_ms(4);            // espera 4 milisengundos 
0064:  MOVLW  04
0066:  MOVWF  43
0068:  RCALL  0028
....................  
....................    comando_lcd(0x30);         // envia comando para inicializar display 
006A:  MOVLW  30
006C:  MOVWF  42
006E:  RCALL  000C
....................    delay_us(100);            // espera 100 microsengundos 
0070:  MOVLW  A6
0072:  MOVWF  00
0074:  DECFSZ 00,F
0076:  BRA    0074
0078:  NOP   
....................  
....................    comando_lcd(0x30);         // envia comando para inicializar display 
007A:  MOVLW  30
007C:  MOVWF  42
007E:  RCALL  000C
....................  
....................    comando_lcd(0x38);         // liga o display, sem cursor e sem blink 
0080:  MOVLW  38
0082:  MOVWF  42
0084:  RCALL  000C
....................  
....................    limpa_lcd();            // limpa lcd 
0086:  BRA    004E
....................  
....................    comando_lcd(0x0c);         // display sem cursor 
0088:  MOVLW  0C
008A:  MOVWF  42
008C:  RCALL  000C
....................  
....................    comando_lcd(0x06);         // desloca cursor para a direita 
008E:  MOVLW  06
0090:  MOVWF  42
0092:  RCALL  000C
....................  
....................    return;               // retorna 
0094:  GOTO   1CA2 (RETURN)
.................... }    
....................  
....................  
....................  
.................... char message2[] = "RH   = 00.0 %"; //  vetor de mensagem para a umidade  
.................... short Time_out; //  variavel para as funçoes referentes ao sensor de umidade dht11 
.................... unsigned  int8 RH_byte1, RH_byte2, CheckSum; //  variaveis para as funçoes do dht11 
....................  
.................... float ntc_val = 0; // variavel responsavel por receber o valor digital do ntc 
.................... float rntc = 0; //  valor da resistencia do divisor de tensao do ntc  
.................... float b1=0;  //  variavel auxiliar para função do ntc 
.................... float c1=0;//  variavel auxiliar para função do ntc 
.................... float temp=0;//  variavel auxiliar para função do ntc 
.................... float temperatura=0;//  variavel auxiliar para função do ntc 
.................... char umidade;//  variavel auxiliar para função do ntc 
....................  double a = 0.0011303; //  constantes fisicas do sensor ntc 10k 
....................  double b = 0.0002339; //  constantes fisicas do sensor ntc 10k 
....................  double c = 0.00000008863; //  constantes fisicas do sensor ntc 10k 
.................... int cont=0; 
....................  
....................  
.................... // FUNÇÃO POR INICIAR A DHT11 
....................  
.................... void start_signal(){ 
....................   Data_Pin_Direction = 0;              // Configure connection pin as output 
*
17EC:  BCF    x86.7
....................   Data_Pin = 0;                        // Connection pin output low 
17EE:  BCF    06.7
....................   delay_ms(25); 
17F0:  MOVLW  19
17F2:  MOVWF  43
17F4:  CALL   0028
....................   Data_Pin = 1;                        // Connection pin output high 
17F8:  BSF    06.7
....................   delay_us(30); 
17FA:  MOVLW  31
17FC:  MOVWF  00
17FE:  DECFSZ 00,F
1800:  BRA    17FE
1802:  BRA    1804
....................   Data_Pin_Direction = 1;              // Configure connection pin as input 
1804:  BSF    x86.7
1806:  GOTO   1910 (RETURN)
.................... } 
....................  
.................... // FUNÇAÕ POR VERIFICAR SE O SENSOR ESTA RESPONDENDO  
....................  
....................   short check_response(){ 
....................   delay_us(40); 
180A:  MOVLW  42
180C:  MOVWF  00
180E:  DECFSZ 00,F
1810:  BRA    180E
1812:  NOP   
....................   if(!Data_Pin){                     // Read and test if connection pin is low 
1814:  BTFSC  06.7
1816:  BRA    1838
....................     delay_us(80); 
1818:  MOVLW  84
181A:  MOVWF  00
181C:  DECFSZ 00,F
181E:  BRA    181C
1820:  BRA    1822
1822:  NOP   
....................     if(Data_Pin){                    // Read and test if connection pin is high 
1824:  BTFSS  06.7
1826:  BRA    1838
....................       delay_us(50); 
1828:  MOVLW  52
182A:  MOVWF  00
182C:  DECFSZ 00,F
182E:  BRA    182C
1830:  BRA    1832
1832:  NOP   
....................       return 1;} 
1834:  MOVLW  01
1836:  MOVWF  01
....................     } 
1838:  GOTO   1912 (RETURN)
.................... } 
....................  
....................  
.................... // FUNÇÃO PARA A OBTENÇÃO DO VALOR DE HUMIDADE 
.................... unsigned int8 Read_Data(){ 
183C:  CLRF   44
....................   unsigned int8 i, k, _data = 0;     // k is used to count 1 bit reading duration 
....................   if(Time_out) 
183E:  BTFSS  18.0
1840:  BRA    1842
....................     break; 
....................   for(i = 0; i < 8; i++){ 
1842:  CLRF   42
1844:  MOVF   42,W
1846:  SUBLW  07
1848:  BNC   18CE
....................     k = 0; 
184A:  CLRF   43
....................     while(!Data_Pin){                          // Wait until pin goes high 
184C:  BTFSC  06.7
184E:  BRA    1864
....................       k++; 
1850:  INCF   43,F
....................       if (k > 100) {Time_out = 1; break;} 
1852:  MOVF   43,W
1854:  SUBLW  64
1856:  BC    185C
1858:  BSF    18.0
185A:  BRA    1864
....................       delay_us(1);} 
185C:  BRA    185E
185E:  BRA    1860
1860:  NOP   
1862:  BRA    184C
....................     delay_us(30); 
1864:  MOVLW  31
1866:  MOVWF  00
1868:  DECFSZ 00,F
186A:  BRA    1868
186C:  BRA    186E
....................     if(!Data_Pin) 
186E:  BTFSC  06.7
1870:  BRA    1894
....................       bit_clear(_data, (7 - i));               // Clear bit (7 - i) 
1872:  MOVLW  07
1874:  BSF    FD8.0
1876:  SUBFWB 42,W
1878:  MOVWF  45
187A:  MOVLW  01
187C:  MOVWF  00
187E:  MOVF   45,W
1880:  MOVWF  01
1882:  BZ    188C
1884:  BCF    FD8.0
1886:  RLCF   00,F
1888:  DECFSZ 01,F
188A:  BRA    1884
188C:  MOVF   00,W
188E:  XORLW  FF
1890:  ANDWF  44,F
1892:  BRA    18CA
....................     else{ 
....................       bit_set(_data, (7 - i));                 // Set bit (7 - i) 
1894:  MOVLW  07
1896:  BSF    FD8.0
1898:  SUBFWB 42,W
189A:  MOVWF  45
189C:  MOVLW  01
189E:  MOVWF  00
18A0:  MOVF   45,W
18A2:  MOVWF  01
18A4:  BZ    18AE
18A6:  BCF    FD8.0
18A8:  RLCF   00,F
18AA:  DECFSZ 01,F
18AC:  BRA    18A6
18AE:  MOVF   00,W
18B0:  IORWF  44,F
....................       while(Data_Pin){                         // Wait until pin goes low 
18B2:  BTFSS  06.7
18B4:  BRA    18CA
....................       k++; 
18B6:  INCF   43,F
....................       if (k > 100) {Time_out = 1; break;} 
18B8:  MOVF   43,W
18BA:  SUBLW  64
18BC:  BC    18C2
18BE:  BSF    18.0
18C0:  BRA    18CA
....................       delay_us(1);} 
18C2:  BRA    18C4
18C4:  BRA    18C6
18C6:  NOP   
18C8:  BRA    18B2
....................     } 
18CA:  INCF   42,F
18CC:  BRA    1844
....................   } 
....................   return _data; 
18CE:  MOVFF  44,01
18D2:  RETURN 0
.................... } 
....................  
.................... // FUNÇÃO PRINCIPAL QUE RETORNARA A UMIDADE  
....................  
.................... char dht11(){ 
....................    delay_ms(1000); 
*
18FC:  MOVLW  04
18FE:  MOVWF  42
1900:  MOVLW  FA
1902:  MOVWF  43
1904:  CALL   0028
1908:  DECFSZ 42,F
190A:  BRA    1900
....................    Time_out = 0; 
190C:  BCF    18.0
....................    Start_signal(); 
190E:  BRA    17EC
....................    if(check_response()){// If there is response from sensor 
1910:  BRA    180A
1912:  MOVF   01,F
1914:  BZ    1960
....................    RH_byte1=Read_Data();// read RH byte1 
1916:  RCALL  183C
1918:  MOVFF  01,19
....................    RH_byte2=Read_Data();// read RH byte2 
191C:  RCALL  183C
191E:  MOVFF  01,1A
....................    Checksum=Read_Data();// read checksum                    
1922:  RCALL  183C
1924:  MOVFF  01,1B
....................       if(CheckSum==((RH_Byte1+RH_Byte2)& 0xFF)){ 
1928:  MOVF   1A,W
192A:  ADDWF  19,W
192C:  SUBWF  1B,W
192E:  BNZ   1960
....................       message2[7]=RH_Byte1/10+48; 
1930:  MOVFF  19,42
1934:  MOVLW  0A
1936:  MOVWF  43
1938:  RCALL  18D4
193A:  MOVLW  30
193C:  ADDWF  01,W
193E:  MOVWF  11
....................              message2[8]= RH_Byte1%10+48; 
1940:  MOVFF  19,42
1944:  MOVLW  0A
1946:  MOVWF  43
1948:  RCALL  18D4
194A:  MOVLW  30
194C:  ADDWF  00,W
194E:  MOVWF  12
....................              message2[10] = RH_Byte2/10+48;                             
1950:  MOVFF  1A,42
1954:  MOVLW  0A
1956:  MOVWF  43
1958:  RCALL  18D4
195A:  MOVLW  30
195C:  ADDWF  01,W
195E:  MOVWF  14
....................        } 
....................    }  
....................    return message2; 
1960:  MOVLW  0A
1962:  MOVWF  01
1964:  MOVLW  00
1966:  MOVWF  02
1968:  GOTO   1CB6 (RETURN)
.................... } 
....................  
....................  
....................  
....................  
.................... float ntc(){ 
.................... set_adc_channel(0); //  escolhe o pino analogico para ler   
*
1520:  MOVLW  00
1522:  MOVWF  01
1524:  MOVF   FC2,W
1526:  ANDLW  C3
1528:  IORWF  01,W
152A:  MOVWF  FC2
.................... delay_us(10); // delay para começar a conversão 
152C:  MOVLW  10
152E:  MOVWF  00
1530:  DECFSZ 00,F
1532:  BRA    1530
1534:  NOP   
.................... read_adc(ADC_START_ONLY ); 
1536:  BSF    FC2.1
.................... while(!adc_done()){ 
1538:  BTFSS  FC2.1
153A:  BRA    153E
153C:  BRA    1538
.................... } 
.................... ntc_val = read_adc(ADC_READ_ONLY ); // le o valor na porta analogica 
153E:  BTFSC  FC2.1
1540:  BRA    153E
1542:  MOVFF  FC4,03
1546:  MOVFF  FC3,72
154A:  MOVFF  FC4,73
154E:  CALL   0098
1552:  MOVFF  03,1F
1556:  MOVFF  02,1E
155A:  MOVFF  01,1D
155E:  MOVFF  00,1C
.................... ntc_val *=5; // multiplica o valor digitalizado pelo valor de tensão de alimentação 
1562:  MOVFF  1F,71
1566:  MOVFF  1E,70
156A:  MOVFF  1D,6F
156E:  MOVFF  1C,6E
1572:  CLRF   x75
1574:  CLRF   x74
1576:  MOVLW  20
1578:  MOVWF  x73
157A:  MOVLW  81
157C:  MOVWF  x72
157E:  CALL   00CE
1582:  MOVFF  03,1F
1586:  MOVFF  02,1E
158A:  MOVFF  01,1D
158E:  MOVFF  00,1C
.................... ntc_val/=1023;  // divide  o valor acima por 1023 
1592:  MOVFF  1F,6A
1596:  MOVFF  1E,69
159A:  MOVFF  1D,68
159E:  MOVFF  1C,67
15A2:  CLRF   x6E
15A4:  MOVLW  C0
15A6:  MOVWF  x6D
15A8:  MOVLW  7F
15AA:  MOVWF  x6C
15AC:  MOVLW  88
15AE:  MOVWF  x6B
15B0:  CALL   01C0
15B4:  MOVFF  03,1F
15B8:  MOVFF  02,1E
15BC:  MOVFF  01,1D
15C0:  MOVFF  00,1C
.................... // Inicio calculo de equação de  Steinhart & Hart  
.................... rntc=50000/ntc_val;      
15C4:  CLRF   x6A
15C6:  MOVLW  50
15C8:  MOVWF  x69
15CA:  MOVLW  43
15CC:  MOVWF  x68
15CE:  MOVLW  8E
15D0:  MOVWF  x67
15D2:  MOVFF  1F,6E
15D6:  MOVFF  1E,6D
15DA:  MOVFF  1D,6C
15DE:  MOVFF  1C,6B
15E2:  CALL   01C0
15E6:  MOVFF  03,23
15EA:  MOVFF  02,22
15EE:  MOVFF  01,21
15F2:  MOVFF  00,20
....................        rntc=rntc-10000;       
15F6:  BSF    FD8.1
15F8:  MOVFF  23,75
15FC:  MOVFF  22,74
1600:  MOVFF  21,73
1604:  MOVFF  20,72
1608:  CLRF   x79
160A:  MOVLW  40
160C:  MOVWF  x78
160E:  MOVLW  1C
1610:  MOVWF  x77
1612:  MOVLW  8C
1614:  MOVWF  x76
1616:  CALL   031A
161A:  MOVFF  03,23
161E:  MOVFF  02,22
1622:  MOVFF  01,21
1626:  MOVFF  00,20
....................        b1=log(rntc);           
162A:  MOVFF  23,51
162E:  MOVFF  22,50
1632:  MOVFF  21,4F
1636:  MOVFF  20,4E
163A:  CALL   0642
163E:  MOVFF  03,27
1642:  MOVFF  02,26
1646:  MOVFF  01,25
164A:  MOVFF  00,24
....................        b1=b1*b;                
164E:  MOVFF  27,71
1652:  MOVFF  26,70
1656:  MOVFF  25,6F
165A:  MOVFF  24,6E
165E:  MOVFF  3C,75
1662:  MOVFF  3B,74
1666:  MOVFF  3A,73
166A:  MOVFF  39,72
166E:  CALL   00CE
1672:  MOVFF  03,27
1676:  MOVFF  02,26
167A:  MOVFF  01,25
167E:  MOVFF  00,24
....................        c1=log(rntc);           
1682:  MOVFF  23,51
1686:  MOVFF  22,50
168A:  MOVFF  21,4F
168E:  MOVFF  20,4E
1692:  CALL   0642
1696:  MOVFF  03,2B
169A:  MOVFF  02,2A
169E:  MOVFF  01,29
16A2:  MOVFF  00,28
....................        c1=pow(c1,3);           
16A6:  MOVFF  2B,45
16AA:  MOVFF  2A,44
16AE:  MOVFF  29,43
16B2:  MOVFF  28,42
16B6:  CLRF   49
16B8:  CLRF   48
16BA:  MOVLW  40
16BC:  MOVWF  47
16BE:  MOVLW  80
16C0:  MOVWF  46
16C2:  BRA    124A
16C4:  MOVFF  03,2B
16C8:  MOVFF  02,2A
16CC:  MOVFF  01,29
16D0:  MOVFF  00,28
....................        c1=c1*c;                
16D4:  MOVFF  2B,71
16D8:  MOVFF  2A,70
16DC:  MOVFF  29,6F
16E0:  MOVFF  28,6E
16E4:  MOVFF  40,75
16E8:  MOVFF  3F,74
16EC:  MOVFF  3E,73
16F0:  MOVFF  3D,72
16F4:  CALL   00CE
16F8:  MOVFF  03,2B
16FC:  MOVFF  02,2A
1700:  MOVFF  01,29
1704:  MOVFF  00,28
....................        temp=a+b1+c1;           
1708:  BCF    FD8.1
170A:  MOVFF  38,75
170E:  MOVFF  37,74
1712:  MOVFF  36,73
1716:  MOVFF  35,72
171A:  MOVFF  27,79
171E:  MOVFF  26,78
1722:  MOVFF  25,77
1726:  MOVFF  24,76
172A:  CALL   031A
172E:  MOVFF  03,45
1732:  MOVFF  02,44
1736:  MOVFF  01,43
173A:  MOVFF  00,42
173E:  BCF    FD8.1
1740:  MOVFF  03,75
1744:  MOVFF  02,74
1748:  MOVFF  01,73
174C:  MOVFF  00,72
1750:  MOVFF  2B,79
1754:  MOVFF  2A,78
1758:  MOVFF  29,77
175C:  MOVFF  28,76
1760:  CALL   031A
1764:  MOVFF  03,2F
1768:  MOVFF  02,2E
176C:  MOVFF  01,2D
1770:  MOVFF  00,2C
....................        temp=1/temp;            
1774:  CLRF   x6A
1776:  CLRF   x69
1778:  CLRF   x68
177A:  MOVLW  7F
177C:  MOVWF  x67
177E:  MOVFF  2F,6E
1782:  MOVFF  2E,6D
1786:  MOVFF  2D,6C
178A:  MOVFF  2C,6B
178E:  CALL   01C0
1792:  MOVFF  03,2F
1796:  MOVFF  02,2E
179A:  MOVFF  01,2D
179E:  MOVFF  00,2C
....................        temp=temp-273.15; 
17A2:  BSF    FD8.1
17A4:  MOVFF  2F,75
17A8:  MOVFF  2E,74
17AC:  MOVFF  2D,73
17B0:  MOVFF  2C,72
17B4:  MOVLW  33
17B6:  MOVWF  x79
17B8:  MOVLW  93
17BA:  MOVWF  x78
17BC:  MOVLW  08
17BE:  MOVWF  x77
17C0:  MOVLW  87
17C2:  MOVWF  x76
17C4:  CALL   031A
17C8:  MOVFF  03,2F
17CC:  MOVFF  02,2E
17D0:  MOVFF  01,2D
17D4:  MOVFF  00,2C
....................        return temp; 
17D8:  MOVFF  2C,00
17DC:  MOVFF  2D,01
17E0:  MOVFF  2E,02
17E4:  MOVFF  2F,03
17E8:  GOTO   1CA4 (RETURN)
.................... // Fim do calculo de equação de  Steinhart & Hart 
.................... } 
....................  
....................  
.................... int tratamento_de_bouncing() { 
....................  
....................  
....................  
....................  
.................... //  Aqui será implementada uma função para o tratamento de bouncing de todos os botoes da aplicação  
....................  
....................  
....................  
....................  
....................  
....................  
.................... } 
....................  
....................  
.................... void mexeovos () { 
.................... // Essa função é responsável por controlar o servo motor que mexe os ovos 
.................... for( int j=0; j<=10; j++){  // j=50 é cerca de 5 min  
....................  // para garantir que a temperatura varie pouco enquanto o ovosestão mexendo faça   
....................    limpa_lcd(); 
....................    comando_lcd(0x83); //  posiciona o cursor no endereço 0x83 
....................    printf(escreve_lcd,"MEXENDO" ); 
....................    if(j%2==0){ 
....................    RELE_LAMP = 1; 
....................    PIN_COOLER = 0; 
....................    } 
....................      if(j%2!=0){ 
....................      RELE_LAMP = 0; 
....................      PIN_COOLER =1; 
....................      } 
.................... // termina aqui esse arficio  
....................       for(int i=0;  i<50; i++){                       
....................       PIN_SERV=1; 
....................       delay_us(800); 
....................       PIN_SERV=0; 
....................       delay_us(19200); 
....................       } 
....................       delay_ms(2000); 
....................       for(i=0;  i<50; i++){ 
....................       PIN_SERV=1; 
....................       delay_us(1500); 
....................       PIN_SERV=0; 
....................       delay_us(18500); 
....................       } 
....................       delay_ms(2000); 
....................  } 
....................     
.................... } 
....................  
.................... void main (void){ 
*
1BD2:  CLRF   FF8
1BD4:  BCF    FD0.7
1BD6:  CLRF   1F
1BD8:  CLRF   1E
1BDA:  CLRF   1D
1BDC:  CLRF   1C
1BDE:  CLRF   23
1BE0:  CLRF   22
1BE2:  CLRF   21
1BE4:  CLRF   20
1BE6:  CLRF   27
1BE8:  CLRF   26
1BEA:  CLRF   25
1BEC:  CLRF   24
1BEE:  CLRF   2B
1BF0:  CLRF   2A
1BF2:  CLRF   29
1BF4:  CLRF   28
1BF6:  CLRF   2F
1BF8:  CLRF   2E
1BFA:  CLRF   2D
1BFC:  CLRF   2C
1BFE:  CLRF   33
1C00:  CLRF   32
1C02:  CLRF   31
1C04:  CLRF   30
1C06:  MOVLW  93
1C08:  MOVWF  38
1C0A:  MOVLW  26
1C0C:  MOVWF  37
1C0E:  MOVLW  14
1C10:  MOVWF  36
1C12:  MOVLW  75
1C14:  MOVWF  35
1C16:  MOVLW  0E
1C18:  MOVWF  3C
1C1A:  MOVLW  43
1C1C:  MOVWF  3B
1C1E:  MOVLW  75
1C20:  MOVWF  3A
1C22:  MOVLW  72
1C24:  MOVWF  39
1C26:  MOVLW  DC
1C28:  MOVWF  40
1C2A:  MOVLW  54
1C2C:  MOVWF  3F
1C2E:  MOVLW  3E
1C30:  MOVWF  3E
1C32:  MOVLW  67
1C34:  MOVWF  3D
1C36:  CLRF   41
1C38:  MOVF   FC1,W
1C3A:  ANDLW  C0
1C3C:  IORLW  0F
1C3E:  MOVWF  FC1
1C40:  MOVLW  07
1C42:  MOVWF  FB4
1C44:  CLRF   04
1C46:  CLRF   05
1C48:  MOVLW  52
1C4A:  MOVWF  0A
1C4C:  MOVLW  48
1C4E:  MOVWF  0B
1C50:  MOVLW  A0
1C52:  MOVWF  0C
1C54:  MOVWF  0D
1C56:  MOVWF  0E
1C58:  MOVLW  3D
1C5A:  MOVWF  0F
1C5C:  MOVLW  A0
1C5E:  MOVWF  10
1C60:  MOVLW  30
1C62:  MOVWF  11
1C64:  MOVWF  12
1C66:  MOVLW  2E
1C68:  MOVWF  13
1C6A:  MOVLW  30
1C6C:  MOVWF  14
1C6E:  MOVLW  A0
1C70:  MOVWF  15
1C72:  MOVLW  25
1C74:  MOVWF  16
1C76:  CLRF   17
.................... setup_adc(ADC_CLOCK_DIV_32); //  configura o clock utilizado para o conversor ad e o pior clock ele usa a malha RC é lenta  
1C78:  MOVF   FC0,W
1C7A:  ANDLW  C0
1C7C:  IORLW  02
1C7E:  MOVWF  FC0
1C80:  BSF    FC0.7
1C82:  BSF    FC2.0
.................... setup_adc_ports( AN0_TO_AN2 ); // selecionaos pinos A0 a A2 como pinos de sinais analogicos  
1C84:  MOVF   FC1,W
1C86:  ANDLW  C0
1C88:  IORLW  0C
1C8A:  MOVWF  FC1
.................... set_tris_a(0b00001111); // verificar se pinos analogicos necessitam de definição de tris 
1C8C:  MOVLW  0F
1C8E:  MOVWF  F92
.................... set_tris_b(0b11000000);   
1C90:  MOVLW  C0
1C92:  MOVWF  F93
.................... set_tris_c(0b00000000);// define os pinos RB0 E RB1 como entrada e os demais como saida 
1C94:  MOVLW  00
1C96:  MOVWF  F94
.................... set_tris_d(0b00000000);  //  Idem como supracitado acima  
1C98:  MOVWF  F95
.................... set_tris_e(0b00000100); 
1C9A:  MOVLW  04
1C9C:  MOVWF  F96
.................... inicializa_lcd(); // função responsavel por inicializar o modulo lcd 
1C9E:  GOTO   005E
....................  
....................   while(true){ 
....................   temperatura = ntc(); //  le o valor  de temperatura em graus celsius que a função do ntc retorna  
1CA2:  BRA    1520
1CA4:  MOVFF  03,33
1CA8:  MOVFF  02,32
1CAC:  MOVFF  01,31
1CB0:  MOVFF  00,30
....................   umidade = dht11(); 
1CB4:  BRA    18FC
1CB6:  MOVFF  01,34
....................   comando_lcd(0x83); //  posiciona o cursor no endereço 0x83 
1CBA:  MOVLW  83
1CBC:  MOVWF  42
1CBE:  CALL   000C
....................   printf(escreve_lcd,"%f",temperatura); 
1CC2:  MOVLW  89
1CC4:  MOVWF  FE9
1CC6:  MOVFF  33,45
1CCA:  MOVFF  32,44
1CCE:  MOVFF  31,43
1CD2:  MOVFF  30,42
1CD6:  MOVLW  02
1CD8:  MOVWF  46
1CDA:  BRA    1A56
....................     // implementação da rotina de controle de  temperatura  
....................    if(temperatura<=38){   //  verifica se da temperatura de menor que 38 graus e faz  a rotina  
1CDC:  MOVFF  33,71
1CE0:  MOVFF  32,70
1CE4:  MOVFF  31,6F
1CE8:  MOVFF  30,6E
1CEC:  CLRF   x75
1CEE:  CLRF   x74
1CF0:  MOVLW  18
1CF2:  MOVWF  x73
1CF4:  MOVLW  84
1CF6:  MOVWF  x72
1CF8:  CALL   0584
1CFC:  BC    1D00
1CFE:  BNZ   1D04
....................      PIN_COOLER =0 ; 
1D00:  BCF    F82.0
....................      RELE_LAMP = 1 ; 
1D02:  BSF    F81.2
....................     } 
....................     if(temperatura>38){ 
1D04:  CLRF   x71
1D06:  CLRF   x70
1D08:  MOVLW  18
1D0A:  MOVWF  x6F
1D0C:  MOVLW  84
1D0E:  MOVWF  x6E
1D10:  MOVFF  33,75
1D14:  MOVFF  32,74
1D18:  MOVFF  31,73
1D1C:  MOVFF  30,72
1D20:  CALL   0584
1D24:  BNC   1D2A
....................     PIN_COOLER =1 ; 
1D26:  BSF    F82.0
....................     RELE_LAMP = 0 ;  
1D28:  BCF    F81.2
....................     } 
1D2A:  BRA    1CA2
....................     //delay_ms(2000);    
....................   } 
....................    
....................    
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... } 
1D2C:  SLEEP 

Configuration Fuses:
   Word  1: CC3F   PLL12 CPUDIV4 USBDIV HS FCMEN IESO
   Word  2: 1E38   PUT NOBROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
